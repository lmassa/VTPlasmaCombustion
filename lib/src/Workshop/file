#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "DataFileIF.H"

#include "NamespaceHeader.H"

using std::cin;

DataFileIF::DataFileIF(const DataFileIF::DataType& a_dataType,
                       const Real&                 a_value,
                       const bool&                 a_inside,
                       const bool&                 a_useCubicInterp)
{
  // Read an entire header from "cin" - see .H file
  ReadFullHeader(m_num,m_spacing,m_origin,cin);

  // Read all the data from "cin"
  ReadData(m_noDataValue,cin,a_dataType,m_num);

  // Save some state
  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::DataFileIF(const char* const           a_filename,
                       const DataFileIF::DataType& a_dataType,
                       const Real&                 a_value,
                       const bool&                 a_inside,
                       const bool&                 a_useCubicInterp)
{
  ifstream curFile;

  // Open the named file for input
  OpenFile(curFile,a_filename);

  // Read an entire header from the file - see .H file
  ReadFullHeader(m_num,m_spacing,m_origin,curFile);

  // Read all the data from the file
  ReadData(m_noDataValue,curFile,a_dataType,m_num);

  // Close the named file
  CloseFile(curFile);

  // Save some state
  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::DataFileIF(const DataFileIF::DataType& a_dataType,
                       const RealVect&             a_spacing,
                       const RealVect&             a_origin,
                       const Real&                 a_value,
                       const bool&                 a_inside,
                       const bool&                 a_useCubicInterp)
{
  // Read an dimension of the data from "cin" - see .H file
  ReadMinHeader(m_num,cin);

  // Save the other "header information"
  m_spacing = a_spacing;
  m_origin = a_origin;

  // Read all the data from "cin"
  ReadData(m_noDataValue,cin,a_dataType,m_num);

  // Save some state
  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::DataFileIF(const char* const           a_filename,
                       const DataFileIF::DataType& a_dataType,
                       const RealVect&             a_spacing,
                       const RealVect&             a_origin,
                       const Real&                 a_value,
                       const bool&                 a_inside,
                       const bool&                 a_useCubicInterp)
{
  ifstream curFile;

  // Open the named file for input
  OpenFile(curFile,a_filename);

  // Read an dimension of the data from the file - see .H file
  ReadMinHeader(m_num,curFile);

  // Save the other "header information"
  m_spacing = a_spacing;
  m_origin = a_origin;

  // Read all the data from the file
  ReadData(m_noDataValue,curFile,a_dataType,m_num);

  // Close the named file
  CloseFile(curFile);

  // Save some state
  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::DataFileIF(const DataFileIF::DataType& a_dataType,
                       const IntVect&              a_num,
                       const RealVect&             a_spacing,
                       const RealVect&             a_origin,
                       const Real&                 a_value,
                       const bool&                 a_inside,
                       const bool&                 a_useCubicInterp)
{
  // Save the "header information"
  m_num = a_num;
  m_spacing = a_spacing;
  m_origin = a_origin;

  // Read all the data from "cin"
  ReadData(m_noDataValue,cin,a_dataType,m_num);

  // Save some state
  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::DataFileIF(const char* const           a_filename,
                       const DataFileIF::DataType& a_dataType,
                       const IntVect&              a_num,
                       const RealVect&             a_spacing,
                       const RealVect&             a_origin,
                       const Real&                 a_value,
                       const bool&                 a_inside,
                       const bool&                 a_useCubicInterp)
{
  ifstream curFile;

  // Open the named file for input
  OpenFile(curFile,a_filename);

  // Save the "header information"
  m_num = a_num;
  m_spacing = a_spacing;
  m_origin = a_origin;

  // Read all the data from the file
  ReadData(m_noDataValue,curFile,a_dataType,m_num);

  // Close the named file
  CloseFile(curFile);

  // Save some state
  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::DataFileIF(const DataFileIF& a_inputIF)
{
  // Save a refcounted pointer to the data
  m_ascii_data  = a_inputIF.m_ascii_data;
  m_binary_data = a_inputIF.m_binary_data;
  m_noDataValue = a_inputIF.m_noDataValue;

  // Copy all the other data
  m_num = a_inputIF.m_num;

  m_spacing = a_inputIF.m_spacing;
  m_origin = a_inputIF.m_origin;

  m_value = a_inputIF.m_value;
  m_inside = a_inputIF.m_inside;
  m_useCubicInterp = a_inputIF.m_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::DataFileIF(const RefCountedPtr<FArrayBox>               a_ascii_data,
                       const RefCountedPtr<BaseFab<unsigned char> > a_binary_data,
                       const Real&                                  a_noDataValue,
                       const IntVect&                               a_num,
                       const RealVect&                              a_spacing,
                       const RealVect&                              a_origin,
                       const Real&                                  a_value,
                       const bool&                                  a_inside,
                       const bool&                                  a_useCubicInterp)
{
  // Save a refcounted pointer to the data
  m_ascii_data  = a_ascii_data;
  m_binary_data = a_binary_data;
  m_noDataValue = a_noDataValue;

  // Copy all the other data
  m_num = a_num;

  m_spacing = a_spacing;
  m_origin = a_origin;

  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;

  // Make the unit cube IntVectSet
  MakeCorners();
}

DataFileIF::~DataFileIF()
{
}

void DataFileIF::GetHeader(IntVect&  a_num,
                           RealVect& a_spacing,
                           RealVect& a_origin) const
{
  // Copy header information over
  a_num = m_num;
  a_spacing = m_spacing;
  a_origin = m_origin;
}

void DataFileIF::GetParams(Real& a_value,
                           bool& a_inside,
                           bool& a_useCubicInterp) const
{
  // Copy parameter information over
  a_value = m_value;
  a_inside = m_inside;
  a_useCubicInterp = m_useCubicInterp;
}

void DataFileIF::SetParams(const Real& a_value,
                           const bool& a_inside,
                           const bool& a_useCubicInterp)
{
  // Set parameter information
  m_value = a_value;
  m_inside = a_inside;
  m_useCubicInterp = a_useCubicInterp;
}

void DataFileIF::SetNoDataValue(const Real& a_value)
{
  // value to use when we are outside
  m_noDataValue = a_value;
}

Real DataFileIF::value(const RealVect& a_point) const
{
  IndexTM<Real,GLOBALDIM> point;

  for (int idir = 0; idir < SpaceDim; idir++)
  {
    point[idir] = a_point[idir];
  }

  for (int idir = SpaceDim; idir < GLOBALDIM; idir++)
  {
    point[idir] = 0.0;
  }

  return value(point);
}

Real DataFileIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{
  return value(IndexTM<int,GLOBALDIM>::Zero,a_point);
}

Real DataFileIF::value(const IndexTM<int,GLOBALDIM> & a_partialDerivative,
                       const IndexTM<Real,GLOBALDIM>& a_point) const
{
  Real retval;

  // The box of the stored data
  Box dataBox;
  if (m_ascii_data != NULL)
  {
    dataBox = m_ascii_data->box();
  }
  else
  {
    dataBox = m_binary_data->box();
  }

  // The index in the data corresponding to a_point
  IntVect loCorner;
  // The fraction of a cell from the low index to a_point
  IndexTM<Real,GLOBALDIM> fraction;

  // Determine the low index and the fraction
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    Real index;

    // The floating point "index" of a_point in the data
    index = (a_point[idir] - m_origin[idir]) / m_spacing[idir];

    // The integer portion of that "index"
    loCorner[idir] = (int)floor(index);

    // Make sure the low corner in one inside the high end of the data
    if (loCorner[idir] == dataBox.bigEnd(idir))
    {
      loCorner[idir] -= 1;
    }

    // The fraction portion of the "index"
    fraction[idir] = index - loCorner[idir];
  }

  for (int idir = SpaceDim; idir < GLOBALDIM; idir++)
  {
    Real index;

    // The floating point "index" of a_point in the data
    index = (a_point[idir] - m_origin[idir]) / m_spacing[idir];

    // The integer portion of that "index"
    int loCorner = (int)floor(index);

    // The fraction portion of the "index"
    fraction[idir] = index - loCorner;
  }

  if (!m_useCubicInterp)
  {
    Vector<Vector<Real> > linear(GLOBALDIM,Vector<Real>(2));
    bool zeroWeight = false;

    for (int idir = 0; idir < GLOBALDIM; idir++)
    {
        Real f = fraction[idir];

        if (a_partialDerivative[idir] == 0)
        {
          linear[idir][0] = (-f + 1.0);
          linear[idir][1] = ( f      );
        }
        else if (a_partialDerivative[idir] == 1)
        {
          linear[idir][0] = (-1.0);
          linear[idir][1] = ( 1.0);
        }
        else
        {
          linear[idir][0] = (0.0);
          linear[idir][1] = (0.0);

          zeroWeight = true;
        }
    }

    // If so, use multi-linear interpolation to get a return value
    retval = 0.0;

    if (!zeroWeight)
    {
      // Iterate over all the corners
      int comp = 0;
      IVSIterator ivsit(m_cornersLinear);
      for (ivsit.begin(); ivsit.ok(); ++ivsit)
      {
        IntVect curIV(loCorner);
        IntVect incIV(ivsit());
        Real curValue;

        // Index of the current data
        curIV += incIV;

        // Check to see if current index in insid the data
        if (dataBox.contains(curIV))
        {
          // If so, get the current data value
          if (m_ascii_data != NULL)
          {
            curValue = (*m_ascii_data)(curIV,comp);
          }
          else
          {
            curValue = (*m_binary_data)(curIV,comp);
          }
        }
        else
        {
          // If not, use the no data value
          curValue = m_noDataValue;
        } 

        // Weight it appropriate based on the index fractions computed above
        for (int idir = 0; idir < GLOBALDIM; idir++)
        {
          curValue *= linear[idir][incIV[idir]];
        }

        // Add it into the total
        retval += curValue;
      }
    }
  }
  else
  {
    Vector<Vector<Real> > cubic(GLOBALDIM,Vector<Real>(4));
    bool zeroWeight = false;

    for (int idir = 0; idir < GLOBALDIM; idir++)
    {
        Real f = fraction[idir];

        if (a_partialDerivative[idir] == 0)
        {
          cubic[idir][0] = (-0.5*f*f*f +     f*f - 0.5*f      );
          cubic[idir][1] = ( 1.5*f*f*f - 2.5*f*f         + 1.0);
          cubic[idir][2] = (-1.5*f*f*f + 2.0*f*f + 0.5*f      );
          cubic[idir][3] = ( 0.5*f*f*f - 0.5*f*f              );
        }
        else if (a_partialDerivative[idir] == 1)
        {
          cubic[idir][0] = (-1.5*f*f + 2.0*f - 0.5);
          cubic[idir][1] = ( 4.5*f*f - 5.0*f      );
          cubic[idir][2] = (-4.5*f*f + 4.0*f + 0.5);
          cubic[idir][3] = ( 1.5*f*f - 1.0*f      );
        }
        else if (a_partialDerivative[idir] == 2)
        {
          cubic[idir][0] = (-3.0*f + 2.0);
          cubic[idir][1] = ( 9.0*f - 5.0);
          cubic[idir][2] = (-9.0*f + 4.0);
          cubic[idir][3] = ( 3.0*f - 1.0);
        }
        else if (a_partialDerivative[idir] == 3)
        {
          cubic[idir][0] = (-3.0);
          cubic[idir][1] = ( 9.0);
          cubic[idir][2] = (-9.0);
          cubic[idir][3] = ( 3.0);
        }
        else
        {
          cubic[idir][0] = (0.0);
          cubic[idir][1] = (0.0);
          cubic[idir][2] = (0.0);
          cubic[idir][3] = (0.0);

          zeroWeight = true;
        }
    }

    // If so, use multi-cubic interpolation to get a return value
    retval = 0.0;

    if (!zeroWeight)
    {
      // Iterate over all the corners
      int comp = 0;
      IVSIterator ivsit(m_cornersCubic);
      for (ivsit.begin(); ivsit.ok(); ++ivsit)
      {
        IntVect curIV(loCorner);
        IntVect incIV(ivsit());
        Real curValue;

        // Index of the current data
        curIV += incIV;

        // Check to see if current index in insid the data
        if (dataBox.contains(curIV))
        {
          // If so, get the current data value
          if (m_ascii_data != NULL)
          {
            curValue = (*m_ascii_data)(curIV,comp);
          }
          else
          {
            curValue = (*m_binary_data)(curIV,comp);
          }
        }
        else
        {
          // If not, use the no data value
          curValue = m_noDataValue;
        }

        // Weight it appropriate based on the index fractions computed above
        for (int idir = 0; idir < GLOBALDIM; idir++)
        {
          curValue *= cubic[idir][incIV[idir]+1];
        }

        // Add it into the total
        retval += curValue;
      }
    }
  }

  if (a_partialDerivative.sum() == 0)
  {
    // Adjust the level set from zero to m_value
    retval -= m_value;
  }

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

BaseIF* DataFileIF::newImplicitFunction() const
{
  DataFileIF* dataFilePtr = new DataFileIF(m_ascii_data,
                                           m_binary_data,
                                           m_noDataValue,
                                           m_num,
                                           m_spacing,
                                           m_origin,
                                           m_value,
                                           m_inside,
                                           m_useCubicInterp);

  return static_cast<BaseIF*>(dataFilePtr);
}

void DataFileIF::OpenFile(ifstream&         a_file,
                          const char* const a_filename)
{
  a_file.open(a_filename);

  if (!a_file.good())
  {
    MayDay::Abort("DataFileIF::OpenFile - Unable to open data file");
  }
}

void DataFileIF::CloseFile(ifstream& a_file)
{
  a_file.close();
}

void DataFileIF::ReadMinHeader(IntVect& a_num,
                               istream& a_file)
{
  char curLine[1024];
  int length = 1024;

  // Read first line - number of grid points in each direction
  a_file.getline(curLine,length);

  int num[3];
  int numFound;

  numFound = sscanf(curLine,"%d%d%d",&num[0],&num[1],&num[2]);

  if (numFound < SpaceDim)
  {
    MayDay::Abort("DataFileIF::ReadMinHeader - Unable to read number of grid points in each direction from data file");
  }
  else
  {
    if (numFound > SpaceDim)
    {
      MayDay::Warning("Found more entries in header line than the number of dimensions - wrong dimension data?");
    }

    for (int idir = 0; idir < SpaceDim; idir++)
    {
      a_num[idir] = num[idir];
    }
  }
}

void DataFileIF::ReadFullHeader(IntVect& a_num,
                                RealVect& a_spacing,
                                RealVect& a_origin,
                                istream&  a_file)
{
  char curLine[1024];
  int length = 1024;

  // Read first line - number of grid points in each direction
  a_file.getline(curLine,length);

  int num[3];
  int numFound;

  numFound = sscanf(curLine,"%d%d%d",&num[0],&num[1],&num[2]);

  if (numFound < SpaceDim)
  {
    MayDay::Abort("DataFileIF::ReadFullHeader - Unable to read number of grid points in each direction from data file");
  }
  else
  {
    if (numFound > SpaceDim)
    {
      MayDay::Warning("Found more entries in header line than the number of dimensions - wrong dimension data?");
    }

    for (int idir = 0; idir < SpaceDim; idir++)
    {
      a_num[idir] = num[idir];
    }
  }

  // Read second line - grid spacing
  a_file.getline(curLine,length);

  double spacing[3];

  numFound = sscanf(curLine,"%lf%lf%lf",&spacing[0],&spacing[1],&spacing[2]);

  if (numFound < SpaceDim)
  {
    MayDay::Abort("DataFileIF::ReadFullHeader - Unable to read number of grid spacing from data file");
  }
  else
  {
    if (numFound > SpaceDim)
    {
      MayDay::Warning("Found more entries in header line than the number of dimensions - wrong dimension data?");
    }

    for (int idir = 0; idir < SpaceDim; idir++)
    {
      a_spacing[idir] = spacing[idir];
    }
  }

  // Read third line - grid origin
  a_file.getline(curLine,length);

  double origin[3];

  numFound = sscanf(curLine,"%lf%lf%lf",&origin[0],&origin[1],&origin[2]);

  if (numFound < SpaceDim)
  {
    MayDay::Abort("DataFileIF::ReadFullHeader - Unable to read number of grid origin from data file");
  }
  else
  {
    if (numFound > SpaceDim)
    {
      MayDay::Warning("Found more entries in header line than the number of dimensions - wrong dimension data?");
    }

    for (int idir = 0; idir < SpaceDim; idir++)
    {
      a_origin[idir] = origin[idir];
    }
  }
}

void DataFileIF::ReadData(Real&                       a_maxValue,
                          istream&                    a_file,
                          const DataFileIF::DataType& a_dataType,
                          const IntVect&              a_num)
{
  // Maximum index IntVect
  IntVect a_max = a_num;
  a_max -= IntVect::Unit;

  // Box where the data is defined
  Box dataBox(IntVect::Zero,a_max);

  // Check data type to be read
  if (a_dataType == DataFileIF::ASCII)
  {
    // ASCII data - read the data one entry at a time

    // The data has one component
    RefCountedPtr<FArrayBox> data(new FArrayBox(dataBox,1));

    // Start all loop counters at zero
    IntVect state(IntVect::Zero);
    int comp = 0;

    bool first = true;
    a_maxValue = 0.0;

    // Loop until all loop counters are done
    while (state[SpaceDim-1] < a_num[SpaceDim-1])
    {
      Real curInput;

      if (a_dataType == DataFileIF::ASCII)
      {
        // Read the next ASCII value and store the data
        a_file >> curInput;
      }
      else
      if (a_dataType == DataFileIF::Binary)
      {
        // Read the next binary byte and store the data
        unsigned char curChar;
        a_file.read((char *)(&curChar),1);

        curInput = curChar;
      }

      (*data)(state,comp) = curInput;

      // Update the maximum data value
      if (first || a_maxValue < curInput)
      {
        first = false;
        a_maxValue = curInput;
      }

      // Increment the indices as needed - increasing x most rapidly
      for (int i = 0; i < SpaceDim; i++)
      {
        // Increment the counter
        state[i]++;

        // Is the counter in bounds?
        if (state[i] < a_num[i])
        {
          // If so, continue reading data
          break;
        }
        else
        {
          // If not, zero the counter and increment the next (nested loops)
          // unless this is the outermost loop counter
          if (i < SpaceDim-1)
          {
            state[i] = 0;
          }
        }
      }
    }

    m_ascii_data = data;
    m_binary_data = RefCountedPtr<BaseFab<unsigned char> >(NULL);
  }
  else if (a_dataType == DataFileIF::Binary)
  {
    // Binary data - read the data one entry at a time

    // The data has one component
    RefCountedPtr<BaseFab<unsigned char> > data(new BaseFab<unsigned char>(dataBox,1));

    // Start all loop counters at zero
    IntVect state(IntVect::Zero);
    int comp = 0;

    bool first = true;
    a_maxValue = 0.0;

    // Loop until all loop counters are done
    while (state[SpaceDim-1] < a_num[SpaceDim-1])
    {
      Real curInput;

      if (a_dataType == DataFileIF::ASCII)
      {
        // Read the next ASCII value and store the data
        a_file >> curInput;
      }
      else
      if (a_dataType == DataFileIF::Binary)
      {
        // Read the next binary byte and store the data
        unsigned char curChar;
        a_file.read((char *)(&curChar),1);

        curInput = curChar;
      }

      (*data)(state,comp) = curInput;

      // Update the maximum data value
      if (first || a_maxValue < curInput)
      {
        first = false;
        a_maxValue = curInput;
      }

      // Increment the indices as needed - increasing x most rapidly
      for (int i = 0; i < SpaceDim; i++)
      {
        // Increment the counter
        state[i]++;

        // Is the counter in bounds?
        if (state[i] < a_num[i])
        {
          // If so, continue reading data
          break;
        }
        else
        {
          // If not, zero the counter and increment the next (nested loops)
          // unless this is the outermost loop counter
          if (i < SpaceDim-1)
          {
            state[i] = 0;
          }
        }
      }
    }

    m_ascii_data = RefCountedPtr<FArrayBox>(NULL);
    m_binary_data = data;
  }
  else
  {
    // Unknown data - an error
    MayDay::Abort("Unknow data type specified for data file");
  }
}

void DataFileIF::MakeCorners(void)
{
  // Make the end points of the linear interpolation box
  IntVect loLinear(0*IntVect::Unit);
  IntVect hiLinear(1*IntVect::Unit);

  // Make the unit cube box
  Box boxLinear(loLinear,hiLinear);

  // Save all its members (corners) as an IntVectSet
  m_cornersLinear.define(boxLinear);

  // Make the end points of the cubic interpolation box
  IntVect loCubic(-1*IntVect::Unit);
  IntVect hiCubic( 2*IntVect::Unit);

  // Make the unit cube box
  Box boxCubic(loCubic,hiCubic);

  // Save all its members (corners) as an IntVectSet
  m_cornersCubic.define(boxCubic);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

#include "GeometryService.H"
#include "GeometryShop.H"
#include "Moments.H"
#include "ConstrainedLS.H"
#include "PolyGeom.H"
#include "RealVect.H"
#include "parstream.H"

#include "NamespaceHeader.H"

ConstrainedLS::ConstrainedLS()
  :
  m_nbound(0),
  m_residual(LARGEREALVAL)
{
}

ConstrainedLS::LSResult ConstrainedLS::qrSolution(Real ** a,
                                                  Vector<Real> & x,
                                                  Vector<Real> & rhs,
                                                  Real         & resq)
{
  const int nCol = x.size();
  const int nRow = rhs.size();

  resq=-2.0;               // underdetermined
  if (nRow < nCol) return UNDERDETERMINED;
  resq=-1.0;               // singular

  //Rotates  into upper triangular form.
  for (int j = 0; j<nCol; ++j)
    {
      //   Find constants for rotation and diagonal entry.
      Real sq=0.0;
      for (int i = j; i<nRow; ++i)
        {
          sq+= a[i][j]*a[i][j];
        }
      if (sq == 0.0)
      {
        resq = -1.0; //singular
        return SINGULAR;
      }
      Real qv1= a[j][j] >= 0 ? -sqrt(sq) : sqrt(sq);
      Real u1=a[j][j] - qv1;
      a[j][j]=qv1;
      int j1=j + 1;
      //  Rotate remaining columns of sub-matrix.
      for (int jj = j1; jj<nCol ; ++jj)
        {
          Real dot=u1*a[j][jj];
          for (int i = j1; i<nRow ; ++i)
            {
              dot+=a[i][jj]*a[i][j];
            }
          Real constant=dot/Abs(qv1*u1);
          for (int i = j1; i<nRow ; ++i)
            {
              a[i][jj]-= constant*a[i][j]; // todo pointer
            }
          a[j][jj] -= constant*u1;
        }

      //  Rotate  rhs  vector.
      Real dot=u1*rhs[j];
      for (int i=j1; i<nRow; ++i)
        {
          dot+=rhs[i]*a[i][j];
        }

      Real constant=dot/Abs(qv1*u1);
      rhs[j]-=constant*u1;
      for (int i=j1; i<nRow; ++i)
        {
          rhs[i] -= constant*a[i][j];
        }
    }

  //  Solve triangular system by back-substitution.
  for (int ii = 0; ii<nCol; ++ii)
    {
      int i=nCol-(ii+1);
      Real sum=rhs[i];
      for (int j = i+1; j<nCol; ++j)
        {
          sum=sum - a[i][j]*x[j];
        }
      if (a[i][i] == 0.0) return SINGULAR;
      x[i]=sum/a[i][i];
    }
  // Find residual in overdetermined case.
  resq=0.0;
  for (int i = nCol; i<nRow; ++i)
    {
      resq+=rhs[i]*rhs[i];
    }
  return SUCCESS;
}

Real ConstrainedLS::getResidual() const
{
  return m_residual;
}


int ConstrainedLS::numberActiveConstraints() const
{
  return m_nbound;
}

Vector<ConstrainedLS::Bound> ConstrainedLS::getConstraints() const
{
  return m_boundState;
}


ConstrainedLS::LSResult ConstrainedLS::solveUnconstrained(Vector<Real>       & a_x,
                                           Real**               a_A,
                                           const Vector<Real> & a_rhs)
{
  Vector<Real>  lowBound(a_x.size());
  lowBound.assign(-HUGE);
  Vector<Real> highBound(a_x.size());
  highBound.assign(HUGE);
  return solveBoundConstrained(a_x,a_A,a_rhs,lowBound,highBound);
}

bool ConstrainedLS::boundsConsistent(const Vector<Real> & a_loBound,
                                     const Vector<Real> & a_hiBound) const
{
  bool retval = true;
  Real maxDiff = -LARGEREALVAL;
  for (int jbound = 0; jbound < a_loBound.size(); ++jbound)
  {
    retval &= (a_loBound[jbound] <= a_hiBound[jbound]);
    maxDiff = Max(maxDiff, (a_hiBound[jbound] - a_loBound[jbound]));
  }
  retval &= (maxDiff >= 0.0);
  return retval;
}

ConstrainedLS::LSResult ConstrainedLS::solveBoundConstrained(Vector<Real>      & x,
                                                             Real**              A,
                                                             const Vector<Real>& rhs,
                                                             const Vector<Real>& lowerBound,
                                                             const Vector<Real>& upperBound)
{
  const int NO_IFROM5 = -1234567;
  LSResult lastResultQR;
  // Note: in the past this eps actually mattered a lot in domains with flat sections
  // it got changed from 1.e-16
  const Real eps = 1.e-13;
  int numColsA = x.size();
  int numRowsA = rhs.size();
  int n = numColsA;
  int m = numRowsA;
  Real** act = NULL;
  allocArray(numRowsA,numColsA,act);
  Vector<Real> actResid(numRowsA);

  Vector<int> istate(x.size()+1);

  Real sj = 0.0; //todo: init correctly

  /*  Step 1.  Initialize everything--
      active and bound sets, initial values, etc.*/
  int mm = m <= n ? m : n;  // min m,n
  int jj = -1;       // index of last successful entry to active set
  int ifrom5 =NO_IFROM5;   // indicator step 6 entered from step 5 (sign
                    // gives bound, value gives index)
  bool from5Low = false;
  int iact = -1; //todo: check this
  int key = 1;   //todo: hardwire
  Vector<Real> w(n);
  Vector<Real> zz(n);
  vector<bool> isBoundLow(n);


  /*  Check bounds*/
  CH_assert(lowerBound.size() == upperBound.size());
  if (!boundsConsistent(lowerBound,upperBound))
    {
      pout() << "Inconsistent bounds in BVLS constrained least squares algorithm"<<endl;;
      return INCONSISTENT_BOUNDS;
    }

  m_nbound = 0;
  int nact = n-m_nbound;


  /* This initialization is only the warm start with all variables
     assumed active */

  for (int k = 0; k < numColsA ; ++k)
    {
      if (lowerBound[k] < 0.0 && upperBound[k] > 0.0)
        {
          x[k] = 0.0;
        }
      else if (lowerBound[k] == -HUGE)
        {
          x[k]=upperBound[k] - eps;
        }
      else if (upperBound[k] == HUGE)
        {
          x[k] = lowerBound[k] + eps;
        }
      else
        {
          x[k]=(lowerBound[k]+upperBound[k])/2.0;
        }
      istate[k] = k;
      isBoundLow[k]=false;
    }
  istate[numColsA] = 0; // m_nbound = 0


  // Compute bnorm, the norm of the data vector b, for reference.
  // todo:  Lapack?
  Real bsq=0.0;
  for (int i = 0; i < numRowsA ; ++ i)
    {
      bsq+= rhs[i]*rhs[i];
    }
  Real bnorm=sqrt(bsq);
  for (int iLoopA = 1; iLoopA < 3*n; ++iLoopA)
    {
      // Step 2: Initialize the negative gradient vector w
      Real obj = 0.0;
      for (int j=0; j < n; ++j)
        {
          w[j]=0.0;
        }
      for (int i=0; i<m; ++i)
        {
          Real ri=rhs[i];
          for (int j=0; j<n; ++j)
            {
              ri -= A[i][j]*x[j];
            }
          obj+= ri*ri;   // obj = || a.x - b ||.
          for (int j=0; j<n; ++j)
            {
              w[j] += A[i][j]*ri;
            }
          actResid[i]=ri;  //The residual vector is stored in the
                          //mm+1'st column of act(*,*).
                          // todo: seems kludgy
        }
      // Converged?  Stop if the misfit << || b ||,
      // or if all components are active (unless this is the
      // first iteration from a warm start).

      if ((sqrt(obj) <= bnorm*eps) || (iLoopA > 1 && m_nbound == 0))
        {
          istate[numColsA]=m_nbound;
          w[0]=sqrt(obj);
          m_residual=sqrt(obj);
          freeArray(numRowsA,numColsA,act);
          return lastResultQR;
        }

      // Add the contribution of the active components back into the residual.
        for (int k = m_nbound; k < n ; ++k)
          {
            int j=istate[k];
            for (int i=0; i<m; ++i)
              {
                actResid[i] += A[i][j]*x[j];
              }

          }

        //The first iteration in a warm start requires immediate qr.

        if (!(iLoopA == 1 && key != 0))
          {
            //Find the bound element that most wants to be active.
            findBound: Real worst=0.0;
            int it=1;
            for (int j=0; j<m_nbound; ++j)
              {
                int ks=istate[j];
                Real bad=isBoundLow[ks] ? -w[ks] : w[ks];
                if (bad < worst)
                  {
                    it=j;
                    worst=bad;
                    iact=ks; //todo: scope
                  }
              }

            // Test whether the Kuhn-Tucker condition is met.

            if (worst >= 0.0 )
              {
                istate[n]=m_nbound;
                w[0]=sqrt(obj);
                m_residual=sqrt(obj);
                freeArray(numRowsA,numColsA,act);
                return SUCCESS;
              }


         // The component  x(iact)  is the one that most wants to become active.
         // If the last successful change in the active set was to move x(iact)
         // to a bound, don't let x(iact) in now: set the derivative of the
         // misfit with respect to x(iact) to zero and return to the Kuhn-Tucker
         // test.
         if ( iact == jj )
           {
             w[jj]=0.0;
             goto findBound; //todo: came from old Fortran
           }

         // Step 5. Undo the effect of the new (potentially)
         // active variable on the residual vector.
         Real bound = isBoundLow[iact] ? lowerBound[iact] : upperBound[iact];
         for (int i=0; i<m; ++i)
           {
             actResid[i]+= bound*A[i][iact];
           }

         //  Set flag ifrom5, indicating that Step 6 was entered from Step 5.
         //  This forms the defined but not usedasis of a test for instability: the gradient
         //  calculation shows that x(iact) wants to join the active
         //  set; if
         //  qr puts x(iact) beyond the bound from which it came, the gradient
         //   calculation was in error and the variable should not have been
         //   introduced.

         ifrom5=istate[it]; //todo?
         from5Low=isBoundLow[ifrom5];

         //  Swap the indices (in istate) of the new active variable and the
         //   rightmost bound variable; `unbind' that location by decrementing
         //   m_nbound.

         istate[it]=istate[m_nbound-1]; //todo?
         m_nbound--;
         nact++;
         istate[m_nbound]=iact; //todo?
         isBoundLow[istate[m_nbound]] = false;

         if (mm < nact)
           {
             pout() << "Too many free variables in BVLS constrained least squares algorithm!";
             return UNDERDETERMINED;
           }
         }

         //Step 6.
         //Load array  act  with the appropriate columns of  a  for qr.  For
         //added stability, reverse the column ordering so that the most
         //recent addition to the active set is in the last column.  Also
         //copy the residual vector from act(., mm1) into act(.,
         //mm1+1).
         bool doQR = true;
         while (doQR)
           {
             Vector<Real> actResidCopy(numRowsA);
             zz.resize(nact);
             actResidCopy = actResid;
             // prepare for qr using active problem
             for (int i=0; i<m; ++i)
               {
                 for (int k=m_nbound; k<n; ++k)
                   {
                     int j=istate[k];
                     act[i][nact-1-k+m_nbound]=A[i][j]; //todo?
                   }
               }
             Real resq;
             lastResultQR = qrSolution(act,zz,actResidCopy,resq);

             //  Test for linear dependence in qr, and for an instability that moves
             //   the variable just introduced away from the feasible region
             //   (rather than into the region or all the way through it).
             //   In either case, remove the latest vector introduced from the
             //   active set and adjust the residual vector accordingly.
             //   Set the gradient component (w(iact)) to zero and return to
             //   the Kuhn-Tucker test.

             if (ifrom5 !=NO_IFROM5)
             {
               if (resq < 0.0
                   || (!from5Low && (zz[nact-1] > upperBound[iact]))
                   || ( from5Low && (zz[nact-1] < lowerBound[iact])))
                 {
                   m_nbound++;
                   isBoundLow[istate[m_nbound]] = (x[iact]-upperBound[iact] < 0.);

                   nact--;
                   for (int i=0; i<m; ++i)
                     {
                       actResid[i] -= x[iact]*A[i][iact]; //todo? iact
                     }
                   ifrom5=NO_IFROM5;
                   w[iact]=0.0;
                   goto findBound;   // came from old-school Fortran
                 }
               /*  If Step 6 was entered from Step 5 and we are here, a new variable
                   has been successfully introduced into the active set; the last
                   variable that was fixed at a bound is again permitted to become
                   active.*/
               jj=-1;
             }
             ifrom5=NO_IFROM5;
             int k1;
             bool foundInfeasible = false;
             // Step 7.  Check for strict feasibility of the new qr solution.
             for (int k=0; k<nact; ++k)
               {
                 k1=k;
                 int j=istate[k+m_nbound];
                   if (zz[nact-1-k] < lowerBound[j] ||
                       zz[nact-1-k] > upperBound[j])
                     {
                       foundInfeasible = true;
                       break;
                     }
               }
             if (! foundInfeasible)
               {
                 for (int k=0; k<nact; ++k)
                   {
                     int j=istate[k+m_nbound];
                     x[j]=zz[nact-1-k];
                   }
                 break; // get out of doQR to top of main loop
               }

             //  Steps 8, 9.
             Real alpha=2.0;
             Real alf=alpha;
             for (int k=k1; k<nact; ++k)//todo:
               {
                 int j=istate[k+m_nbound];
                 if (zz[nact-1-k] > upperBound[j])
                   {
                     alf=(upperBound[j]-x[j])/(zz[nact-1-k]-x[j]);
                   }
                 if (zz[nact-1-k] < lowerBound[j])
                   {
                     alf=(lowerBound[j]-x[j])/(zz[nact-1-k]-x[j]);
                   }
                 if (alf < alpha)
                   {
                     alpha=alf;
                     jj=j;
                     sj=(zz[nact-1-k]-lowerBound[j]) >= 0.0 ? 1. : -1.;
                   }
               }

             //  Step 10
             for (int k=0; k<nact; ++k)
               {
                 int j=istate[k+m_nbound];
                 x[j] += alpha*(zz[nact-1-k]-x[j]);
               }

             /*  Step 11.
                 Move the variable that determined alpha to the appropriate bound.
                 (jj is its index; sj is + if zz(jj)> upperBound(jj)] - if zz(jj)<bl(jj) ).
                 If any other component of  x  is infeasible at this stage, it must
                 be due to roundoff.  Bind every infeasible component and every
                 component at a bound to the appropriate bound.  Correct the
                 residual vector for any variables moved to bounds.  Since at least
                 one variable is removed from the active set in this step, Loop B
                 (Steps 6-11) terminates after at most  nact  steps.*/

             int noldb=m_nbound;
             for (int k=0; k<nact; ++k)
               {
                 int j=istate[k+noldb];
                 if (((upperBound[j]-x[j]) <= 0.0) ||
                     ((j==jj) && (sj > 0.0)))
                   {
                     x[j]=upperBound[j];
                     istate[k+noldb]=istate[m_nbound];
                     istate[m_nbound]=j;
                     m_nbound++;
                     for (int i=0; i<m; ++i)
                       {
                         actResid[i]-= upperBound[j]*A[i][j];
                       }
                   }
                 else if (((x[j]-lowerBound[j]) <= 0.0) ||
                          ((j == jj) && (sj < 0.0)))
                   {
                     x[j]=lowerBound[j];
                     istate[k+noldb]=istate[m_nbound];
                     istate[m_nbound]=j;
                     isBoundLow[j]=true;
                     m_nbound++;
                     for (int i=0; i<m ; ++i)
                       {
                         actResid[i]-= lowerBound[j]*A[i][j];
                       }
                   }
               }
             nact=n - m_nbound;
             // If there are still active variables left repeat the qr;
             doQR = (nact > 0 );
           } //doQR
    } //LoopA
  pout() << "BVLS constrained least squares algorithm failed to converge" <<endl;
  freeArray(numRowsA,numColsA,act);  //
                                     //todo: this isn't done anywhere
                                     //where it will be called
  return UNCONVERGED;
}



  void ConstrainedLS::allocArray(const int& rows,
                                 const int& cols,
                                 Real**& A)
{
  A = new Real* [rows];

  for (int i = 0; i < rows;i++)
    {
      A[i] = new Real [cols];
      Real* scanA = A[i];

      for (int j = 0; j < cols; j++)
        {
          *(scanA++) = 0.0;
        }
    }
}

void ConstrainedLS::freeArray(const int& rows,
                              const int& cols,
                              Real**& A)
{
  for (int i = 0; i < rows; i++)
    {
      delete[] A[i];
    }

  delete[] A;
}



#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>

#include "GeometryService.H"
#include "GeometryShop.H"

#include "PolyGeom.H"
#include "RealVect.H"

#include "NamespaceHeader.H"

bool GeometryShop::s_verbose = false;

GeometryShop::GeometryShop(const BaseIF& a_localGeom,
                           int           a_verbosity,
                           RealVect      a_vectDx,
                           Real          a_thrshdVoF)
  :m_phase(-1)
{
  CH_TIME("GeometryShop::GeometryShop");

  m_vectDx = a_vectDx;

  RealVect vectDx;
  vectDx = RealVect::Unit;
  PolyGeom::setVectDx(vectDx);

  m_implicitFunction = a_localGeom.newImplicitFunction();

  // See if this is an STL description - m_stlIF will be NULL if it isn't
  m_stlIF = dynamic_cast<const STLIF *>(m_implicitFunction);

  m_verbosity = a_verbosity;

  Real arg1 = 10.0;
  Real arg2 = -m_verbosity;

  m_threshold = 1.0e-15*pow(arg1, arg2);

  m_numCellsClipped = 0;

  m_thrshdVoF = a_thrshdVoF;

  m_STLBoxSet = false;
}

GeometryShop::~GeometryShop()
{
  delete(m_implicitFunction);
}

bool GeometryShop::twoEdgeIntersections(edgeMo a_edges[4])const
{
  bool retval;
  int count = 0;
  for (int iedge = 0;iedge<4;++iedge)
    {
      if (!a_edges[iedge].isCovered() && a_edges[iedge].getEdgeLength()<1.0)
        {
          count += 1;
        }
    }
  if (count >= 2 && count !=0)
    {
      retval = true;
    }
  else
    {
      retval = false;
    }
  return retval;
}

bool GeometryShop::isRegular(const Box&           a_region,
                             const ProblemDomain& a_domain,
                             const RealVect&      a_origin,
                             const Real&          a_dx) const
{
  CH_TIME("GeometryShop::isRegular");
  // set a vectDx
  RealVect vectDx = m_vectDx;

  // If this isn't an STL description then the value function works
  if (m_stlIF == NULL)
  {
    // first check any of the Box corners is outside, and return false
    // right away. (bvs)
    IntVect lo = a_region.smallEnd();
    IntVect len = a_region.size();
    Box unitBox(IntVect::Zero, IntVect::Unit);
    for (BoxIterator bit(unitBox); bit.ok(); ++bit)
      {
        IntVect current = lo + len*bit();
        RealVect physCorner;
        for (int idir = 0; idir < CH_SPACEDIM; ++idir)
          {
            physCorner[idir] = vectDx[idir]*current[idir] + a_origin[idir];
          }
        Real functionValue = m_implicitFunction->value(physCorner);
        if (functionValue > 0.0 )
          {
            return false;
          }
      }
  }

  return isRegularEveryPoint(a_region, a_domain, a_origin, a_dx);
}

bool GeometryShop::isRegularEveryPoint(const Box&           a_region,
                                       const ProblemDomain& a_domain,
                                       const RealVect&      a_origin,
                                       const Real&          a_dx) const
{
  CH_TIME("GeometryShop::isRegularEveryPoint");
  // set a vectDx
  RealVect vectDx = m_vectDx;

  // All corner indices for the current box
  Box allCorners(a_region);
  allCorners.surroundingNodes();

  RealVect physCorner;
  BoxIterator bit(allCorners);
  // If every corner is inside, the box is regular
  for (int i=0; i<2; i++)
    {
      for (; bit.ok(); ++bit, ++bit)
        {
          // Current corner
          const IntVect& corner = bit();

          // Compute physical coordinate of corner


          for (int idir = 0; idir < CH_SPACEDIM; ++idir)
            {
              physCorner[idir] = vectDx[idir]*corner[idir] + a_origin[idir];
            }

          if (m_stlIF == NULL)
          {
            // If the implicit function value is positive then the current
            // corner is outside the domain
            Real functionValue = m_implicitFunction->value(physCorner);

            if (functionValue > 0.0 )
              {
                return false;
              }
          }
          else
          {
            if (!m_STLBoxSet)
            {
              m_stlIF->getExplorer()->Explore(a_domain.domainBox(),a_domain,a_origin,vectDx);
              m_STLBoxSet = true;
            }

            MayDay::Error("STL not implemented");
          }
        }
      bit.reset();
      ++bit;
    }

  return true;
}

bool GeometryShop::isIrregular(const Box&           a_region,
                               const ProblemDomain& a_domain,
                               const RealVect&      a_origin,
                               const Real&          a_dx) const
{

  CH_TIME("GeometryShop::isIrregular");
  // set a vectDx
  RealVect vectDx = m_vectDx;

  // first check any of the Box corners is outside, and return false
  // right away. (bvs)
  RealVect physCorner;
  IntVect lo = a_region.smallEnd();
  IntVect len = a_region.size();
  for (int idir = 0; idir < CH_SPACEDIM; ++idir)
    {
      physCorner[idir] = vectDx[idir]*lo[idir] + a_origin[idir];
    }
  Real originVal = m_implicitFunction->value(physCorner);

  Box unitBox(IntVect::Zero, IntVect::Unit);
  for (BoxIterator bit(unitBox); bit.ok(); ++bit)
    {
      IntVect current = lo + len*bit();
      for (int idir = 0; idir < CH_SPACEDIM; ++idir)
        {
          physCorner[idir] = vectDx[idir]*current[idir] + a_origin[idir];
        }

      if (m_stlIF == NULL)
      {
        Real functionValue = m_implicitFunction->value(physCorner);
        if (functionValue * originVal < 0.0 )
          {
            return true;
          }
      }
      else
      {
        if (!m_STLBoxSet)
        {
          m_stlIF->getExplorer()->Explore(a_domain.domainBox(),a_domain,a_origin,vectDx);
          m_STLBoxSet = true;
        }

        MayDay::Error("STL not implemented");
      }
    }

  // return isIrregularEveryPoint(a_region, a_domain, a_origin, a_dx, originVal);
  return !(isRegularEveryPoint(a_region, a_domain, a_origin, a_dx) ||
           isCoveredEveryPoint(a_region, a_domain, a_origin, a_dx));
}

bool GeometryShop::isIrregularEveryPoint(const Box&           a_region,
                                         const ProblemDomain& a_domain,
                                         const RealVect&      a_origin,
                                         const Real&          a_dx,
                                         const Real&          a_originVal) const
{
  CH_TIME("GeometryShop::isIrregularEveryPoint");
  // set a vectDx
  RealVect vectDx = m_vectDx;

  // All corner indices for the current box
  Box allCorners(a_region);
  allCorners.surroundingNodes();

  RealVect physCorner;
  BoxIterator bit(allCorners);
  // If every corner is inside, the box is regular
  for (int i=0; i<2; i++)
    {
      for (; bit.ok(); ++bit, ++bit)
        {
          // Current corner
          IntVect corner = bit();

          // Compute physical coordinate of corner

          for (int idir = 0; idir < CH_SPACEDIM; ++idir)
            {
              physCorner[idir] = vectDx[idir]*corner[idir] + a_origin[idir];
            }

          if (m_stlIF == NULL)
          {
            // If the implicit function value is positive then the current
            // corner is outside the domain
            Real functionValue = m_implicitFunction->value(physCorner);

            if (functionValue * a_originVal < 0.0 )
              {
                return true;
              }
          }
          else
          {
            if (!m_STLBoxSet)
            {
              m_stlIF->getExplorer()->Explore(a_domain.domainBox(),a_domain,a_origin,vectDx);
              m_STLBoxSet = true;
            }

            MayDay::Error("STL not implemented");
          }
        }
      bit.reset();
      ++bit;
    }

  return false;
}

bool GeometryShop::isCovered(const Box&           a_region,
                             const ProblemDomain& a_domain,
                             const RealVect&      a_origin,
                             const Real&          a_dx) const
{
  CH_TIME("GeometryShop::isCovered");

  // set a vectDx
  RealVect vectDx = m_vectDx;

  // first check any of the Box corners is outside, and return false
  // right away. (bvs)
  RealVect physCorner;
  IntVect lo = a_region.smallEnd();
  IntVect len = a_region.size();
  Box unitBox(IntVect::Zero, IntVect::Unit);
  for (BoxIterator bit(unitBox); bit.ok(); ++bit)
    {
      IntVect current = lo + len*bit();
      for (int idir = 0; idir < CH_SPACEDIM; ++idir)
        {
          physCorner[idir] = vectDx[idir]*current[idir] + a_origin[idir];
        }

      if (m_stlIF == NULL)
      {
        Real functionValue = m_implicitFunction->value(physCorner);
        if (functionValue < 0.0 )
          {
            return false;
          }
      }
      else
      {
        if (!m_STLBoxSet)
        {
          m_stlIF->getExplorer()->Explore(a_domain.domainBox(),a_domain,a_origin,vectDx);
          m_STLBoxSet = true;
        }

        MayDay::Error("STL not implemented");
      }
    }

  return isCoveredEveryPoint(a_region, a_domain, a_origin, a_dx);
}

bool GeometryShop::isCoveredEveryPoint(const Box&           a_region,
                                       const ProblemDomain& a_domain,
                                       const RealVect&      a_origin,
                                       const Real&          a_dx) const
{
  CH_TIME("GeometryShop::isCoveredEveryPoint");
  // set a vectDx
  RealVect vectDx = m_vectDx;

  // All corner indices for the current box
  Box allCorners(a_region);
  allCorners.surroundingNodes();

  RealVect physCorner;
  BoxIterator bit(allCorners);
  // If every corner is inside, the box is regular
  for (int i=0; i<2; i++)
    {
      for (; bit.ok(); ++bit, ++bit)
        {
          // Current corner
          IntVect corner = bit();

          // Compute physical coordinate of corner

          for (int idir = 0; idir < CH_SPACEDIM; ++idir)
            {
              physCorner[idir] = vectDx[idir]*corner[idir] + a_origin[idir];
            }

          if (m_stlIF == NULL)
          {
            // If the implicit function value is positive then the current
            // corner is outside the domain
            Real functionValue = m_implicitFunction->value(physCorner);

            if (functionValue < 0.0 )
              {
                return false;
              }
          }
          else
          {
            if (!m_STLBoxSet)
            {
              m_stlIF->getExplorer()->Explore(a_domain.domainBox(),a_domain,a_origin,vectDx);
              m_STLBoxSet = true;
            }

            MayDay::Error("STL not implemented");
          }
        }
      bit.reset();
      ++bit;
    }

  return true;
}

GeometryService::InOut GeometryShop::InsideOutside(const Box&           a_region,
                                                   const ProblemDomain& a_domain,
                                                   const RealVect&      a_origin,
                                                   const Real&          a_dx) const
{
  CH_TIME("GeometryShop::InsideOutside");

  GeometryService::InOut rtn;

  if (m_implicitFunction->fastIntersection(a_region, a_domain, a_origin, a_dx))
    {
      rtn = m_implicitFunction->InsideOutside(a_region, a_domain, a_origin, a_dx);
    }
  else
    {
      RealVect vectDx;

      // All corner indices for the current box
      Box allCorners(a_region);
      allCorners.surroundingNodes();

      RealVect physCorner(allCorners.smallEnd());

      if (m_vectDx[0] != 0.0)
      {
        vectDx[0] = a_dx;
        for (int idir = 1; idir < SpaceDim; idir++)
        {
          vectDx[idir] = vectDx[0] * m_vectDx[idir] / m_vectDx[0];
        }
      }
      else
      {
        vectDx = a_dx * RealVect::Unit;
      }

      STLExplorer* stlExplorer = NULL;
      if (m_stlIF != NULL)
      {
        if (!m_STLBoxSet)
        {
          m_stlIF->getExplorer()->Explore(a_domain.domainBox(),a_domain,a_origin,vectDx);
          m_STLBoxSet = true;
        }

        stlExplorer = m_stlIF->getExplorer();
      }

      physCorner *= vectDx;
      physCorner += a_origin;

      Real firstValue;
      Real firstSign;

      if (m_stlIF == NULL)
      {
        firstValue = m_implicitFunction->value(physCorner);
      }
      else
      {
        bool in;
        stlExplorer->GetPointInOut(allCorners.smallEnd(),in);

        if (in)
        {
          firstValue = -1.0;
        }
        else
        {
          firstValue =  1.0;
        }
      }
      
      firstSign  = copysign(1.0, firstValue);

      if ( firstSign < 0 )
        {
          rtn = GeometryService::Regular;
        }
      else
        {
          rtn = GeometryService::Covered;
        }

      BoxIterator bit(allCorners);

      for (; bit.ok(); ++bit)
        {
          // Current corner
          IntVect corner = bit();

          Real functionValue;
          Real functionSign;

          if (m_stlIF == NULL)
          {
            // Compute physical coordinate of corner
            for (int idir = 0; idir < CH_SPACEDIM; ++idir)
              {
                physCorner[idir] = vectDx[idir]*corner[idir] + a_origin[idir];
              }

            // If the implicit function value is positive then the current
            // corner is outside the domain
            functionValue = m_implicitFunction->value(physCorner);
          }
          else
          {
            bool in;
            stlExplorer->GetPointInOut(corner,in);

            if (in)
            {
              functionValue = -1.0;
            }
            else
            {
              functionValue =  1.0;
            }
          }

          functionSign = copysign(1.0, functionValue);

          if (functionValue == 0 || firstValue == 0)
            {
              if (functionSign * firstSign < 0)
                {
                  rtn = GeometryService::Irregular;
                  return rtn;
                }
            }
          if (functionValue * firstValue < 0.0 )
            {
              rtn = GeometryService::Irregular;
              return rtn;
            }
        }
    }

  return rtn;
}

/**********************************************/
/*********************************************/
void
GeometryShop::fillGraph(BaseFab<int>        & a_regIrregCovered,
                        Vector<IrregNode>   & a_nodes,
                        const Box           & a_validRegion,
                        const Box           & a_ghostRegion,
                        const ProblemDomain & a_domain,
                        const RealVect      & a_origin,
                        const Real          & a_dx) const
{
  CH_TIMERS("GeometryShop::fillGraph");
  CH_TIMER("part1",p1);
  CH_TIMER("part2",p2);
  CH_TIMER("part3",p3);
  CH_TIMER("part4",p4);

  CH_START(p1);
  CH_assert(a_domain.contains(a_ghostRegion));
  RealVect vectDx;
  Real thrshd = m_thrshdVoF;
  // if (thrshd > 0)
  //   pout() << "GeometryShop:: Using thrshd: " << thrshd << endl;
  if (m_vectDx == RealVect::Zero)
    {
      vectDx = a_dx*RealVect::Unit;
    }
  else
    {
      vectDx = m_vectDx;
    }

  PolyGeom::setVectDx(vectDx);
  IntVectSet ivsirreg = IntVectSet(DenseIntVectSet(a_ghostRegion, false));
  IntVectSet ivsdrop  = IntVectSet(DenseIntVectSet(a_ghostRegion, false));// CP
  long int numCovered=0, numReg=0, numIrreg=0;
  CH_STOP(p1);

  CH_START(p2);
  for (BoxIterator bit(a_ghostRegion); bit.ok(); ++bit)
    {
      const IntVect iv =bit();
      Box miniBox(iv, iv);
      GeometryService::InOut inout = InsideOutside(miniBox, a_domain, a_origin, a_dx);

      if (inout == GeometryService::Covered)
        {
          // set covered cells to -1
          a_regIrregCovered(iv, 0) = -1;
          numCovered++;
        }
      else if (inout == GeometryService::Regular)
        {
          // set regular cells to 1
          a_regIrregCovered(iv, 0) =  1;
          numReg++;
        }
      else
        {
          // set irregular cells to 0
          a_regIrregCovered(iv, 0) =  0;
          if (a_validRegion.contains(iv))
            {
              ivsirreg |= iv;
              numIrreg++;
            }
        }
    }
  // pout()<< "GeometryShop:: Counting cells:  " << numCovered<< "  "<< numReg<< "  "<< numIrreg  <<endl;
  CH_STOP(p2);

  CH_START(p3);
  // now loop through irregular cells and make nodes for each  one.
  for (IVSIterator ivsit(ivsirreg); ivsit.ok(); ++ivsit)
    {
      VolIndex vof(ivsit(), 0);
      Real     volFrac, bndryArea;
      RealVect normal, volCentroid, bndryCentroid;
      Vector<int> loArc[SpaceDim];
      Vector<int> hiArc[SpaceDim];
      Vector<Real> loAreaFrac[SpaceDim];
      Vector<Real> hiAreaFrac[SpaceDim];
      Vector<RealVect> loFaceCentroid[SpaceDim];
      Vector<RealVect> hiFaceCentroid[SpaceDim];
      computeVoFInternals(volFrac,
                          loArc,
                          hiArc,
                          loAreaFrac,
                          hiAreaFrac,
                          bndryArea,
                          normal,
                          volCentroid,
                          bndryCentroid,
                          loFaceCentroid,
                          hiFaceCentroid,
                          ivsirreg,
                          vof,
                          a_domain,
                          a_origin,
                          a_dx,
                          vectDx,
                          ivsit());


          IrregNode newNode;
          newNode.m_cell          = ivsit();
          newNode.m_volFrac       = volFrac;
          newNode.m_cellIndex     = 0;
          newNode.m_volCentroid   = volCentroid;
          newNode.m_bndryCentroid = bndryCentroid;
          // if (thrshd == 0.)//begin treb
          //   {
          //     //this piece of code successfully removes volFrac=1 cells where EB cuts the vertex
          //     //this piece of code cannot be used with CP's small volFrac removal below
          //     //this piece of code does not work for removal of volFrac << 1 because of regular next to covered
          //     bool isIrregNode;
          //     if ((volFrac < -thrshd || volFrac > thrshd) && (volFrac < 1.-thrshd || volFrac > 1.+thrshd))
          //       // if (volFrac < 1.)
          //       {
          //         isIrregNode = true;
          //       }
          //     else
          //       {
          //         isIrregNode = false;
          //       }
      
          //     for (int faceDir = 0; faceDir < SpaceDim; faceDir++)
          //       {
          //         int loNodeInd = newNode.index(faceDir, Side::Lo);
          //         int hiNodeInd = newNode.index(faceDir, Side::Hi);
          //         newNode.m_arc[loNodeInd]          = loArc[faceDir];
          //         newNode.m_arc[hiNodeInd]          = hiArc[faceDir];
          //         newNode.m_areaFrac[loNodeInd]     = loAreaFrac[faceDir];
          //         newNode.m_areaFrac[hiNodeInd]     = hiAreaFrac[faceDir];
          //         newNode.m_faceCentroid[loNodeInd] = loFaceCentroid[faceDir];
          //         newNode.m_faceCentroid[hiNodeInd] = hiFaceCentroid[faceDir];
          //         if (!isIrregNode)//only go through this logic if a covered or regular cell has chance of being irregular????
          //           {
          //             //covered cell with no arcs in all directions
          //             if ((volFrac == 0.) && (loArc[faceDir].size() == 0) && (hiArc[faceDir].size() == 0))
          //               {
          //                 isIrregNode = false;
          //               }
          //             //regular cell with exactly one arc one lo and hi sides in all directions
          //             else if ((volFrac > 1.-thrshd && volFrac < 1.+thrshd) && (loArc[faceDir].size() == 1) && (hiArc[faceDir].size() == 1))
          //               // else if (volFrac == 1. && (loArc[faceDir].size() == 1) && (hiArc[faceDir].size() == 1))
          //               {
          //                 for (int numFace = 0; numFace < loAreaFrac[faceDir].size(); numFace++)
          //                   {
          //                     if (loAreaFrac[faceDir][numFace] > 1.-thrshd && loAreaFrac[faceDir][numFace] < 1.+thrshd)
          //                       {
          //                         isIrregNode = false;
          //                       }
          //                     else
          //                       {
          //                         isIrregNode = true;
          //                       }
          //                   }
          //                 for (int numFace = 0; numFace < hiAreaFrac[faceDir].size(); numFace++)
          //                   {
          //                     if (hiAreaFrac[faceDir][numFace] > 1.-thrshd && hiAreaFrac[faceDir][numFace] < 1.+thrshd)
          //                       {
          //                         isIrregNode = false;
          //                       }
          //                     else
          //                       {
          //                         isIrregNode = true;
          //                       }
          //                   }
          //               }
          //             //if none of those fit for all directions, then irregular, and don't come back through this logic
          //             else
          //               {
          //                 isIrregNode = true;
          //               }
          //           }
          //       }

          //     if (isIrregNode)
          //       {
          //         a_nodes.push_back(newNode);
          //       }
          //     else
          //       {
          //         if ((volFrac > 1.-thrshd && volFrac < 1.+thrshd))
          //           // if (volFrac == 1.)
          //           {
          //             a_regIrregCovered(ivsit(), 0) =  1;
          //             pout() << "Removing regular vof " << vof << " from irreg node list" << endl;
          //           }
          //       }
          //   }//end treb
          // else//begin CP
          //   {
              if (thrshd > 0. && volFrac < thrshd)
                {
                  ivsdrop |= ivsit();
                  a_regIrregCovered(ivsit(), 0) = -1;
                  if (m_verbosity > 2)
                    {
                      pout() << "Removing vof " << vof << " with volFrac " << volFrac << endl;
                    }
                }//CP record these nodes to be removed
              else
                {
                  IrregNode newNode;
                  newNode.m_cell          = ivsit();
                  newNode.m_volFrac       = volFrac;
                  newNode.m_cellIndex     = 0;
                  newNode.m_volCentroid   = volCentroid;
                  newNode.m_bndryCentroid = bndryCentroid;
                  
                  for (int faceDir = 0; faceDir < SpaceDim; faceDir++)
                    {
                      int loNodeInd = newNode.index(faceDir, Side::Lo);
                      int hiNodeInd = newNode.index(faceDir, Side::Hi);
                      newNode.m_arc[loNodeInd]          = loArc[faceDir];
                      newNode.m_arc[hiNodeInd]          = hiArc[faceDir];
                      newNode.m_areaFrac[loNodeInd]     = loAreaFrac[faceDir];
                      newNode.m_areaFrac[hiNodeInd]     = hiAreaFrac[faceDir];
                      newNode.m_faceCentroid[loNodeInd] = loFaceCentroid[faceDir];
                      newNode.m_faceCentroid[hiNodeInd] = hiFaceCentroid[faceDir];
                    }
                  a_nodes.push_back(newNode);
                }
            // }//end CP
    } // end loop over cells in the box
  CH_STOP(p3);

  CH_START(p4);
  // CP: fix sweep that removes cells with volFrac less than a certain threshold
  for (IVSIterator ivsit(ivsdrop); ivsit.ok(); ++ivsit)
    {
      VolIndex vof(ivsit(), 0);
      IntVect iv = vof.gridIndex();

      // multiple nodes in a gridcell location?
      // where is this guy in a_nodes?--search in m_cell?
      // how to access this guy's neighbor?

      // newNode.m_cell          = ivsit();
      // newNode.m_volFrac       = volFrac;
      // newNode.m_cellIndex     = 0;
      // newNode.m_volCentroid   = volCentroid;
      // newNode.m_bndryCentroid = bndryCentroid;
      for (int faceDir = 0; faceDir < SpaceDim; faceDir++)
        {
          for (SideIterator sit; sit.ok(); ++sit)
            {
              int isign = sign(sit());
              IntVect otherIV = iv + isign*BASISV(faceDir);
              if (a_validRegion.contains(otherIV))
                {
                  if (a_regIrregCovered(otherIV,0) == 0)
                    {
                      // i am in the case where the other cell
                      // is also irregular.   I just made a previously
                      // irregular cell covered so I have to check to
                      // see if it had any faces pointed this way.
                      int inode = -1;
                      bool found = false;
                      for (int ivec = 0; ivec < a_nodes.size() && ! found; ivec++)
                        {
                          if (a_nodes[ivec].m_cell == otherIV)
                            {
                              inode = ivec;
                              found = true;
                            }
                        }
                      if (!found && a_validRegion.contains(otherIV))
                        {
                          MayDay::Error("something wrong in our logic");
                        }
                      if (found)
                        {
                          int arcindex = a_nodes[inode].index(faceDir, flip(sit()));
                          a_nodes[inode].m_arc[         arcindex].resize(0);
                          a_nodes[inode].m_areaFrac[    arcindex].resize(0);
                          a_nodes[inode].m_faceCentroid[arcindex].resize(0);
                        }
                    }
                  else if (a_regIrregCovered(otherIV,0) == 1)
                    // CP This is a very peculiar case which has so far
                    // not happened. A irregular cell with tiny cell volFrac
                    // is connected to a regular cell
                    // may not work well. Need to be debugged before it is used

                    {
                      // MayDay::Error("need to be debugged before this branch is used!!!");
                      VolIndex vof(otherIV, 0);
                      Real     volFrac, bndryArea;
                      RealVect normal, volCentroid, bndryCentroid;
                      Vector<int> loArc[SpaceDim];
                      Vector<int> hiArc[SpaceDim];
                      Vector<Real> loAreaFrac[SpaceDim];
                      Vector<Real> hiAreaFrac[SpaceDim];
                      Vector<RealVect> loFaceCentroid[SpaceDim];
                      Vector<RealVect> hiFaceCentroid[SpaceDim];
                      computeVoFInternals(volFrac,
                                          loArc,
                                          hiArc,
                                          loAreaFrac,
                                          hiAreaFrac,
                                          bndryArea,
                                          normal,
                                          volCentroid,
                                          bndryCentroid,
                                          loFaceCentroid,
                                          hiFaceCentroid,
                                          ivsirreg, // CP this one????
                                          vof,
                                          a_domain,
                                          a_origin,
                                          a_dx,
                                          vectDx,
                                          otherIV); // CP
                      IrregNode newNode;
                      // case where neighbor is regular.  need to make
                      // a new node with IrregNode newNode;

                      newNode.m_cell          = otherIV;
                      newNode.m_volFrac       = volFrac;
                      newNode.m_cellIndex     = 0;
                      newNode.m_volCentroid   = volCentroid;
                      newNode.m_bndryCentroid = bndryCentroid;

                      for (int faceDir = 0; faceDir < SpaceDim; faceDir++)
                        {
                          int loNodeInd = newNode.index(faceDir, Side::Lo);
                          int hiNodeInd = newNode.index(faceDir, Side::Hi);
                          newNode.m_arc[loNodeInd]          = loArc[faceDir];
                          newNode.m_arc[hiNodeInd]          = hiArc[faceDir];
                          newNode.m_areaFrac[loNodeInd]     = loAreaFrac[faceDir];
                          newNode.m_areaFrac[hiNodeInd]     = hiAreaFrac[faceDir];
                          newNode.m_faceCentroid[loNodeInd] = loFaceCentroid[faceDir];
                          newNode.m_faceCentroid[hiNodeInd] = hiFaceCentroid[faceDir];
                        }

                      a_nodes.push_back(newNode);
                      a_regIrregCovered(otherIV,0) = 0;

                    }//else if
                }//valid region
            }//sit
        }//facedir
    }//ivsdrop
  CH_STOP(p4);
}

/**********************************************/
/*********************************************/
void
GeometryShop::computeVoFInternals(Real&               a_volFrac,
                                  Vector<int>         a_loArc[SpaceDim],
                                  Vector<int>         a_hiArc[SpaceDim],
                                  Vector<Real>        a_loAreaFrac[SpaceDim],
                                  Vector<Real>        a_hiAreaFrac[SpaceDim],
                                  Real&               a_bndryArea,
                                  RealVect&           a_normal,
                                  RealVect&           a_volCentroid,
                                  RealVect&           a_bndryCentroid,
                                  Vector<RealVect>    a_loFaceCentroid[SpaceDim],
                                  Vector<RealVect>    a_hiFaceCentroid[SpaceDim],
                                  const IntVectSet&   a_ivsIrreg,
                                  const VolIndex&     a_vof,
                                  const ProblemDomain&a_domain,
                                  const RealVect&     a_origin,
                                  const Real&         a_dx,
                                  const RealVect&     a_vectDx,
                                  const IntVect&      a_iv)const
{
  CH_TIME("GeometryShop::computeVoFInternals");

  // need maxDx to properly scale a_bndryArea
  Real maxDx = 0.0;

  for (int idir = 0; idir <SpaceDim; ++idir)
    {
      CH_assert(a_vectDx[idir] > 0);
      if (a_vectDx[idir] >maxDx)
        {
          maxDx = a_vectDx[idir];
        }
    }

  if (SpaceDim == 2)
    {
      // In 2D a vof is a faceMo = edgeMo[4],boundary length and normal vector
      faceMo Face;
      edgeMo edges[4];

      bool faceCovered;
      bool faceRegular;
      bool faceDontKnow;
      int faceNormal = 2;

      // get edgeType and intersection points
      edgeData2D(edges,
                 faceCovered,
                 faceRegular,
                 faceDontKnow,
                 a_dx,
                 a_vectDx,
                 a_iv,
                 a_domain,
                 a_origin);

      CH_assert(faceRegular || faceCovered || faceDontKnow);
      CH_assert((!(faceRegular && faceCovered)) && (!(faceRegular && faceDontKnow)) && (!(faceDontKnow && faceCovered)));
      // define the faceMo
      Face.define(edges,faceNormal,faceCovered,faceRegular,faceDontKnow);

      Moments geom;

      // answer0,answer1 are vectors whose components contain geometric information
      Vector<Real> answer0;
      Vector<Real> answer1;

      int order = 0;
      answer0 = geom.momentCalc2D(order,Face);

      // extract the info from answer0 and answer1

      // volfrac
      a_volFrac = answer0[0];

      order = 1;
      answer1 = geom.momentCalc2D(order,Face);

      // centroid
      for (int idir=0; idir<SpaceDim;++idir)
        {
          a_volCentroid[idir] = answer1[SpaceDim-1-idir];
        }

      if (a_volFrac <= 0.0)
        {
          a_volCentroid = RealVect::Zero;
        }
      else
        {
          a_volCentroid /= a_volFrac;
        }

      // normal
      Real normalVec[SpaceDim];
      Face.getNormal(normalVec);
      for (int idir = 0;idir < SpaceDim;++idir)
        {
          a_normal[idir] = normalVec[idir];
        }

      for (int idir = 0;idir < SpaceDim;++idir)
        {
          // (nx,ny)->(nxdy,nydx)
          a_normal[idir] = normalVec[idir]*a_vectDx[1 - idir];
        }
      Real anisBd = 0.0;
      for (int idir = 0;idir < SpaceDim;++idir)
        {
          anisBd += a_normal[idir]*a_normal[idir];
        }
      anisBd = sqrt(anisBd);
      if (anisBd !=0.0)
        {
          a_normal /= anisBd;
        }

      // compute bndryArea and bndryCentroid
      a_bndryArea = Face.getBdLength();
      if (a_bndryArea <= 0.0)
        {
          a_bndryCentroid = RealVect::Zero;
          a_bndryArea = 0.0;
        }
      else
        {
          for (int idir = 0;idir < SpaceDim; ++idir)
            {
              a_bndryCentroid[idir] = answer0[SpaceDim-idir]/a_bndryArea;
            }
          a_bndryArea *= anisBd;
          a_bndryArea /= maxDx;
        }

      for (int edgeNormal = 0; edgeNormal < SpaceDim; ++edgeNormal)
        {
          // loside
          bool coveredLo = edges[edgeNormal*2].isCovered();
          if (coveredLo)
            {
              a_loArc[edgeNormal].resize(0);
              a_loFaceCentroid[edgeNormal].resize(0);
              a_loAreaFrac[edgeNormal].resize(0);
            }
          else if (!coveredLo)
            {
              a_loArc[edgeNormal].resize(1);
              a_loFaceCentroid[edgeNormal].resize(1);
              a_loAreaFrac[edgeNormal].resize(1);
              IntVect otherIV = a_iv;
              otherIV[edgeNormal] -= 1;
              if (a_domain.contains(otherIV))
                {
                  int otherCellIndex;
                  if (a_ivsIrreg.contains(otherIV))
                    {
                      otherCellIndex = 0;
                    }
                  else
                    {
                      // arc to regular cell
                      otherCellIndex = -2;
                    }
                  a_loArc[edgeNormal][0]=otherCellIndex;
                }
              else if (!a_domain.contains(otherIV))
                {
                  // boundary arcs always -1
                  a_loArc[edgeNormal][0] = -1;
                }
              a_loFaceCentroid[edgeNormal][0] = edges[edgeNormal*2].getEdgeCentroid();
              a_loAreaFrac[edgeNormal][0] = edges[edgeNormal*2].getEdgeLength();
            }

          // hiside
          bool coveredHi = edges[edgeNormal*2+1].isCovered();
          if (coveredHi)
            {
              a_hiArc[edgeNormal].resize(0);
              a_hiFaceCentroid[edgeNormal].resize(0);
              a_hiAreaFrac[edgeNormal].resize(0);
            }
          else if (!coveredHi)
            {
              a_hiArc[edgeNormal].resize(1);
              a_hiFaceCentroid[edgeNormal].resize(1);
              a_hiAreaFrac[edgeNormal].resize(1);
              IntVect otherIV = a_iv;
              otherIV[edgeNormal] += 1;
              if (a_domain.contains(otherIV))
                {
                  int otherCellIndex;
                  if (a_ivsIrreg.contains(otherIV))
                    {
                      otherCellIndex = 0;
                    }
                  else
                    {
                      // arc to regular cell
                      otherCellIndex = -2;
                    }
                  a_hiArc[edgeNormal][0] = otherCellIndex;
                }
              else if (!a_domain.contains(otherIV))
                {
                  // boundary arcs always -1
                  a_hiArc[edgeNormal][0] = -1;
                }
              a_hiFaceCentroid[edgeNormal][0] = edges[edgeNormal*2+1].getEdgeCentroid();
              a_hiAreaFrac[edgeNormal][0] = edges[edgeNormal*2+1].getEdgeLength();

            }

        }
    }

  if (SpaceDim==3)
    {
      // 1) using the intvect, build up the classes in Moments: edgeMO,
      //    faceMo and finally vofMo
      // 2) check for covered or regular faces
      // 3) call  momentCalc3D
      // 4) keep track of what the output means and fill the variables
      //    requested

      faceMo Faces[6];
      int index = -1;

      for (int faceNormal = 0;faceNormal < SpaceDim;++faceNormal)
        {
          for (int hiLoFace = 0;hiLoFace < 2;++hiLoFace)
            {
              index += 1;
              edgeMo edges[4];
              bool faceCovered;
              bool faceRegular;
              bool faceDontKnow;
              edgeData3D(edges,
                         faceCovered,
                         faceRegular,
                         faceDontKnow,
                         hiLoFace,
                         faceNormal,
                         a_dx,
                         a_vectDx,
                         a_iv,
                         a_domain,
                         a_origin);

              CH_assert(faceRegular || faceCovered || faceDontKnow);
              CH_assert((!(faceRegular && faceCovered)) && (!(faceRegular && faceDontKnow)) && (!(faceDontKnow && faceCovered)));
              Faces[index].define(edges,faceNormal,faceCovered,faceRegular,faceDontKnow);

              // if the face is covered we will deal with it later
              if (!Faces[index].isCovered())
                {
                  Moments geom;
                  // answer0 and answer1 have all the geometric facts
                  Vector<Real> answer0;
                  Vector<Real> answer1;

                  int order = 0;
                  answer0 = geom.momentCalc2D(order,Faces[index]);

                  // area of this face
                  Real area=answer0[0];

                  order = 1;
                  answer1 = geom.momentCalc2D(order,Faces[index]);

                  // first we get the centroid of the face
                  RealVect faceCentroid;
                  for (int idir = 0; idir<SpaceDim;++idir)
                    {
                      faceCentroid[idir] = answer1[SpaceDim-1-idir];
                    }

                  if (area > 0.0)
                    {
                      faceCentroid /= area;
                    }
                  else
                    {
                      faceCentroid = RealVect::Zero;
                    }

                  // record these facts in member data
                  Faces[index].setFaceCentroid(faceCentroid);
                  Faces[index].setFaceArea(area);
                }

              else if (Faces[index].isCovered())
                {
                  RealVect faceCentroid = RealVect::Zero;
                  Faces[index].setFaceCentroid(faceCentroid);
                  Real area = 0.0;
                  Faces[index].setFaceArea(area);
                }
            }
        }
#if 1
      // iterate over faces recalculating face area
      // face order is xLo,xHi,yLo,yHi,zLo,zHi
      for (int iFace = 0; iFace < 2*SpaceDim; ++iFace)
        {
          // recalculate face area
          faceMo& face = Faces[iFace];

          // collect exactly two irregular edges or mayday.
          Vector<RealVect> crossingPt;

          Vector<int> cPtHiLo;
          Vector<int> edgeHiLo;
          Vector<int> edgeDir;

          if (!(face.isCovered()) && !(face.isRegular()))
            {
              for ( int iEdge = 0; iEdge < 4; ++iEdge)
                {
                  const edgeMo& curEdge = face.retrieveEdge(iEdge);

                  if (curEdge.dontKnow())
                    {
                      // loPt of edge
                      RealVect loPt = curEdge.getLo();

                      // hiPt of edge
                      RealVect hiPt = curEdge.getHi();

                      // direction that varies over edge
                      int direction = curEdge.direction();
                      bool intersectLo = curEdge.getIntersectLo();

                      // for irregular or regular edges at most one pt away from corner
                      if (intersectLo)
                        {
                          crossingPt.push_back(loPt);
                          cPtHiLo.push_back(-1);

                          int hilo = iEdge % 2;
                          edgeHiLo.push_back(hilo);

                          edgeDir.push_back(direction);
                        }
                      else // forced by dontknow
                        {
                          crossingPt.push_back(hiPt);
                          cPtHiLo.push_back(1);

                          int hilo = iEdge % 2;
                          edgeHiLo.push_back(hilo);

                          edgeDir.push_back(direction);
                        }
                    }
                }
            }

          if (crossingPt.size() == 2)
            {
              // get midpoint of line connecting intersection points
              RealVect midPt = crossingPt[0];
              midPt += crossingPt[1];
              midPt *= 0.5;

              // faceNormal
              int faceNormal = Faces[iFace].getFaceNormal();

              // directions over which the face varies
              int dir1 = (faceNormal + 1) % SpaceDim;
              int dir2 = (faceNormal + 2) % SpaceDim;

              // find max of (deltaDir1,deltaDir2)
              Real deltaDir1 = Abs(crossingPt[0][dir1] - crossingPt[1][dir1]);
              Real deltaDir2 = Abs(crossingPt[0][dir2] - crossingPt[1][dir2]);

              // maxDir will be the direction of integration (independent variable)
              // minDir will the direction in which the integrand varies(dependent variable)
              int maxDir;
              int minDir;
              if (deltaDir1 > deltaDir2)
                {
                  maxDir = dir1;
                  minDir = dir2;
                }
              else
                {
                  maxDir = dir2;
                  minDir = dir1;
                }
              // flip area?
              bool complementArea;

              CH_assert (cPtHiLo.size() == 2);

              // loEdge-loEdge
              if (edgeHiLo[0] == 0 && edgeHiLo[1] == 0)
                {
                  // both crossingPts must be Hi or both must be Lo
                  CH_assert((cPtHiLo[0] == 1 && cPtHiLo[1] == 1) ||
                         (cPtHiLo[0] == -1 && cPtHiLo[1] == -1));

                  // prismArea gives triangle

                  // if the cPtHiLo[0]= hiPt then one wants triangle
                  if (cPtHiLo[0] == 1)
                    {
                      complementArea = false;
                    }
                  else
                    {
                      complementArea = true;
                    }
                }

              // hiEdge-hiEdge
              else if (edgeHiLo[0] == 1 && edgeHiLo[1] == 1)
                {
                  // both crossingPts must be Hi or both must be Lo
                  CH_assert((cPtHiLo[0] == 1 && cPtHiLo[1] == 1) ||
                         (cPtHiLo[0] == -1 && cPtHiLo[1] == -1));
                  // prismArea gives the trapezoid

                  // cPtHiLo[0] == Lo => one wants the triangle area
                  if (cPtHiLo[0] == -1)
                    {
                      complementArea = true;
                    }
                  else
                    {
                      complementArea = false;
                    }
                }

              // hiEdge-loEdge
              else if (edgeHiLo[0] == 1 && edgeHiLo[1] == 0)
                {
                  // cpPtHiLo must be the same or the opposite of edgeHiLo
                  CH_assert((cPtHiLo[0] == 1 && cPtHiLo[1] == -1) ||
                         (cPtHiLo[0] == -1 && cPtHiLo[1] == 1));
                  // maxDir > minDir =>prismArea gives trapezoid
                  // maxDir < minDir =>prismArea gives triangle

                  // (cPtHiLo[1] == 1) => one wants trapezoid
                  if (cPtHiLo[1] == 1)
                    {
                      if (maxDir < minDir)
                        {
                          complementArea = true;
                        }
                      else
                        {
                          complementArea = false;
                        }
                    }
                  else
                    // (cPtHiLo[1] == -1) => one wants triangle
                    {
                      if (maxDir < minDir)
                        {
                          complementArea = false;
                        }
                      else
                        {
                          complementArea = true;
                        }
                    }
                }

              // loEdge-hiEdge
              else if (edgeHiLo[0] == 0 && edgeHiLo[1] == 1)
                {
                  // triangle + triangle complement or two trapezoids comprise this case

                  // two trapezoids
                  if (cPtHiLo[1] == 1 && cPtHiLo[0] == 1)
                    {
                      CH_assert(edgeDir[0] == edgeDir[1]);
                      complementArea = false;
                    }
                  else if (cPtHiLo[1] == -1 && cPtHiLo[0] == -1)
                    {
                      CH_assert(edgeDir[0] == edgeDir[1]);
                      complementArea = true;
                    }
                  // triangle + triangle complement
                  // if the cPtHiLo[0]= loPt then one wants triangle
                  else if (cPtHiLo[0] == -1 && cPtHiLo[1] == 1 )
                    {
                      CH_assert(edgeDir[0] != edgeDir[1]);
                      // if maxDir < minDir prismArea gives trapezoid
                      // if maxDir > minDir prismArea gives triangle
                      if (maxDir < minDir)
                        {
                          complementArea = true;
                        }
                      else
                        {
                          complementArea = false;
                        }
                    }

                  // cPtHiLo[0]= hiPt => one wants trapezoid
                  else if (cPtHiLo[0] == 1 && cPtHiLo[1] == -1)
                    {
                      if (maxDir < minDir)
                        {
                          complementArea = false;
                        }
                      else
                        {
                          complementArea = true;
                        }
                    }
                }

              else
                {
                  MayDay::Abort("cPtDir or mindir or maxDir not set correctly");
                }

              // segLo is the lo end of segment within face[iEdge] for Brent Rootfinder
              RealVect segLo = midPt;
              segLo[minDir] = -0.5;

              // segHi is the hi end of segment within face[iEdge] for Brent Rootfinder
              RealVect segHi = midPt;
              segHi[minDir] = 0.5;

              // put segLo and segHi in physical coordinates
              RealVect physSegLo;
              RealVect physSegHi;
              RealVect physMidPt;
              for (int idir = 0; idir < SpaceDim; ++idir)
                {
                  physSegLo[idir] = a_vectDx[idir]*(segLo[idir] + a_iv[idir] + 0.5) + a_origin[idir];
                  physSegHi[idir] = a_vectDx[idir]*(segHi[idir] + a_iv[idir] + 0.5) + a_origin[idir];
                  physMidPt[idir] = a_vectDx[idir]*(midPt[idir] + a_iv[idir] + 0.5) + a_origin[idir];
                }

              // find upDir
              pair<int,Side::LoHiSide> upDir;

              // physIntercept is along the segment[physSegLo,physSegHi]
              // this segment passes through midPt with direction minDir
              Real physIntercept;
              bool dropOrder = false;


              if (m_stlIF == NULL)
              {
                Real fLo = m_implicitFunction->value(physSegLo);
                Real fHi = m_implicitFunction->value(physSegHi);

                // This guards against the "root must be bracketed" error
                // by dropping order
                if (fLo*fHi > 0.0)
                  {
                    dropOrder = true;
                  }
                else
                  {
                    physIntercept = BrentRootFinder(physSegLo, physSegHi, minDir);
                  }
              }
              else
              {
                dropOrder = true;
              }

              if (!dropOrder)
                {
                  // put physIntercept into relative coordinates
                  Real intercept = physIntercept - a_origin[minDir];
                  intercept  /= a_vectDx[minDir];
                  intercept -= (a_iv[minDir]+0.5);

                  // push_back third pt onto crossingPt
                  crossingPt.push_back(midPt);
                  crossingPt[2][minDir] = intercept;

                  // integrate w.r.t xVec using Prismoidal Rule
                  RealVect xVec;
                  RealVect yVec;

                  // the order of (xVec,yVec) will be sorted out in PrismoidalAreaCalc
                  xVec[0] = crossingPt[0][maxDir];
                  xVec[1] = crossingPt[2][maxDir];
                  xVec[2] = crossingPt[1][maxDir];

                  yVec[0] = crossingPt[0][minDir];
                  yVec[1] = crossingPt[2][minDir];
                  yVec[2] = crossingPt[1][minDir];

                  // Prismoidal's rule
                  Real area = PrismoidalAreaCalc(xVec,yVec);

                  // Only use area if it is valid
                  if (area >= 0.0 && area <= 1.0)
                  {
                    // assign area to this value or (1 - this value)
                    if (complementArea)
                      {
                        area = 1.0 - area;
                      }

                    Faces[iFace].setFaceArea(area);
                  }
                }
            }
        }
#endif
      // fill in some arguments of computeVofInternals for the faces
      for (int faceNormal = 0;faceNormal < SpaceDim;++faceNormal)
        {
          bool coveredLo = Faces[faceNormal*2].isCovered();
          if (coveredLo)
            {
              a_loArc[faceNormal].resize(0);
              a_loFaceCentroid[faceNormal].resize(0);
              a_loAreaFrac[faceNormal].resize(0);
            }
          else if (!coveredLo)
            {
              a_loArc[faceNormal].resize(1);
              a_loFaceCentroid[faceNormal].resize(1);
              a_loAreaFrac[faceNormal].resize(1);
              IntVect otherIV = a_iv;
              otherIV[faceNormal] -= 1;

              if (a_domain.contains(otherIV))
                {
                  int otherCellIndex;
                  if (a_ivsIrreg.contains(otherIV))
                    {
                      otherCellIndex = 0;
                    }
                  else
                    {
                      // arc to regular cell
                      otherCellIndex = -2;
                    }
                  a_loArc[faceNormal][0] = otherCellIndex;
                }
              else if (!a_domain.contains(otherIV))
                {
                  // boundary arcs always -1
                  a_loArc[faceNormal][0] = -1;
                }

              a_loFaceCentroid[faceNormal][0] = Faces[faceNormal*2].getFaceCentroid();

              a_loAreaFrac[faceNormal][0] = Faces[faceNormal*2].getFaceArea();

            }
          else
            {
              MayDay::Abort("is it coveredLo?");
            }
          bool coveredHi = Faces[faceNormal*2+1].isCovered();
          if (coveredHi)
            {
              a_hiArc[faceNormal].resize(0);
              a_hiFaceCentroid[faceNormal].resize(0);
              a_hiAreaFrac[faceNormal].resize(0);
            }
          else if (!coveredHi)
            {
              a_hiArc[faceNormal].resize(1);
              a_hiFaceCentroid[faceNormal].resize(1);
              a_hiAreaFrac[faceNormal].resize(1);
              IntVect otherIV = a_iv;
              otherIV[faceNormal] += 1;
              if (a_domain.contains(otherIV))
                {
                  int otherCellIndex;
                  if (a_ivsIrreg.contains(otherIV))
                    {
                      otherCellIndex = 0;
                    }
                  else
                    {
                      // arc to regular cell
                      otherCellIndex = -2;
                    }
                  a_hiArc[faceNormal][0] = otherCellIndex;
                }
              else if (!a_domain.contains(otherIV))
                {
                  // boundaryArcs always -1
                  a_hiArc[faceNormal][0] = -1;
                }
              a_hiFaceCentroid[faceNormal][0] = Faces[faceNormal*2+1].getFaceCentroid();
              a_hiAreaFrac[faceNormal][0] = Faces[faceNormal*2+1].getFaceArea();
            }
          else
            {
              MayDay::Abort("is it coveredHi?");
            }
        }

      // We have enough face data to construct the vof
      vofMo Vof;
      Vof.define(Faces);

      Moments geom;
      int order = 0;
      Vector<Real> answer0;
      answer0 = geom.momentCalc3D(order,Vof);

      a_volFrac = answer0[0];

      Vector<Real> answer1;
      order = 1;
      answer1 = geom.momentCalc3D(order,Vof);

      for (int idir=0; idir<SpaceDim;++idir)
        {
          a_volCentroid[idir] = answer1[SpaceDim-1-idir];
        }

      if (a_volFrac == 0.0)
        {
          a_volCentroid = RealVect::Zero;
        }
      else
        {
          a_volCentroid /= a_volFrac;

        }

      Real normalVec[SpaceDim];
      Vof.getNormal(normalVec);
      for (int idir = 0;idir < SpaceDim;++idir)
        {
          a_normal[idir] = normalVec[idir];
        }

      for (int idir = 0;idir < SpaceDim;++idir)
        {
          // (nx,ny,nz)->(nxdydz,nydxdz,nzdxdy)
          a_normal[idir] = normalVec[idir]*a_vectDx[((idir-1)*(idir-2))/2]*a_vectDx[2 - ((idir-1)*idir)/2];
        }
      Real anisBd = 0.0;
      for (int idir = 0;idir < SpaceDim;++idir)
        {
          anisBd += a_normal[idir]*a_normal[idir];
        }
      anisBd = sqrt(anisBd);
      if (anisBd !=0.0)
        {
          a_normal /= anisBd;
        }

      a_bndryArea = Vof.getBdArea();
      if (a_bndryArea > 0.0)
        {
          for (int idir = 0;idir < SpaceDim;++idir)
            {
              a_bndryCentroid[idir] = answer0[SpaceDim-idir]/a_bndryArea;
            }
          a_bndryArea *= anisBd;
          a_bndryArea /= (maxDx*maxDx);
        }
      else
        {
          a_bndryCentroid = RealVect::Zero;
          a_bndryArea = 0.0;
        }
    }

  // clipping
  // only report adjustments when discrepancy is above the threshold
  bool thisVofClipped = false;
  Real discrepancy = 0.0;
  Real volDiscrepancy = 0.0;
  // volFrac out of bounds
  if (a_volFrac < 0.0)
    {
      volDiscrepancy = Abs(a_volFrac);
      char message[1024];
      if (SpaceDim ==2)
        {
          sprintf(message,"vol fraction (%e) out of bounds. Clipping: (%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1]);
        }
      else if (SpaceDim == 3)
        {
          sprintf(message,"vol frac (%e) out of bounds. Clipping: (%d,%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1],a_iv[2]);
        }
      else
        {
          sprintf(message,"SpaceDim not 2 or 3");
        }

      if (volDiscrepancy > m_threshold)
        {
          MayDay::Warning(message);
        }
      // do the clipping
      thisVofClipped = true;
      a_volFrac = 0.0;
    }

  if (a_volFrac > 1.0)
    {
      volDiscrepancy = Abs(1.0 - a_volFrac);
      char message[1024];
      if (SpaceDim ==2)
        {
          sprintf(message,"vol fraction (%e) out of bounds. Clipping: (%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1]);
        }
      else if (SpaceDim == 3)
        {
          sprintf(message,"vol frac (%e) out of bounds. Clipping: (%d,%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1],a_iv[2]);
        }
      else
        {
          sprintf(message,"SpaceDim not 2 or 3");
        }
      if (volDiscrepancy>m_threshold)
        {
          MayDay::Warning(message);
        }
      // do the clipping
      thisVofClipped = true;
      a_volFrac = 1.0;
    }

  // area frac out of bounds
  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_loAreaFrac[idir].size();num ++)
        {
          // lo frac too high
          if (a_loAreaFrac[idir][num] > 1.0)
            {
              discrepancy = Abs(1 - a_loAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
                {
                  MayDay::Warning(message);
                }

              // do the clipping
              thisVofClipped = true;
              a_loAreaFrac[idir][num] = 1.0;
            }
          // lo frac too low
          if (a_loAreaFrac[idir][num] < 0.0)
            {
              discrepancy = Abs(a_loAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
                {
                  MayDay::Warning(message);
                }

              // do the clipping
              thisVofClipped = true;
              a_loAreaFrac[idir][num] = 0.0;
            }

        }
    }

  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_hiAreaFrac[idir].size();num ++)
        {
          // hi frac too high
          if (a_hiAreaFrac[idir][num] > 1.0)
            {
              discrepancy = Abs(1 - a_hiAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
                {
                  MayDay::Warning(message);
                }

              // do the clipping
              thisVofClipped = true;
              a_hiAreaFrac[idir][num] = 1.0;
            }
          // hi frac too low
          if (a_hiAreaFrac[idir][num] < 0.0)
            {
              discrepancy = Abs(a_hiAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
                {
                  MayDay::Warning(message);
                }

              // do the clipping
              thisVofClipped = true;
              a_hiAreaFrac[idir][num] = 0.0;
            }

        }

    }

  // bndry area out of bounds
  if (a_bndryArea < 0.0)
    {
      discrepancy = Abs(a_bndryArea);
      char message[1024];
      if (SpaceDim ==2)
        {
          sprintf(message,"boundary area fraction (%e) out of bounds. Clipping: (%d,%d)",
                  a_bndryArea,a_iv[0],a_iv[1]);
        }
      else if (SpaceDim == 3)
        {
          sprintf(message,"boundary area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                  a_bndryArea,a_iv[0],a_iv[1],a_iv[2]);
        }
      else
        {
          sprintf(message,"SpaceDim not 2 or 3");
        }
      if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
        {
          MayDay::Warning(message);
        }

      // do the clipping
      thisVofClipped = true;
      a_bndryArea = 0.0;
    }

  if (a_bndryArea > sqrt(2.0))
    {
      discrepancy = Abs(sqrt(2.0) - a_bndryArea);
      char message[1024];
      if (SpaceDim ==2)
        {
          sprintf(message,"boundary area fraction (%e) out of bounds. Clipping: (%d,%d)",
                  a_bndryArea,a_iv[0],a_iv[1]);
        }
      else if (SpaceDim == 3)
        {
          sprintf(message,"boundary area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                  a_bndryArea,a_iv[0],a_iv[1],a_iv[2]);
        }
      else
        {
          sprintf(message,"SpaceDim not 2 or 3");
        }
      if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
        {
          MayDay::Warning(message);
        }
      // do the clipping
      thisVofClipped = true;
      a_bndryArea = sqrt(2.0);
    }

  // volCentroid out of bounds
  for (int idir =0;idir<SpaceDim;++idir)
    {
      if (a_volCentroid[idir] > 0.5)
        {
          discrepancy = Abs(0.5 - a_volCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"volCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"volCentroid(%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
            {
              MayDay::Warning(message);
            }
          // do the clipping
          thisVofClipped = true;
          a_volCentroid[idir] = 0.5;
        }
      if (a_volCentroid[idir] < -0.5)
        {
          discrepancy = Abs(-0.5 - a_volCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"volCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"volCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy > m_threshold&& volDiscrepancy>m_threshold)
            {
              MayDay::Warning(message);
            }
          // do the clipping
          thisVofClipped = true;
          a_volCentroid[idir] = -0.5;
        }

      // boundary centroid out of bounds
      if (a_bndryCentroid[idir] > 0.5)
        {
          discrepancy = Abs(0.5 - a_bndryCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"bndryCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"boundary Centroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy>m_threshold && volDiscrepancy>m_threshold)
            {
              MayDay::Warning(message);
            }
          // do the clipping
          thisVofClipped = true;
          a_bndryCentroid[idir] = 0.5;
        }

      if (a_bndryCentroid[idir] < -0.5)
        {
          discrepancy = Abs(-0.5 - a_bndryCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"bndryCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"bndryCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy > m_threshold && volDiscrepancy>m_threshold)
            {
              MayDay::Warning(message);
            }
          // do the clipping
          thisVofClipped = true;
          a_bndryCentroid[idir] = -0.5;
        }
    }
  // loFaceCentroid out of bounds
  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_loFaceCentroid[idir].size();num ++)
        {
          for (int jdir = 0; jdir<SpaceDim; ++jdir)
            {
              if (a_loFaceCentroid[idir][num][jdir] > 0.5)
                {
                  discrepancy = Abs(0.5 - a_loFaceCentroid[idir][num][jdir]);
                  char message[1024];
                  if (SpaceDim ==2)
                    {
                      sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                              a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                    }
                  else if (SpaceDim == 3)
                    {
                      sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                              a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                    }
                  else
                    {
                      sprintf(message,"SpaceDim not 2 or 3");
                    }
                  if (discrepancy > m_threshold && volDiscrepancy>m_threshold)
                    {
                      MayDay::Warning(message);
                    }
                  // do the clipping
                  thisVofClipped = true;
                  a_loFaceCentroid[idir][num][jdir] = 0.5;
                }
              if (a_loFaceCentroid[idir][num][jdir] < -0.5)
                {
                  discrepancy = Abs(-0.5 - a_loFaceCentroid[idir][num][jdir]);
                  char message[1024];
                  if (SpaceDim ==2)
                    {
                      sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                              a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                    }
                  else if (SpaceDim == 3)
                    {
                      sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                              a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                    }
                  else
                    {
                      sprintf(message,"SpaceDim not 2 or 3");
                    }
                  if (discrepancy > m_threshold && volDiscrepancy>m_threshold)
                    {
                      MayDay::Warning(message);
                    }
                  // do the clipping
                  thisVofClipped = true;
                  a_loFaceCentroid[idir][num][jdir] = -0.5;
                }
            }
        }
    }
  // hiFaceCentroid out of bounds
  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_hiFaceCentroid[idir].size();num ++)
        {
          for (int jdir = 0; jdir<SpaceDim; ++jdir)
            {
              if (a_hiFaceCentroid[idir][num][jdir] > 0.5)
                {
                  discrepancy = Abs(0.5 - a_hiFaceCentroid[idir][num][jdir]);
                  char message[1024];
                  if (SpaceDim ==2)
                    {
                      sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                              a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                    }
                  else if (SpaceDim == 3)
                    {
                      sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                              a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                    }
                  else
                    {
                      sprintf(message,"SpaceDim not 2 or 3");
                    }
                  if (discrepancy > m_threshold && volDiscrepancy>m_threshold)
                    {
                      MayDay::Warning(message);
                    }
                  // do the clipping
                  thisVofClipped = true;
                  a_hiFaceCentroid[idir][num][jdir] = 0.5;
                }
              if (a_hiFaceCentroid[idir][num][jdir] < -0.5)
                {
                  discrepancy = Abs(0.5 - a_hiFaceCentroid[idir][num][jdir]);
                  char message[1024];
                  if (SpaceDim ==2)
                    {
                      sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                              a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                    }
                  else if (SpaceDim == 3)
                    {
                      sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                              a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                    }
                  else
                    {
                      sprintf(message,"SpaceDim not 2 or 3");
                    }
                  if (discrepancy > m_threshold && volDiscrepancy > m_threshold)
                    {
                      MayDay::Warning(message);
                    }
                  // do the clipping
                  thisVofClipped = true;
                  a_hiFaceCentroid[idir][num][jdir] = -0.5;
                }
            }
        }
    }

  if (thisVofClipped)
    {
      GeometryShop* changedThis = (GeometryShop *) this;
      changedThis->m_numCellsClipped += 1;
    }
}

int GeometryShop::getNumCellsClipped()
{
  return m_numCellsClipped;
}

void GeometryShop::edgeData3D(edgeMo a_edges[4],
                              bool& a_faceCovered,
                              bool& a_faceRegular,
                              bool& a_faceDontKnow,
                              const int a_hiLoFace,
                              const int a_faceNormal,
                              const Real& a_dx,
                              const RealVect& a_vectDx,
                              const IntVect& a_iv,
                              const ProblemDomain& a_domain,
                              const RealVect& a_origin) const
{
  CH_TIME("GeometryShop::edgeData3D");
  a_faceRegular = true;
  a_faceCovered = true;
  a_faceDontKnow = false;

  int index = -1;

  // edge order is lexigraphic xLo,xHi,yLo,yHi
  for (int dom = 0; dom < 3; ++dom)
    {
      if (dom != a_faceNormal)
        {
          for (int lohi = 0; lohi < 2; ++lohi)
            {
              // which edge 0,1,2, or 3 in lexigraphic order is given by index
              index += 1;
              // range is the direction along which the edge varies
              int range = 3 - a_faceNormal - dom;

              RealVect LoPt;
              bool LoPtChanged = false;
              Real funcLo;

              RealVect HiPt;
              bool HiPtChanged = false;
              Real funcHi;

              // put LoPt in physical coordinates
              LoPt[a_faceNormal] = a_origin[a_faceNormal]+
                (a_iv[a_faceNormal]+a_hiLoFace)*a_vectDx[a_faceNormal];
              LoPt[dom] = a_origin[dom] + (a_iv[dom]+lohi)*a_vectDx[dom];
              LoPt[range] = a_origin[range] + (a_iv[range])*a_vectDx[range];

              // put HiPt in physical coordinates
              HiPt[a_faceNormal] = a_origin[a_faceNormal] +
                (a_iv[a_faceNormal]+a_hiLoFace)*a_vectDx[a_faceNormal];
              HiPt[dom] = a_origin[dom] + (a_iv[dom]+lohi)*a_vectDx[dom];
              HiPt[range] = a_origin[range] + (a_iv[range]+1)*a_vectDx[range];

              // find the midpoint
              RealVect MidPt = LoPt;
              MidPt += HiPt;
              MidPt /= 2.0;

              Real signHi;
              Real signLo;

              // placeholders for edgeType
              bool covered  = false;
              bool regular  = false;
              bool dontKnow = false;

              RealVect interceptPt = RealVect::Zero;

              if (m_stlIF == NULL)
              {
                funcHi = m_implicitFunction->value(HiPt);
                funcLo = m_implicitFunction->value(LoPt);
              }
              else
              {
                IntVect loIV(a_iv);
                loIV[a_faceNormal] += a_hiLoFace;
                loIV[dom]          += lohi;

                IntVect hiIV(a_iv);
                hiIV[a_faceNormal] += a_hiLoFace;
                hiIV[dom]          += lohi;
                hiIV[range]        += 1;

                CellEdge curEdge(loIV,hiIV);

                bool loIn,hiIn;
                m_stlIF->getExplorer()->GetCellEdgeIntersection(curEdge,interceptPt,loIn,hiIn);

                if (loIn)
                {
                  funcLo = -1.0;
                }
                else
                {
                  funcLo = 1.0;
                }

                if (hiIn)
                {
                  funcHi = -1.0;
                }
                else
                {
                  funcHi = 1.0;
                }
              }

              // For level set data negative -> in the fluid
              //                    positive -> out of the fluid
              signHi = -funcHi;
              signLo = -funcLo;

              edgeType(covered,regular,dontKnow,signHi,signLo);

              // now we know the boolean values so we can set the edge Hi  and Lo pts
              if (covered)
                {
                  a_faceRegular=false;

                  LoPt[range] = a_origin[range] + (a_iv[range]+0.5)*a_vectDx[range];
                  LoPtChanged = true;

                  HiPt[range] = a_origin[range] + (a_iv[range]+0.5)*a_vectDx[range];
                  HiPtChanged = true;
                }
              else if (regular)
                {
                  a_faceCovered = false;
                }
              else if (dontKnow)
                {
                  a_faceRegular = false;
                  a_faceCovered = false;
                  a_faceDontKnow = true;

                  Real intercept;
                  if (m_stlIF == NULL)
                  {
                    // find where the surface intersects the edge
                    intercept = BrentRootFinder(LoPt, HiPt, range);
                  }
                  else
                  {
                    intercept = interceptPt[range];
                  }

                  if (funcHi >= 0 && funcLo*funcHi <= 0)
                    {
                      HiPt[range] = intercept;
                      HiPtChanged = true;
                    }
                  else if (funcLo >= 0 && funcLo*funcHi <= 0)
                    {
                      LoPt[range] = intercept;
                      LoPtChanged = true;
                    }
                  else
                    {
                      MayDay::Abort("Bogus intersection calculated");
                    }
                }

              // put LoPt and HiPt in local coordinates
              if (a_hiLoFace == 0)
                {
                  LoPt[a_faceNormal] = -0.5;
                  HiPt[a_faceNormal] = -0.5;
                }
              else
                {
                  LoPt[a_faceNormal] =  0.5;
                  HiPt[a_faceNormal] =  0.5;
                }

              if (lohi == 0)
                {
                  LoPt[dom] = -0.5;
                  HiPt[dom] = -0.5;
                }
              else
                {
                  LoPt[dom] =  0.5;
                  HiPt[dom] =  0.5;
                }

              if (LoPtChanged)
                {
                  LoPt[range] -= a_origin[range];
                  LoPt[range] /= a_vectDx[range];
                  LoPt[range] -= (a_iv[range] + 0.5);
                }
              else
                {
                  LoPt[range] = -0.5;
                }

              if (HiPtChanged)
                {
                  HiPt[range] -= a_origin[range];
                  HiPt[range] /= a_vectDx[range];
                  HiPt[range] -= (a_iv[range] + 0.5);
                }
              else
                {
                  HiPt[range] =  0.5;
                }

              CH_assert((!(regular && covered)) && (!(regular && dontKnow)) && (!(dontKnow && covered)));
              CH_assert(regular || covered || (!(LoPtChanged && HiPtChanged)));
              CH_assert(regular || covered || dontKnow);
              CH_assert(regular || covered || LoPtChanged || HiPtChanged);
              bool intersectLo = LoPtChanged;
              edgeMo Edge;
              // range means the coordinate direction that varies over the length of the edge
              Edge.define(LoPt,HiPt,intersectLo, range,covered,regular,dontKnow);
              a_edges[index] = Edge;
            }
        }
    }
  return;
}
void GeometryShop::edgeData2D(edgeMo a_edges[4],
                              bool& a_faceCovered,
                              bool& a_faceRegular,
                              bool& a_faceDontKnow,
                              const Real& a_dx,
                              const RealVect& a_vectDx,
                              const IntVect& a_iv,
                              const ProblemDomain& a_domain,
                              const RealVect& a_origin) const
{
  CH_TIME("GeometryShop::edgeData2D");
  // index counts which edge:xLo=0,xHi=1,yLo=2,yHi=3
  int index = -1;

  a_faceRegular = true;
  a_faceCovered = true;
  a_faceDontKnow = false;

  // domain means the direction normal to the edge
  for (int domain = 0; domain < 2;++domain)
    {
      for (int lohi = 0; lohi < 2;++lohi)
        {
          index += 1;

          // range is the direction along the edge
          int range = 1-domain;

          // Express HiPt. LoPt and MidPt in physical coordinates
          RealVect LoPt;
          bool LoPtChanged = false;
          LoPt[domain] = a_origin[domain] + (a_iv[domain]+lohi)*a_vectDx[domain];
          LoPt[range]  = a_origin[range]  + (a_iv[range])*a_vectDx[range];

          RealVect HiPt;
          bool HiPtChanged = false;
          HiPt[domain] = a_origin[domain] + (a_iv[domain]+lohi)*a_vectDx[domain];
          HiPt[range] =  a_origin[range] + (a_iv[range]+1)*a_vectDx[range];

          RealVect MidPt = HiPt;
          MidPt += LoPt;
          MidPt /= 2.0;

          // decide which type of edge
          bool covered;
          bool regular;
          bool dontKnow;

          // function value
          Real funcHi = m_implicitFunction->value(HiPt);
          Real funcLo = m_implicitFunction->value(LoPt);

          // the sign of signHi and signLo determine edgetype
          Real signHi;
          Real signLo;

          // For level set data negative -> in the fluid
          //                    positive -> out of the fluid
          signHi = -funcHi;
          signLo = -funcLo;

          edgeType(covered,regular,dontKnow,signHi,signLo);

          // Given edgeType, set the edge Hi  and Lo pts
          if (covered)
            {
              a_faceRegular=false;

              LoPt[range] = a_origin[range] + (a_iv[range]+0.5)*a_vectDx[range];
              LoPtChanged = true;

              HiPt[range] = a_origin[range] + (a_iv[range]+0.5)*a_vectDx[range];
              HiPtChanged = true;
            }
          else if (regular)
            {
              a_faceCovered = false;
            }
          else if (dontKnow)
            {
              a_faceRegular  = false;
              a_faceCovered  = false;
              a_faceDontKnow = true;

              // find where the surface intersects the edge
              Real intercept;

              intercept = BrentRootFinder(LoPt, HiPt, range);

              // choose the midpoint for an ill-conditioned problem
              if (intercept<LoPt[range] || intercept>HiPt[range])
                {
                  pout()<<"GeometryShop::edgeData: Ill-conditioned edge data"<<endl;
                  intercept = (LoPt[range]+HiPt[range])/2.0;
                }

              if (funcHi >= 0 && funcLo*funcHi <= 0)
                {
                  HiPt[range] = intercept;
                  HiPtChanged = true;
                }
              else if (funcLo >= 0 && funcLo*funcHi <= 0)
                {
                  LoPt[range] = intercept;
                  LoPtChanged = true;
                }
              else
                {
                  MayDay::Abort("Bogus intersection calculated");
                }
            }

          // express the answer relative to dx and cell-center
          if (lohi == 0)
            {
              LoPt[domain] = -0.5;
              HiPt[domain] = -0.5;
            }
          else
            {
              LoPt[domain] =  0.5;
              HiPt[domain] =  0.5;
            }

          if (LoPtChanged)
            {
              LoPt[range] -= a_origin[range];
              LoPt[range] /= a_vectDx[range];
              LoPt[range] -= (a_iv[range] + 0.5);
            }
          else
            {
              LoPt[range] = -0.5;
            }

          if (HiPtChanged)
            {
              HiPt[range] -= a_origin[range];
              HiPt[range] /= a_vectDx[range];
              HiPt[range] -= (a_iv[range] + 0.5);
            }
          else
            {
              HiPt[range] =  0.5;
            }

          CH_assert(regular || covered || (!(LoPtChanged && HiPtChanged)));
          CH_assert(regular || covered || dontKnow);
          CH_assert((!(regular && covered)) && (!(regular && dontKnow)) && (!(dontKnow && covered)));
          CH_assert(regular || covered || LoPtChanged || HiPtChanged);
          // default is something invalid
          bool intersectLo = LoPtChanged;

          // define this edge
          // Note we have some irregular edges of 0 length
          a_edges[index].define(LoPt,HiPt,intersectLo, range,covered,regular,dontKnow);
        }
    }
}

void GeometryShop::edgeType(bool& a_covered,
                            bool& a_regular,
                            bool& a_dontKnow,
                            Real& a_signHi,
                            Real& a_signLo) const
{
  // if signHi and signLo are both positive
  if (a_signHi > 0.0 && a_signLo > 0.0)
    {
      a_covered  = false;
      a_regular  = true;
      a_dontKnow = false;
    }

  // if signHi and signLo are both negative
  else if (a_signHi <= 0.0 && a_signLo <= 0.0)
    {
      a_covered  = true;
      a_regular  = false;
      a_dontKnow = false;
    }

  // if signHi or signLo both are zero
  else if (a_signHi == 0.0 && a_signLo == 0.0)
    {
      a_covered  = true;
      a_regular  = false;
      a_dontKnow = false;
    }

  // otherwise signLo*signHi <= 0
  // in this case we will look for an intersection point
  else
    {
      a_covered  = false;
      a_regular  = false;
      a_dontKnow = true;
    }

  return;
}

Real GeometryShop::Min(const Real x, const Real y)const
{
  Real retval;
  if (x < y)
    {
      retval = x;
    }
  else
    {
      retval = y;
    }
  return retval;
}

//  The following is an implementation of "Brent's Method"
//    for one-dimensional root finding. Pseudo-code for this
//    algorithm can be found on p. 253 of "Numerical Recipes"
//    ISBN 0-521-30811-9
Real GeometryShop::BrentRootFinder(const RealVect& a_x1,
                                   const RealVect& a_x2,
                                   const int&      a_range) const
{
  const Real tol = PolyGeom::getTolerance();

  //  Max allowed iterations and floating point precision
  const unsigned int  MAXITER = 100;
#if defined(CH_USE_DOUBLE)
  const Real      EPS   = 3.0e-15;
#elif defined(CH_USE_FLOAT)
  const Real      EPS   = 3.0e-7;
#else
#error Unknown Chombo precision
#endif
  unsigned int i;
  RealVect aPt;
  RealVect bPt;
  Real c, fa, fb, fc;
  Real d, e;
  Real tol1, xm;
  Real p, q, r, s;

  aPt = a_x1;
  bPt = a_x2;

  fa = -m_implicitFunction->value(aPt);
  fb = -m_implicitFunction->value(bPt);

  //  Init these to be safe
  c = d = e = 0.0;

  if (fb*fa > 0)
    {
      pout() << "fa " << fa << " fb " << fb <<endl;
      MayDay::Abort("GeometryShop::BrentRootFinder. Root must be bracketed, but instead the supplied end points have the same sign.");
    }

  fc = fb;

  for (i = 0; i < MAXITER; i++)
    {
      if (fb*fc > 0)
        {
          //  Rename a, b, c and adjust bounding interval d
          c = aPt[a_range];
          fc  = fa;
          d = bPt[a_range] - aPt[a_range];
          e = d;
        }

      if (Abs(fc) < Abs(fb))
        {
          aPt[a_range] = bPt[a_range];
          bPt[a_range] = c;
          c = aPt[a_range];
          fa  = fb;
          fb  = fc;
          fc  = fa;
        }

      //  Convergence check
      tol1  = 2.0 * EPS * Abs(bPt[a_range]) + 0.5 * tol;
      xm    = 0.5 * (c - bPt[a_range]);

      if (Abs(xm) <= tol1 || fb == 0.0)
        {
          break;
        }

      if (Abs(e) >= tol1 && Abs(fa) > Abs(fb))
        {
          //  Attempt inverse quadratic interpolation
          s = fb / fa;
          if (aPt[a_range] == c)
            {
              p = 2.0 * xm * s;
              q = 1.0 - s;
            }
          else
            {
              q = fa / fc;
              r = fb / fc;
              p = s * (2.0 * xm * q * (q-r) - (bPt[a_range]-aPt[a_range]) * (r-1.0));
              q = (q-1.0) * (r-1.0) * (s-1.0);
            }

          //  Check whether in bounds
          if (p > 0) q = -q;

          p = Abs(p);

          if (2.0 * p < Min(3.0*xm*q-Abs(tol1*q), Abs(e*q)))
            {
              //  Accept interpolation
              e = d;
              d = p / q;
            }
          else
            {
              //  Interpolation failed, use bisection
              d = xm;
              e = d;
            }
        }
      else
        {
          //  Bounds decreasing too slowly, use bisection
          d = xm;
          e = d;
        }

      //  Move last best guess to a
      aPt[a_range] = bPt[a_range];
      fa  = fb;

      //  Evaluate new trial root
      if (Abs(d) > tol1)
        {
          bPt[a_range] = bPt[a_range] + d;
        }
      else
        {
          if (xm < 0) bPt[a_range] = bPt[a_range] - tol1;
          else        bPt[a_range] = bPt[a_range] + tol1;
        }

      fb = -m_implicitFunction->value(bPt);
    }

  if (i >= MAXITER)
    {
      cerr  << "BrentRootFinder: exceeding maximum iterations: "
            << MAXITER << endl;
    }
  //  //  Keep statistics
  //     statCount++;
  //     statSum += i;
  //     statSum2  += i*i;

  return bPt[a_range];
}

// Coordinates are in the box: [-0.5,0.5] x [-0.5,0.5]
// It is assumed that the spacing in x is uniform
Real GeometryShop::PrismoidalAreaCalc(RealVect& a_xVec,
                                      RealVect& a_yVec) const
{
  // The area of the parabola determined by the three input points
  Real retval;

  // See if parabolic approximation, a*x^2 + b*x + c, stays in bounds
  Real aScale;  // a times 2h^2
  Real bScale;  // b times 2h
  Real cScale;  // c

  aScale = a_yVec[2] - 2*a_yVec[1] + a_yVec[0];
  bScale = a_yVec[2] - a_yVec[0];
  cScale = a_yVec[1];

  // If the parabolic extreme isn't between a_xVec[0] and a_xVec[2]
  // or the parabolic extreme is inside the current cell
  //
  //   Note:  The tests below were designed to avoid any division operations
  //          to avoid numeric problems.  What follows is an explanation of
  //          the tests.
  //
  //   If we put a_xVec[0] at x = -h, a_xVec[1] at x = 0, and a_xVec[2] at
  //   x = h then the parabolic fit, f(x), to the data is:
  //
  //       f(x) = a*x^2 + b*x + c
  //
  //   Where:
  //
  //       a = aScale / (2*h^2)
  //       b = bScale / (2*h)
  //       c = cScale
  //
  //   The location of the parabolic extreme is:
  //
  //       xExtreme = -b / (2*a) = h * -bScale / (2*aScale)
  //
  //   This isn't between a_xVec[0] and a_xVec[2] if |x| > h and this implies:
  //
  //       | h * -bScale / (2*aScale) | > h  =>
  //       | bScale | > 2 * | aScale |
  //
  //   Which is the first test below.
  //
  //   The value at the parabolic extreme is:
  //
  //       f(xExtreme) = (4*a*c - b^2) / (4*a)
  //                   = (8*aScale*cScale - bScale^2) / (8*aScale)
  //
  //   And this is inbounds if it is between -1/2 and 1/2 implying:
  //
  //       | f(xExtreme) | <= 1/2                                =>
  //       | (8*aScale*cScale - bScale^2) / (8*aScale) | <= 1/2  =>
  //       | (8*aScale*cScale - bScale^2) | <= | 4*aScale |
  //
  //   Which is the second test below.
  if ((Abs(bScale) > 2*Abs(aScale)) ||
      (Abs(8*aScale*cScale - bScale*bScale) <= Abs(4*aScale)))
    {
      // Compute the area of the parabola

      // Integrate w.r.t. x, y is a function of x
      // (x_vec[1],y_vec[1]) is the middle point

      // Learn whether x_vec[0] or x_vec[2] is smaller (with origin = cell center)
      Real largeX = a_xVec[2];
      Real smallX = a_xVec[0];

      // Y's that go with the largeX and smallX
      Real largeX_Y = a_yVec[2];
      Real smallX_Y = a_yVec[0];

      // Swap large for small, if necessary
      if (a_xVec[0] > a_xVec[2])
        {
          largeX = a_xVec[0];
          smallX = a_xVec[2];

          largeX_Y = a_yVec[0];
          smallX_Y = a_yVec[2];
        }

      // Find h
      Real h = 0.5 * (largeX - smallX);
      CH_assert (h >= 0.0);

      // Prismoidal rule, which is exact on cubics.
      retval = (h/3.0) * (a_yVec[0] + 4.0 * a_yVec[1] + a_yVec[2]);

      // yVec relative to cell center. Hence add 0.5, but
      // adding 0.5 to each y in the line above adds (h/3) * 3 = h)
      retval += h;

      // Unaccounted for rectangle at the high end of the face.
      retval += (0.5 - largeX) * (largeX_Y + 0.5);

      // Similarly, the unaccounted for rectangle may be at the small end.
      retval += (smallX + 0.5) * (smallX_Y + 0.5);
    }
  else
    {
      // If the extreme of the parabola occurs between a_xVec[0] and a_xVec[2]
      // and the lies outside the current cell then return a negative area so
      // the linear approximation is used
      retval = -1.0;
    }

  return retval;
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "PlaneIF.H"

#include "NamespaceHeader.H"

PlaneIF::PlaneIF(const RealVect& a_normal,
                 const RealVect& a_point,
                 const bool&     a_inside)
{
  // Remember the parameters
  m_normal = a_normal;
  m_point = a_point;
  m_inside = a_inside;
}

PlaneIF::PlaneIF(const PlaneIF& a_inputIF)
{
  // Remember the parameters
  m_normal = a_inputIF.m_normal;
  m_point = a_inputIF.m_point;
  m_inside = a_inputIF.m_inside;
}

PlaneIF::~PlaneIF()
{
}

void PlaneIF::GetParams(RealVect& a_normal,
                        RealVect& a_point,
                        bool&     a_inside) const
{
  // Copy parameter information over
  a_normal = m_normal;
  a_point = m_point;
  a_inside = m_inside;
}

void PlaneIF::SetParams(const RealVect& a_normal,
                        const RealVect& a_point,
                        const bool&     a_inside)
{
  // Set parameter information
  m_normal = a_normal;
  m_point = a_point;
  m_inside = a_inside;
}

Real PlaneIF::value(const RealVect& a_point) const
{
  Real retval;

  // Vector from a_point to a point on the plane
  RealVect direction(m_point);
  direction -= a_point;

  // Compute (and return) the dot product of the vector above and the normal
  retval = direction.dotProduct(m_normal);


  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

GeometryService::InOut PlaneIF::InsideOutside(const RealVect& lo, const RealVect& hi) const
{

  RealVect len = hi-lo;
  Real firstValue = value(lo);
  GeometryService::InOut rtn;
  if ( firstValue < 0 )
    {
      rtn = GeometryService::Regular;
    }
  else
    {
      rtn = GeometryService::Covered;
    }
  Box unit(IntVect::Zero, IntVect::Unit);
  for (BoxIterator b(unit); b.ok(); ++b)
    {
      RealVect corner = lo + RealVect(b())*len;
      Real functionValue = value(corner);

      if (functionValue * firstValue <= 0.0 )
      {
        return GeometryService::Irregular;
      }
    }
  return rtn;
}


BaseIF* PlaneIF::newImplicitFunction() const
{
  PlaneIF* planePtr = new PlaneIF(m_normal,
                                  m_point,
                                  m_inside);

  return static_cast<BaseIF*>(planePtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "NormalDerivative.H"

#include "NamespaceHeader.H"

// Null constructor
NormalDerivative<GLOBALDIM>::NormalDerivative()
{
}

// Destructor
NormalDerivative<GLOBALDIM>::~NormalDerivative()
{
}

// Evaluate derivatives of the normal of a BaseIF subclass
Real NormalDerivative<GLOBALDIM>::evaluate(const IvDim  & a_multiIndex,
                                           const int    & a_direction,
                                           const RvDim  & a_point,
                                           const BaseIF & a_implicitFunction)
{
  // Create an IFSlicer from the BaseIF, call "evaluate" with this, and return
  // the result
  IFSlicer<GLOBALDIM> ifSlicer(a_implicitFunction);

  return evaluate(a_multiIndex,a_direction,a_point,&ifSlicer);
}

// Evaluate derivatives of the normal of an IFSlicer class
Real NormalDerivative<GLOBALDIM>::evaluate(const IvDim               & a_multiIndex,
                                           const int                 & a_direction,
                                           const RvDim               & a_point,
                                           const IFSlicer<GLOBALDIM> * a_implicitFunction)
{
  // This is the numerator of the "a_direction" component of the normal, i.e.
  // the "a_direction" component of the gradient of the function.
  DerivativeProduct gradientComponent;
  gradientComponent[BASISV_TM<int,GLOBALDIM>(a_direction)] = 1;

  // Represent the "a_direction" component of the normal as the "a_direction"
  // component of gradient of the function, "gradientComponent", divided by
  // the magnitude of the gradient.
  int magnitudeOfGradientPower = 1;
  PartialDerivativeTerm normalComponent(gradientComponent,
                                        magnitudeOfGradientPower);

  // Compute and store the magnitude of the gradient of the function.
  m_magnitudeOfGradient = 0.0;

  for (int idir = 0; idir < GLOBALDIM; idir++)
  {
    Real firstPartial = a_implicitFunction->value(BASISV_TM<int,GLOBALDIM>(idir),a_point);
    m_magnitudeOfGradient += firstPartial*firstPartial;
  }

  m_magnitudeOfGradient = sqrt(m_magnitudeOfGradient);

  Real value = expand(a_multiIndex,
                      normalComponent,
                      a_point,
                      a_implicitFunction);

  return value;
}

//get m_magnitudeOfGradient
Real NormalDerivative<GLOBALDIM>::getMagnitudeOfGradient()
{
  return m_magnitudeOfGradient;
}

// Expand and evaluate the multi-index partial derivative of a
// PartialDerivativeTerm recursively.  If the multi-index is zero (i.e., no
// further derivatives) then simply evaluate the PartialDerivateTerm at
// "a_point" using the implicit function.  If the multi-index isn't zerom,
// explicitly compute one partial derivative which is a sum of
// PartialDerivativeTerm's and call "expand" with each of these terms and a
// reduced multi-index (which will eventually be zero).  The sum the results
// and return that sum.
Real NormalDerivative<GLOBALDIM>::expand(const IvDim                 & a_multiIndex,
                                         const PartialDerivativeTerm & a_term,
                                         const RvDim                 & a_point,
                                         const IFSlicer<GLOBALDIM>   * a_implicitFunction) const
{
  Real value;

  int firstNonZero;
  for (firstNonZero = 0; firstNonZero < GLOBALDIM; firstNonZero++)
  {
    if (a_multiIndex[firstNonZero] != 0)
    {
      break;
    }
  }

  // No more derivatives, evaluate the current term
  if (firstNonZero == GLOBALDIM)
  {
    value = 1.0;

    // Evalute the needed partial derivatives and take the product of the
    // specified powers
    const DerivativeProduct& curDerivativeProduct = a_term.first;

    for (DerivativeProduct::const_iterator it=curDerivativeProduct.begin();
         it != curDerivativeProduct.end();
         ++it)
    {
      const IvDim& curMultiIndex = it->first;
      const int&   curExponent   = it->second;

      // Evaluate a single partial derivative to its power
      Real curValue = pow(a_implicitFunction->value(curMultiIndex,a_point),curExponent);

      value *= curValue;
    }

    if (m_magnitudeOfGradient != 0.0)
    {
      // Divide by the magnitude of the gradient including the exponent
      int curExponent = a_term.second;
      value /= pow(m_magnitudeOfGradient,curExponent);
    }
  }
  else
  {
    value = 0.0;

    // This is the (current) partial derivative we are going to apply to the
    // current product of partial derivatives
    IvDim curPartialDerivative = BASISV_TM<int,GLOBALDIM>(firstNonZero);

    // This is the remaining multi-index that we haven't applied
    IvDim reducedMultiIndex = a_multiIndex;
    reducedMultiIndex[firstNonZero]--;

    // Distribute the current partial derivative over the product of
    // derivatives using the product rule
    const DerivativeProduct& curDerivativeProduct = a_term.first;
    int curExponentOfMagnitudeOfGradient = a_term.second;

    // Loop through each term in the product
    for (DerivativeProduct::const_iterator it=curDerivativeProduct.begin();
         it != curDerivativeProduct.end();
         ++it)
    {
      // Get the current derivative multi-index and exponent
      const IvDim& curMultiIndex = it->first;
      const int&   curExponent   = it->second;

      // Create the next term in the product rule by copying the current
      // product and take the current partial derivative of the current
      // product term (including the exponent).
      DerivativeProduct newDerivativeProduct = curDerivativeProduct;

      // Handle the exponent of the current product term
      Real multiplier = curExponent;

      if (curExponent == 1)
      {
        // Erase the current product term if its current exponent is one
        newDerivativeProduct.erase(curMultiIndex);
      }
      else
      {
        // Otherwise, decrement the exponent by one
        newDerivativeProduct[curMultiIndex] -= 1;
      }

      // Generate the new product term
      IvDim newMultiIndex = curMultiIndex;
      newMultiIndex += curPartialDerivative;

      // Put it into the product
      newDerivativeProduct[newMultiIndex] += 1;

      // Put the new product together with magnitude of the gradient term
      PartialDerivativeTerm newTerm(newDerivativeProduct,
                                    curExponentOfMagnitudeOfGradient);

      // Evaluate this term in the product rule (recursively)
      Real curValue = multiplier * expand(reducedMultiIndex,
                                          newTerm,
                                          a_point,
                                          a_implicitFunction);

      // Add the result into the overall product rule sum
      value += curValue;
    }

    // Now handle the last term in the overall product (and product rule)
    // which is the inverse of the magnitude of the gradient with an exponent.

    // The derivative of the magnitude of the gradient results in a sum which
    // has to be handled term by term
    for (int idir = 0; idir < GLOBALDIM; idir++)
    {
      // Copy the current overall product
      DerivativeProduct newDerivativeProduct = curDerivativeProduct;

      // Create the two new terms in the product
      IvDim firstPartial = BASISV_TM<int,GLOBALDIM>(idir);
      IvDim secondPartial = firstPartial + curPartialDerivative;

      // Put them in the new overall product
      newDerivativeProduct[firstPartial] += 1;
      newDerivativeProduct[secondPartial] += 1;

      // Generate the new exponent for the magnitude of the gradient
      int newExponentOfMagnitudeOfGradient = curExponentOfMagnitudeOfGradient + 2;

      // The multiplier due to the exponent
      Real multiplier = -curExponentOfMagnitudeOfGradient;

      // Put the new product together with magnitude of the gradient term
      PartialDerivativeTerm newTerm(newDerivativeProduct,
                                    newExponentOfMagnitudeOfGradient);

      // Evaluate this term in the product rule (recursively)
      Real curValue = multiplier * expand(reducedMultiIndex,
                                          newTerm,
                                          a_point,
                                          a_implicitFunction);

      // Add the result into the overall product rule sum
      value += curValue;
    }
  }

  return value;
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <iostream>
#include <iomanip>

#include "NormalDerivative.H"
#include "IFData.H"
//#include "CoordinateSystem.H"
#include "NamespaceHeader.H"

// empty constructor (dim == 1)
IFData<1>::IFData()
{
}

IFData<1>::IFData(const IFData<1>& a_IFData)
  :m_cornerSigns    (a_IFData.m_cornerSigns),
   m_intersection   (a_IFData.m_intersection),
   m_globalCoord    (a_IFData.m_globalCoord),
   m_cellCenterCoord(a_IFData.m_cellCenterCoord),
   m_parentCoord    (a_IFData.m_parentCoord),
   m_allVerticesIn  (a_IFData.m_allVerticesIn),
   m_allVerticesOut (a_IFData.m_allVerticesOut),
   m_allVerticesOn  (a_IFData.m_allVerticesOn),
   m_badNormal      (a_IFData.m_badNormal)
{
}

// Constructor from the implicit function
IFData<1>::IFData(const IFData<2> & a_2DIFData,
#if RECURSIVE_GEOMETRY_GENERATION != 0
                  const int       & a_maxOrder,
#endif
                  const int       & a_idir,
                  const int       & a_hilo)
  :m_globalCoord(a_2DIFData.m_globalCoord,a_idir),
   m_cellCenterCoord(a_2DIFData.m_cellCenterCoord,a_idir),
   m_parentCoord(a_2DIFData.m_localCoord,a_idir)
{
  // we want the edge on the a_hilo side of the square with normal in the
  // a_idir direction
  IFData<2>localInfo = a_2DIFData;

  // This 2D edgeIndex locates the 1D edge in the edgeIntersection map
  IndexTM<int,2>twoDEdge;
  twoDEdge[0] = (a_idir + 1)%2;
  twoDEdge[1] = a_hilo;

  m_intersection = LARGEREALVAL;
  if (localInfo.m_intersections.find(twoDEdge) != localInfo.m_intersections.end())
  {
    m_intersection = localInfo.m_intersections[twoDEdge];
  }

  // This 2D vertex locates the hi and lo ends of the 1D segment in the
  // cornerSigns map
  IndexTM<int,2>loPt2D;
  loPt2D[(a_idir + 1)%2] = 0;
  loPt2D[a_idir] = a_hilo;

  IndexTM<int,2>hiPt2D;
  hiPt2D[(a_idir+ 1)%2] = 1;
  hiPt2D[a_idir] = a_hilo;

  if (localInfo.m_cornerSigns.find(loPt2D) != localInfo.m_cornerSigns.end())
  {
    m_cornerSigns[0] = localInfo.m_cornerSigns[loPt2D];
  }
  else
  {
    MayDay::Abort("Lo endpoint not in Map");
  }

  if (localInfo.m_cornerSigns.find(hiPt2D) != localInfo.m_cornerSigns.end())
  {
    m_cornerSigns[1] = localInfo.m_cornerSigns[hiPt2D];
  }
  else
  {
    MayDay::Abort("Hi endpoint not in Map");
  }

  // set bools
  m_allVerticesIn  = true;
  m_allVerticesOut = true;
  m_allVerticesOn  = true;

  if (m_cornerSigns[0] != ON || m_cornerSigns[1] != ON)
  {
    m_allVerticesOn  = false;
  }

  if (m_cornerSigns[0] == IN || m_cornerSigns[1] == IN)
  {
    m_allVerticesOut = false;
  }

  if (m_cornerSigns[0] == OUT || m_cornerSigns[1] == OUT)
  {
    m_allVerticesIn = false;
  }

  //there is no normal in one dimension. However, if m_badNormal = true at a lower dimension, then the higher dimension refines.
  m_badNormal = false;
}

// Destructor (dim == 1)
IFData<1>::~IFData()
{
}

void IFData<1>::print(ostream& a_out) const
{
  string padding = "  ";
  for (int i = 0; i < GLOBALDIM - 1; i++)
  {
    padding += "  ";
  }

  typedef map<int,int> oneDCornerSigns;

  for (oneDCornerSigns::const_iterator it = m_cornerSigns.begin();
       it != m_cornerSigns.end(); ++it)
  {
    a_out << padding << "Vertex "
                     << "("
                     << it->first
                     << ") = "
                     << it->second
                     << "\n";
  }
  a_out << padding << "\n";

  a_out << padding << "m_allVerticesIn  = " << m_allVerticesIn  << "\n";
  a_out << padding << "m_allVerticesOut = " << m_allVerticesOut << "\n";
  a_out << padding << "m_allVerticesOn  = " << m_allVerticesOn  << "\n";
  a_out << padding << "m_badNormal      = " << m_badNormal      << "\n";
  a_out << padding << "\n";

  if (!m_allVerticesOut)
  {
    a_out << padding << "m_globalCoord     = " << m_globalCoord    ;
    a_out << padding << "m_cellCenterCoord = " << m_cellCenterCoord;
    a_out << padding << "m_parentCoord     = " << m_parentCoord    ;
  }
  else
  {
    a_out << padding << "All vertices out" << "\n";
  }
  a_out << padding << "\n";

  int lo = LARGEINTVAL;
  int hi = LARGEINTVAL;
  if (m_cornerSigns.find(0)!= m_cornerSigns.end())
  {
    lo = m_cornerSigns.find(0)->second;
  }
  else
  {
    MayDay::Abort("No lo in cornerSigns");
  }

  if (m_cornerSigns.find(1)!= m_cornerSigns.end())
  {
    hi = m_cornerSigns.find(1)->second;
  }
  else
  {
    MayDay::Abort("No hi in cornerSigns");
  }

  if (lo == OUT && hi == OUT)
  {
    a_out << padding << "Edge Covered" << "\n";
  }
  else if (lo==IN  && hi==IN)
  {
    a_out << padding << "Edge Uncovered" << "\n";
  }
  else if (lo==ON  || hi==ON)
  {
    a_out << padding << "Edge has vertex on the interface" << "\n";
  }
  else
  {
    if (m_intersection == LARGEREALVAL)
    {
      MayDay::Warning("--- No intersection pt");
    }
    else
    {
      std::ios::fmtflags origFlags = a_out.flags();
      int origWidth = a_out.width();
      int origPrecision = a_out.precision();

      a_out << padding << "Intersection pt is "
                       << setw(23)
                       << setprecision(16)
                       << setiosflags(ios::showpoint)
                       << setiosflags(ios::scientific)
                       << m_intersection
                       << "\n";

      a_out.flags(origFlags);
      a_out.width(origWidth);
      a_out.precision(origPrecision);
    }
  }
  a_out << padding << "\n";
}

// equals operator
void IFData<1>::operator=(const IFData & a_IFData)
{
  if (this != &a_IFData)
  {
    m_cornerSigns     = a_IFData.m_cornerSigns;
    m_intersection    = a_IFData.m_intersection;
    m_globalCoord     = a_IFData.m_globalCoord;
    m_cellCenterCoord = a_IFData.m_cellCenterCoord;
    m_parentCoord     = a_IFData.m_parentCoord;
    m_allVerticesIn   = a_IFData.m_allVerticesIn;
    m_allVerticesOut  = a_IFData.m_allVerticesOut;
    m_allVerticesOn   = a_IFData.m_allVerticesOn;
    m_badNormal   = a_IFData.m_badNormal;
  }
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>
#include "GeometryService.H"
#include "GeometryShop.H"
#include "Moments.H"
#include "LSquares.H"
#include "PolyGeom.H"
#include "RealVect.H"
#include "CH_Timer.H"

#include "NamespaceHeader.H"


void LSquares::LeastSquares(Real** A,
                            Vector<Real>&x,
                            const Vector<Real>&rhs)

{
  CH_TIMELEAF("LSquares::leastSquares");
  int numColsA = x.size();
  int numRowsA = rhs.size();

  Real** Atrans;
  allocArray(numColsA,numRowsA,Atrans);

  Real** LS; // LS = least squares matrix; Ax = rhs is an overdetermined system
  allocArray(numColsA,numColsA,LS);

  transpose(A,Atrans,numRowsA,numColsA);

  matMul(Atrans,A,LS,numColsA,numRowsA,numColsA);

  // pattern is (A,B,A*B,numrowsA,numcolsA,numcolsB)
  Vector<Real> ATrhs(numColsA);
  AtimesX(Atrans,rhs,numColsA,ATrhs); // numCols = number of rows of Atranspose*A

  gaussElim(LS,ATrhs);
  // char* bug = "LS";
  // output(numColsA,numColsA,LS,bug);

  backSolve(LS,ATrhs,numColsA,x); // x is the answer

  freeArray(numColsA,numRowsA,Atrans);
  freeArray(numColsA,numColsA,LS);
}

void LSquares::AtimesX(Real** A,
                       const Vector<Real>& x,
                       const int& numRowsA,
                       Vector<Real>& Ax)
{
  for (int i = 0; i < numRowsA; i++)
    {
      Real* scanA = A[i];

      Real sum = 0.0;
      int xSize = x.size();

      for (int j = 0; j < xSize; j++)
        {
          sum += *(scanA++) * x[j];
        }

      Ax[i] = sum;
    }
}

// this is written for square A
int  LSquares::gaussElim(Real** A,
                         Vector<Real>& rhs)
{
  //   char* name = "A";
  int currRow = 0;
  int numRows = rhs.size();
  int numCols = rhs.size();

  for (int currCol = 0; currCol < numCols; ++currCol)
    {
      int pivot;

      findPivot(A,currCol, currRow,numRows,pivot);
      // output(numRows,numCols,A,name);
      //
      if (Abs(A[pivot][currCol]) > 1.0e-15)
      {
        swapRows(A,currRow,pivot,numCols);
        swapRows(rhs,currRow,pivot);

        Real Beta = A[currRow][currCol];
        Beta = 1.0/Beta;

        timesBeta(A,currRow,Beta, numCols);
        timesBeta(rhs,currRow,Beta);

        // output(numRows,numCols,A,name);
        for (int rows = currRow; rows < numRows-1; ++rows)
        {
          Real alpha = -A[rows+1][currCol];

          addRows(A,rows+1,alpha,currRow,numCols);
          addRows(rhs,rows+1,alpha,currRow);
          // output(numRows,numCols,A,name);
        }
        currRow += 1;
      }
      else
      {
        // MayDay::Warning("small pivot in gaussElim");
      }
    }

  return 0;
}

void LSquares::swapRows(Vector<Real>& rhs,
                        const int& currRow,
                        const int& pivot)
{
  Real    temp = rhs[currRow];
  rhs[currRow] = rhs[pivot];
  rhs[pivot]   = temp;
}

void LSquares::swapRows(Real** A,
                        const int& rowi,
                        const int& rowj,
                        const int& numCols)
{
  Real *scani = A[rowi];
  Real *scanj = A[rowj];

  for (int count = 0; count < numCols; ++count)
    {
      Real temp;

      temp     = (*scani);
      (*scani) = (*scanj);
      (*scanj) = temp;

      scani++;
      scanj++;
    }
}

int LSquares::findPivot(Real** A,
                        const int& currCol,
                        const int& currRow,
                        const int& numRows,
                        int& pivot)
{
  Real max = 0;
  pivot = currRow;

  for (int count = currRow; count < numRows; count++)
    {
      if (Abs(A[count][currCol]) > max)
        {
          max = Abs(A[count][currCol]);
          pivot = count;
        }
   }

  return 0;
}

void LSquares::addRows(Vector<Real>& rhs,
                       const int& rowi,
                       const Real& alpha,
                       const int& rowj)
{
  rhs[rowi] += alpha * rhs[rowj];
}

void LSquares::addRows(Real** A,
                       const int& rowi,
                       const Real& alpha,
                       const int& rowj,
                       const int& numCols) // rowi += alpha * rowj
{
  Real *scani = A[rowi];
  Real *scanj = A[rowj];

  for (int count = 0; count < numCols; ++count)
    {
      (*scani) += alpha * (*scanj);
      scani++;
      scanj++;
    }
}

void LSquares::timesBeta(Vector<Real>&rhs,
                         const int& currRow,
                         const Real& Beta)
{
  rhs[currRow] *= Beta;
}

void  LSquares::timesBeta(Real** A,
                          const int& rowi,
                          const Real& Beta,
                          const int& numCols)
{
  Real *scanA = A[rowi];

  for (int count = 0; count < numCols; ++count)
    {
      (*scanA) *= Beta;
      scanA++;
    }
}

void LSquares::transpose(Real** a_A,
                         Real** a_Atrans,
                         const int& a_numRowsA,
                         const int& a_numColsA)
{
  for (int irow = 0; irow < a_numColsA; ++irow)
    {
      Real *scanAtrans = a_Atrans[irow];

      for (int icol = 0; icol < a_numRowsA; ++icol)
        {
          (*scanAtrans) = a_A[icol][irow];
          scanAtrans++;
       }
    }
}

void LSquares::matMul(Real** a_A,
                      Real** a_B,
                      Real** a_C,
                      const int& a_numRowsA,
                      const int& a_numColsA,
                      const int& a_numColsB)
{
  for (int i = 0; i < a_numRowsA; ++i)
  {
    Real* scanC = a_C[i];

    for (int j = 0; j < a_numColsB; ++j)
    {
      Real* scanA = a_A[i];
      Real sum = 0.0;

      for (int k = 0; k < a_numColsA; ++k)
      {
        sum += (*scanA) * a_B[k][j];
        scanA++;
      }

      (*scanC) = sum;
      scanC++;
    }
  }
}

void LSquares::backSolve(Real** a_A,
                         const Vector <Real>& a_rhs,
                         const int& a_numArows,
                         Vector<Real>& a_x)
{
  int N = a_numArows;
  for (int n = 0; n < N; ++n)
    {
      a_x[n] = 0.0;
    }

  for (int n = N-1; n >= 0; --n)
    {
      for (int m = 1; m < N-n; ++m)
        {
          a_x[n] -= a_x[n+m] * a_A[n][n+m];
        }
      if (Abs(a_A[n][n]) > 0.0)
        {
          a_x[n] += a_rhs[n] / a_A[n][n]; // this only works for square A
        }
    }
}

void LSquares::allocArray(const int& rows,
                          const int& cols,
                          Real**& A)
{
  A = new Real* [rows];

  for (int i = 0; i < rows;i++)
    {
      A[i] = new Real [cols];
      Real* scanA = A[i];

      for (int j = 0; j < cols; j++)
        {
          *(scanA++) = 0.0;
        }
    }
}

void LSquares::freeArray(const int& rows,
                         const int& cols,
                         Real**& A)
{
  for (int i = 0; i < rows; i++)
    {
      delete[] A[i];
    }

  delete[] A;
}

void LSquares::output(const int& rows,
                      const int& cols,
                      Real**& A,
                      char* name)
{
  // pout() << "outputting " << name << endl;
  for (int i = 0; i < rows; i++)
    {
      for (int j = 0; j < cols; j++)
       {
         pout() << A[i][j] << " ";
       }
      pout() << endl;
    }
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "IntersectionIF.H"

#include "NamespaceHeader.H"

IntersectionIF::IntersectionIF(const BaseIF& a_impFunc1,
                               const BaseIF& a_impFunc2)
{
  // Number of implicit function in intersection
  m_numFuncs = 2;

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  // Make copies of the implicit functions
  m_impFuncs[0] = a_impFunc1.newImplicitFunction();
  m_impFuncs[1] = a_impFunc2.newImplicitFunction();
}

IntersectionIF::IntersectionIF(const Vector<BaseIF *>& a_impFuncs)
{
  // Number of implicit function in intersection
  m_numFuncs = a_impFuncs.size();

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  // Make copies of the implicit functions

  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (a_impFuncs[ifunc] == NULL)
    {
      m_impFuncs[ifunc] = NULL;
    }
    else
    {
      m_impFuncs[ifunc] = a_impFuncs[ifunc]->newImplicitFunction();
    }
  }
}

IntersectionIF::IntersectionIF(const IntersectionIF& a_inputIF)
{
  // Number of implicit function in intersection
  m_numFuncs = a_inputIF.m_impFuncs.size();

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);



  // Make copies of the implicit functions
  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (a_inputIF.m_impFuncs[ifunc] == NULL)
    {
      m_impFuncs[ifunc] = NULL;
    }
    else
    {
      m_impFuncs[ifunc] = a_inputIF.m_impFuncs[ifunc]->newImplicitFunction();
    }
  }
}

IntersectionIF::~IntersectionIF()
{
  // Delete all the copies
  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (m_impFuncs[ifunc] != NULL)
    {
      delete m_impFuncs[ifunc];
    }
  }
}

Real IntersectionIF::value(const RealVect& a_point) const
{

  // Maximum of the implicit functions values
  Real retval;

  retval = -1.0;

  // Find the maximum value and return it
  if (m_numFuncs > 0)
    {
      retval = m_impFuncs[0]->value(a_point);

      for (int ifunc = 1; ifunc < m_numFuncs; ifunc++)
        {
          Real cur;

          cur = m_impFuncs[ifunc]->value(a_point);
            if (cur > retval)
              {
                retval = cur;
              }
        }
    }

  return retval;
}

Real IntersectionIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{
  int closestIF = -1;
  findClosest(a_point,closestIF);

  if (closestIF == -1)
  {
    return -1.0;
  }
  else
  {
    return m_impFuncs[closestIF]->value(a_point);
  }
}

Real IntersectionIF::value(const IndexTM<int,GLOBALDIM> & a_partialDerivative,
                           const IndexTM<Real,GLOBALDIM>& a_point) const
{
  int closestIF = -1;
  findClosest(a_point,closestIF);

  if (closestIF == -1)
  {
    if (a_partialDerivative.sum() == 0)
    {
      return -1.0;
    }
    else
    {
      return 0.0;
    }
  }
  else
  {
    return m_impFuncs[closestIF]->value(a_partialDerivative,a_point);
  }
}

BaseIF* IntersectionIF::newImplicitFunction() const
{
  IntersectionIF* intersectionPtr = new IntersectionIF(m_impFuncs);

  return static_cast<BaseIF*>(intersectionPtr);
}

void IntersectionIF::findClosest(const IndexTM<Real,GLOBALDIM> & a_point,
                                 int                           & a_closestIF) const
{
  Real retval = 0.0;

  if (m_numFuncs > 0)
    {
      retval = m_impFuncs[0]->value(a_point);
      a_closestIF = 0;

      for (int ifunc = 1; ifunc < m_numFuncs; ifunc++)
        {
          Real cur;
          cur = m_impFuncs[ifunc]->value(a_point);
          if (cur > retval)
            {
              retval = cur;
              a_closestIF = ifunc;
            }
        }
    }
}

bool IntersectionIF::fastIntersection(const RealVect& a_low,
                                      const RealVect& a_high) const
{
  for (int i=0; i<m_impFuncs.size(); i++)
    {
      if (!m_impFuncs[i]->fastIntersection(a_low, a_high)) return false;
    }
  return true;
}

GeometryService::InOut IntersectionIF::InsideOutside(const RealVect& a_low,
                                                     const RealVect& a_high) const
{
  CH_assert(fastIntersection(a_low, a_high));

  bool allRegular = true;
  for (int i = 0; i<m_numFuncs; ++i)
    {
      GeometryService::InOut r =  m_impFuncs[i]->InsideOutside(a_low, a_high);
      if (r == GeometryService::Covered) return r;
      if (r == GeometryService::Irregular) allRegular = false;
    }
  if (allRegular) return GeometryService::Regular;
  return GeometryService::Irregular;
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "LatheIF.H"
#include "UnionIF.H"

#include "NamespaceHeader.H"

LatheIF::LatheIF(const BaseIF& a_impFunc1,
                 const bool&                 a_inside)
{
  // Make a copy of the implicit function and note only one was given
  m_impFunc1 = a_impFunc1.newImplicitFunction();
  m_impFunc2 = NULL;

  // Save inside flag
  m_inside = a_inside;
}

LatheIF::LatheIF(const BaseIF& a_impFunc1,
                 const BaseIF& a_impFunc2,
                 const RealVect&             a_point,
                 const bool&                 a_inside)
{
  // Make a copy of both implicit functions
  m_impFunc1 = a_impFunc1.newImplicitFunction();
  m_impFunc2 = a_impFunc2.newImplicitFunction();

  // Save the point of rotation
  m_point = a_point;

  // Save inside flag
  m_inside = a_inside;
}

LatheIF::LatheIF(const LatheIF& a_inputIF)
{
  // Make a copy of both implicit functions (the second may be NULL)
  m_impFunc1 = a_inputIF.m_impFunc1->newImplicitFunction();
  m_impFunc2 = a_inputIF.m_impFunc2->newImplicitFunction();

  // Save the point of rotation
  m_point = a_inputIF.m_point;

  // Save inside flag
  m_inside = a_inputIF.m_inside;
}

LatheIF::~LatheIF()
{
  delete m_impFunc1;
  if (m_impFunc2 != NULL)
  {
    delete m_impFunc2;
  }
}

Real LatheIF::value(const RealVect& a_point) const
{
  Real retval;
  Real x = a_point[0];
  Real y = a_point[1];

  // Get r value
  Real r , a;
  r= x*x;
  a= y*y;

  r = sqrt(r+a);

#if CH_SPACEDIM == 2
  RealVect coord(r,0.0);

  retval =  m_impFunc1->value(coord);
#elif CH_SPACEDIM == 3
  Real z = a_point[2];
  Real r1,z1;

  if (m_impFunc2 == NULL)
  {
    r1 = r;
    z1 = z;
  }
  else
  {
    Real theta = atan2(y,x);
    RealVect coord(theta,0.0,0.0);

    Real angle = -m_impFunc2->value(coord);

    r -= m_point[0];
    z -= m_point[1];

    r1 = cos(angle)*r - sin(angle)*z;
    z1 = sin(angle)*r + cos(angle)*z;

    r1 += m_point[0];
    z1 += m_point[1];
  }

  RealVect coord2(r1,z1,0.0);

  retval = m_impFunc1->value(coord2);
#else
  MayDay::Abort("need higher dim in LatheIF\n");
#endif

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

GeometryService::InOut LatheIF::InsideOutside(const RealVect& lo, const RealVect& hi) const
{
  GeometryService::InOut rtn = GeometryService::Irregular;
#if CH_SPACEDIM == 3
  //project the 3D box defined by (lo,hi) onto box in x-z plane, (loPlane,hiPlane)
  Vector<Real> r;
  r.resize(4);
  r[0] = sqrt(lo[0]*lo[0]+lo[1]*lo[1]);
  r[1] = sqrt(lo[0]*lo[0]+hi[1]*hi[1]);
  r[2] = sqrt(hi[0]*hi[0]+lo[1]*lo[1]);
  r[3] = sqrt(hi[0]*hi[0]+hi[1]*hi[1]);
  RealVect loPlane,hiPlane;
//   loPlane[1] = lo[1];//in constant y-plane
//   hiPlane[1] = hi[1];//in constant y-plane
  loPlane[1] = 0.;//in constant y-plane
  hiPlane[1] = 0.;//in constant y-plane
  loPlane[2] = lo[2];
  hiPlane[2] = hi[2];
  if (m_impFunc2 == NULL)
    {
      loPlane[0] = r[0];
      hiPlane[0] = r[0];
      for (int i = 1; i < 4; i++)
        {
          if (r[i] < loPlane[0])
          {
            loPlane[0] = r[i];
          }
          if (r[i] > hiPlane[0])
          {
            hiPlane[0] = r[i];
          }
        }
    }
  else
    {
      MayDay::Abort("LatheIF::InsideOutside should not get here if m_impFunc2 != NULL\n");
    }
//   //now check intersection of projected box with surface (just as in PlaneIF)
//   RealVect len = hiPlane-loPlane;
//   Real firstValue = value(loPlane);
//   GeometryService::InOut rtn;
//   if ( firstValue < 0 )
//     {
//       rtn = GeometryService::Regular;
//     }
//   else
//     {
//       rtn = GeometryService::Covered;
//     }
//   Box unit(IntVect::Zero, IntVect::Unit);
//   for (BoxIterator b(unit); b.ok(); ++b)
//     {
//       RealVect corner = loPlane + RealVect(b())*len;
//       Real functionValue = value(corner);

//       if (functionValue * firstValue <= 0.0 )
//       {
//         return GeometryService::Irregular;
//       }
//     }
  rtn = m_impFunc1->InsideOutside(loPlane,hiPlane);
#else
  MayDay::Abort("LatheIF insideOutside for fastIntersection only works in 3D\n");
#endif
  return rtn;
}

BaseIF* LatheIF::newImplicitFunction() const
{
  LatheIF* lathePtr;

  if (m_impFunc2 == NULL)
  {
   lathePtr = new LatheIF(*m_impFunc1,m_inside);
  }
  else
  {
   lathePtr = new LatheIF(*m_impFunc1,*m_impFunc2,m_point,m_inside);
  }

  return static_cast<BaseIF*>(lathePtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "IFInspector.H"
#include "NormalDerivative.H"

#include "NamespaceHeader.H"

////////////////////

void IFInspector::fillValues(EBCellFAB     & a_ebFab,
                             const BaseIF  & a_imIF,
                             const RealVect& a_origin,
                             const RealVect& a_dx)
{
  //a particular box in the layout
  const Box& box = a_ebFab.box();

  //a particular box, which is linked to the results of computeVoFInternals
  const EBISBox& ebisBox = a_ebFab.getEBISBox();

  //This is all cells in the calculation
  IntVectSet ivs(box);
  for (VoFIterator vofit(ivs,ebisBox.getEBGraph()); vofit.ok(); ++vofit)
    {
      const VolIndex& vof = vofit();
      const IntVect thisIv = vof.gridIndex();

      IndexTM<Real,GLOBALDIM> coord;

      for (int i=0;i<SpaceDim;i++)
        {
          coord[i]=a_origin[i]+thisIv[i]*a_dx[i];
        }
      a_ebFab(vof,0)=a_imIF.value(coord);
    }
}

////////////////////

void IFInspector::fillValues(LevelData<EBCellFAB>& a_levelFab,
                             const BaseIF& a_imIF,
                             const RealVect& a_origin,
                             const RealVect& a_dx)
{
  for (DataIterator dit = a_levelFab.dataIterator();dit.ok();++dit)
    {
      EBCellFAB & ebFab=a_levelFab[dit()];
      fillValues(ebFab,a_imIF,a_origin,a_dx);
    }
}

////////////////////

void IFInspector::fillNormal(EBCellFAB     & a_ebFab,
                             const BaseIF  & a_imIF,
                             const RealVect& a_origin,
                             const RealVect& a_dx)
{
  //a particular box in the layout
  const Box& box = a_ebFab.box();

  //a particular box, which is linked to the results of computeVoFInternals
  const EBISBox& ebisBox = a_ebFab.getEBISBox();

  //This is all cells in the calculation
  IntVectSet ivs(box);
  for (VoFIterator vofit(ivs,ebisBox.getEBGraph()); vofit.ok(); ++vofit)
    {
      const VolIndex& vof = vofit();
      const IntVect thisIv = vof.gridIndex();

      IndexTM<Real,GLOBALDIM> coord;

      for (int i=0;i<SpaceDim;i++)  //todo: think out the third coordinate here and below
        {
          coord[i]=a_origin[i]+thisIv[i]*a_dx[i];
        }

      NormalDerivative<GLOBALDIM> normalDerivative;

      for (int idir=0; idir < GLOBALDIM; ++idir)
        {
          IndexTM<int,GLOBALDIM> zero = IndexTM<int,GLOBALDIM>::Zero;
          a_ebFab(vof,idir) = normalDerivative.evaluate(zero,
                                                        idir,
                                                        coord,
                                                        a_imIF);
        }
    }
}

////////////////////

void IFInspector::fillNormal(LevelData<EBCellFAB> & a_levelFab,
                             const BaseIF         & a_imIF,
                             const RealVect       & a_origin,
                             const RealVect       & a_dx)
{
  for (DataIterator dit = a_levelFab.dataIterator();dit.ok();++dit)
    {
      EBCellFAB & ebFab=a_levelFab[dit()];
      fillNormal(ebFab,a_imIF,a_origin,a_dx);
    }
}

////////////////////

void IFInspector::fillGradNormal(EBCellFAB     & a_ebFab,
                                 const BaseIF  & a_imIF,
                                 const RealVect& a_origin,
                                 const RealVect& a_dx)
{
  //a particular box in the layout
  const Box& box = a_ebFab.box();

  //a particular box, which is linked to the results of computeVoFInternals
  const EBISBox& ebisBox = a_ebFab.getEBISBox();

  //This is all cells in the calculation
  IntVectSet ivs(box);
  for (VoFIterator vofit(ivs,ebisBox.getEBGraph()); vofit.ok(); ++vofit)
    {
      const VolIndex& vof = vofit();
      const IntVect thisIv = vof.gridIndex();

      IndexTM<Real,GLOBALDIM> coord;

      for (int i=0;i<SpaceDim;i++)
        {
          coord[i]=a_origin[i]+thisIv[i]*a_dx[i];
        }

      NormalDerivative<GLOBALDIM> normalDerivative;
      int k = 0;
      for (int idir = 0; idir < GLOBALDIM ; ++idir)
        {
          for (int jdir = 0; jdir < GLOBALDIM ; ++jdir)
            {
              IndexTM<int,GLOBALDIM> deriv = BASISV_TM<int,GLOBALDIM>(jdir);
              a_ebFab(vof,k++) = normalDerivative.evaluate(deriv,
                                                           idir,
                                                           coord,
                                                           a_imIF);
            }
        }
    }
}

////////////////////

void IFInspector::fillGradNormal(LevelData<EBCellFAB>& a_levelFab,
                                 const BaseIF& a_imIF,
                                 const RealVect& a_origin,
                                 const RealVect& a_dx)
{
  for (DataIterator dit = a_levelFab.dataIterator();dit.ok();++dit)
    {
      EBCellFAB & ebFab= a_levelFab[dit()];
      fillGradNormal(ebFab,a_imIF,a_origin,a_dx);
    }
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "ComplementIF.H"

#include "NamespaceHeader.H"

ComplementIF::ComplementIF(const BaseIF& a_impFunc,
                           const bool&   a_complement)
{
  m_impFunc = a_impFunc.newImplicitFunction();
  m_complement = a_complement;
}

ComplementIF::ComplementIF(const ComplementIF& a_inputIF,
                           const bool&         a_complement)
{
  m_impFunc = a_inputIF.m_impFunc->newImplicitFunction();
  m_complement = a_complement;
}

ComplementIF::~ComplementIF()
{
  delete m_impFunc;
}

void ComplementIF::GetParams(bool& a_complement) const
{
  // Copy parameter information over
  a_complement = m_complement;
}

void ComplementIF::SetParams(const bool& a_complement)
{
  // Set parameter information
  m_complement = a_complement;
}

Real ComplementIF::value(const RealVect& a_point) const
{
  Real retval;

  // Implicit function value
  retval = m_impFunc->value(a_point);

  // Return the negative if complement is turned on (true)
  if (m_complement)
  {
    retval = -retval;
  }

  return retval;
}

Real ComplementIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{

  Real retval;

  // Implicit function value
  retval = m_impFunc->value(a_point);

  // Return the negative if complement is turned on (true)
  if (m_complement)
  {
    retval = -retval;
  }

  return retval;

}

Real ComplementIF::value(const IndexTM<int,GLOBALDIM> & a_partialDerivative,
                        const IndexTM<Real,GLOBALDIM>& a_point) const
{
  Real retval = m_impFunc->value(a_partialDerivative,a_point);

  // Return the negative if complement is turned on (true)
  if (m_complement)
  {
    retval = -retval;
  }

  return retval;
}

GeometryService::InOut ComplementIF::InsideOutside(const RealVect& a_low, const RealVect& a_high) const
{
  GeometryService::InOut r = m_impFunc->InsideOutside(a_low, a_high);
  if (!m_complement) return r;
  if (r == GeometryService::Regular) return GeometryService::Covered;
  if (r == GeometryService::Covered) return GeometryService::Regular;
  return GeometryService::Irregular;
}



BaseIF* ComplementIF::newImplicitFunction() const
{
  ComplementIF* complementPtr = new ComplementIF(*m_impFunc,m_complement);

  return static_cast<BaseIF*>(complementPtr);
}

#include "NamespaceFooter.H"

#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "IntVect.H"

#include "PolynomialIF.H"

#include "BilinearIF.H"
#include "NamespaceHeader.H"



BilinearIF::BilinearIF(LevelData<NodeFArrayBox>       * a_etaCorner,
                       const IndexTM<Real,GLOBALDIM>  & a_origin,
                       const IndexTM<Real,GLOBALDIM>  & a_dx,
                       DisjointBoxLayout              * a_grids)
  :  m_etaCorner(a_etaCorner),
     m_origin3D(a_origin),
     m_dx3D(a_dx),
     m_grids(a_grids)
{
}

BilinearIF::BilinearIF(const BilinearIF& a_inputIF)
{
  m_etaCorner = a_inputIF.getEtaCorner();
  m_origin3D = a_inputIF.m_origin3D;
  m_dx3D = a_inputIF.m_dx3D;
  m_grids = a_inputIF.getGrid();
}

BilinearIF::~BilinearIF()
{
}

LevelData<NodeFArrayBox>* BilinearIF::getEtaCorner() const
{
  return m_etaCorner;
}

DisjointBoxLayout* BilinearIF::getGrid() const
{
  return m_grids;
}

void BilinearIF::findIndex(const IndexTM<Real,GLOBALDIM>& a_point ,IntVect& a_index) const
{
  const int indicex = floor((a_point[0] - m_origin3D[0])/m_dx3D[0]);
  const int indicey = floor((a_point[1] - m_origin3D[1])/m_dx3D[1]);
  a_index.setVal(0,indicex);
  a_index.setVal(1,indicey);
}


Real BilinearIF::value(const IndexTM<int,GLOBALDIM> & a_partialDerivativeOp,
                       const IndexTM<Real,GLOBALDIM>& a_point) const
{
  Real retval = LARGEREALVAL;
  //eta is the first component in FArrayBox
  int etacomp = 0;

  //find the coordinates of lower left corner of the box containing a_point
  IntVect index = IntVect::Zero;
  findIndex(a_point,index);

  //find values to interpolate:hil,hir,hsl,hsr
  Real hCorner[4];
  //iterate through LevelData of m_etaCorner
  for (DataIterator dit = m_etaCorner->dataIterator();dit.ok();++dit)
    {
      NodeFArrayBox& nodeFAB = (*m_etaCorner)[dit()];

      Box boxIterNode = (*m_grids)[dit()];
      boxIterNode.surroundingNodes();

      if (boxIterNode.contains(index))
        {
          hCorner[0] = nodeFAB(index,                       etacomp);
          hCorner[1] = nodeFAB(index + BASISV(0),           etacomp);
          hCorner[3] = nodeFAB(index + BASISV(1)+ BASISV(0),etacomp);
          hCorner[2] = nodeFAB(index + BASISV(1),           etacomp);
          break;
        }
    }

  //physical coordinates of lower left corner
  RealVect corner = RealVect::Zero;
  for (int idir = 0; idir < SpaceDim ; ++idir)
    {
      corner[idir] = index[idir] * m_dx3D[idir] + m_origin3D[idir];
    }

  //coeficients of bilinear interpolant
  const Real b = (hCorner[1]-hCorner[0])/m_dx3D[0];
  const Real c = (hCorner[2]-hCorner[0])/m_dx3D[1];
  const Real a = (hCorner[3]+hCorner[0]-hCorner[1]-hCorner[2])/(m_dx3D[0]*m_dx3D[1]);


  if ((a_partialDerivativeOp[0]==0)&&(a_partialDerivativeOp[1]==0))
    {
      retval = a*(a_point[0]-corner[0])*(a_point[1]-corner[1])+b*(a_point[0]-corner[0])+c*(a_point[1]-corner[1])+hCorner[0];
    }
  else if ((a_partialDerivativeOp[0]==1)&&(a_partialDerivativeOp[1]==0))
    {
      retval =  a*(a_point[1]-corner[1])+b;
    }
  else if ((a_partialDerivativeOp[0]==0)&&(a_partialDerivativeOp[1]==1))
    {
      retval = a*(a_point[0]-corner[0])+c;
    }
  else if ((a_partialDerivativeOp[0]==1)&&(a_partialDerivativeOp[1]==1))
    {
      retval = a;
    }
  else
    {
      retval = 0.0;
    }
  return retval;
}

Real BilinearIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{
  // Because we are intrested in the (0,0) derivative
  int ival[3];ival[0]=0;ival[1]=0;ival[2]=0;
  const IndexTM<int,GLOBALDIM> partialDerivativeOp(ival);

  return value(partialDerivativeOp,a_point);

}

Real BilinearIF::value(const RealVect& a_point) const
{
  // Because we are intrested in the (0,0) derivative
   int ival[3];
   ival[0] = 0;
   ival[1] = 0;
   ival[2] = 0;
   const IndexTM<int,GLOBALDIM> partialDerivativeOp(ival);

 // Because we are intrested in the a_point
   Real jval[3];
   jval[0] = a_point[0];
   jval[1] = a_point[1];
   jval[2] = m_dx3D[2];
  const IndexTM<Real,GLOBALDIM> point(jval);

  return value(partialDerivativeOp,point);
}


void BilinearIF::getPolynomial(Vector<PolyTerm> & a_polynomial,
                               IntVect          & a_index)
{
  //eta is the first component in FArrayBox
  int etacomp = 0;
  //find values to interpolate:hil,hir,hsl,hsr
  Real hCorner[4];

  for (DataIterator dit = m_etaCorner->dataIterator();dit.ok();++dit)
    {
      NodeFArrayBox& nodeFAB = (*m_etaCorner)[dit()];

      Box boxIterNode = (*m_grids)[dit()];
      boxIterNode.surroundingNodes();

      if (boxIterNode.contains(a_index))
        {
          hCorner[0] = nodeFAB(a_index,                       etacomp);
          hCorner[1] = nodeFAB(a_index + BASISV(0),           etacomp);
          hCorner[3] = nodeFAB(a_index + BASISV(1)+ BASISV(0),etacomp);
          hCorner[2] = nodeFAB(a_index + BASISV(1),           etacomp);
          break;
        }
    }

  //coeficients of bilinear interpolant
  const Real b = (hCorner[1]-hCorner[0])/m_dx3D[0];
  const Real c = (hCorner[2]-hCorner[0])/m_dx3D[1];
  const Real a = (hCorner[3]+hCorner[0]-hCorner[1]-hCorner[2])/(m_dx3D[0]*m_dx3D[1]);

  //physical coordinates of lower left corner
  RealVect corner = RealVect::Zero;
  for (int idir = 0; idir < SpaceDim ; ++idir)
    {
      corner[idir] = a_index[idir] * m_dx3D[idir] + m_origin3D[idir];
    }

  Real polyCoeff[4];
  polyCoeff[3] = a;
  polyCoeff[2] = b - a*corner[1];
  polyCoeff[1] = c - a*corner[0];
  polyCoeff[0] = a*corner[0]*corner[1] - b*corner[0] - c*corner[1] + hCorner[0];
  IntVect polyPower[4];
  polyPower[3][0] = 1;
  polyPower[3][1] = 1;
  polyPower[2][0] = 1;
  polyPower[2][1] = 0;
  polyPower[1][0] = 0;
  polyPower[1][1] = 1;
  polyPower[0][0] = 0;
  polyPower[0][1] = 0;

  a_polynomial.resize(4);

  a_polynomial[3].coef = polyCoeff[3];
  a_polynomial[3].powers = polyPower[3];

  a_polynomial[2].coef = polyCoeff[2];
  a_polynomial[2].powers = polyPower[2];

  a_polynomial[1].coef = polyCoeff[1];
  a_polynomial[1].powers = polyPower[1];

  a_polynomial[0].coef = polyCoeff[0];
  a_polynomial[0].powers = polyPower[0];
}


BaseIF* BilinearIF::newImplicitFunction() const
{
  BilinearIF* bilinearPtr = new BilinearIF( m_etaCorner,
                                            m_origin3D,
                                            m_dx3D,
                                            m_grids);

  return static_cast<BaseIF*>(bilinearPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif
#include <iostream>
#include "LSProblem.H"

#include "NamespaceHeader.H"

// Null Constructor
LSProblem<1>::LSProblem()
{
}

LSProblem<1>::LSProblem(const LSProblem<1> & a_lsProblem)
{
}

// Destructor
LSProblem<1>::~LSProblem()
{
}

int LSProblem<1>::recursiveCount(const int & a_degreeP)
{
  return 1;
}

void LSProblem<1>::setNumMonomials()
{
  m_numP = 1;
  m_numPLess1 = 1;
}

// Equals operator
void LSProblem<1>::operator=(const LSProblem & a_lSProblem)
{
}

void LSProblem<1>::print(ostream & a_out)const
{

}

ostream& operator<<(ostream      & a_out,
                    LSProblem<1> & a_lSProblem)
{
  a_lSProblem.print(a_out);
  return a_out;
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <string>

#include "MayDay.H"

#include "NoRefinement.H"
#include "LSProblem.H"
#include "ComputeCutCellMoments.H"

#include "NamespaceHeader.H"

// Null constructor
ComputeCutCellMoments<1>::ComputeCutCellMoments()
{
}

// Copy constructor
ComputeCutCellMoments<1>::ComputeCutCellMoments(const ComputeCutCellMoments<1>& a_thisComputeCutCellMoments)

  :m_cutCellMoments(a_thisComputeCutCellMoments.m_cutCellMoments)
{
}

// This constructor is used in the recursion
ComputeCutCellMoments<1>::ComputeCutCellMoments(const IFData<1> & a_info)
  :m_cutCellMoments(a_info)
{
}

// Destructor
ComputeCutCellMoments<1>::~ComputeCutCellMoments()
{
}

// Integrate along line segments aligned in a coordinate direction
#if RECURSIVE_GEOMETRY_GENERATION == 0
void ComputeCutCellMoments<1>::computeMoments(const int              & a_order,
                                              const int              & a_degree,
#else
void ComputeCutCellMoments<1>::computeMoments(const int              & a_orderPmax,
                                              const int              & a_degreePmax,
#endif
                                              const bool             & a_useConstraints,
                                              RefinementCriterion<1> & a_refinementCriterion)
{
  int lo = 0;
  int hi = 1;
  int loSign = m_cutCellMoments.m_IFData.m_cornerSigns[lo];
  int hiSign = m_cutCellMoments.m_IFData.m_cornerSigns[hi];

  // If entire edge out of the fluid, then moments = 0.0
  if (loSign <= ON && hiSign<= ON)
  {
#if RECURSIVE_GEOMETRY_GENERATION == 0
    for (int iDegree = 0; iDegree <= a_degree; ++iDegree)
#else
    for (int iDegree = 0; iDegree <= a_degreePmax; ++iDegree)
#endif
    {
      // Definition of m_cutCellMoments.m_moments typedef requires that we define degree as
      // a oneTuple:
      IndexTM<int,1> degree;
      degree[0] = iDegree;
      m_cutCellMoments.m_moments[degree] = 0.0;
    }
  }
  else
  {
    // Assign loPt and hiPt in m_cutCellMoments.m_IFData.m_parentCoord system

    Real loPt = LARGEREALVAL;
    Real hiPt = LARGEREALVAL;

    // m_origin is an IndexTM<Real,1>, which implies we need to use [0] everywhere
    // m_intersection is undefined if hiSign >= ON  && loSign >= ON
    if (loSign >= ON)
    {
      loPt = m_cutCellMoments.m_IFData.m_parentCoord.convertDir(
                 -0.5*m_cutCellMoments.m_IFData.m_cellCenterCoord.m_dx[0],
                 m_cutCellMoments.m_IFData.m_cellCenterCoord,
                 0);
    }
    else
    {
      CH_assert(-0.5*m_cutCellMoments.m_IFData.m_cellCenterCoord.m_dx[0]
                <= m_cutCellMoments.m_IFData.m_intersection
                &&
                m_cutCellMoments.m_IFData.m_intersection
                <= 0.5*m_cutCellMoments.m_IFData.m_cellCenterCoord.m_dx[0]);

      loPt = m_cutCellMoments.m_IFData.m_parentCoord.convertDir(
                 m_cutCellMoments.m_IFData.m_intersection,
                 m_cutCellMoments.m_IFData.m_cellCenterCoord,
                 0);
    }

    if (hiSign >= ON)
    {
      hiPt = m_cutCellMoments.m_IFData.m_parentCoord.convertDir(
                 0.5*m_cutCellMoments.m_IFData.m_cellCenterCoord.m_dx[0],
                 m_cutCellMoments.m_IFData.m_cellCenterCoord,
                 0);
    }
    else
    {
      CH_assert(-0.5*m_cutCellMoments.m_IFData.m_cellCenterCoord.m_dx[0]
                <= m_cutCellMoments.m_IFData.m_intersection
                &&
                m_cutCellMoments.m_IFData.m_intersection
                <= 0.5*m_cutCellMoments.m_IFData.m_cellCenterCoord.m_dx[0]);

      hiPt = m_cutCellMoments.m_IFData.m_parentCoord.convertDir(
                 m_cutCellMoments.m_IFData.m_intersection,
                 m_cutCellMoments.m_IFData.m_cellCenterCoord,
                 0);
    }

    // Integrate x^degree over the line segment[loPt,hiPt]
#if RECURSIVE_GEOMETRY_GENERATION == 0
    computeMomentsUsingBinomial(loPt,hiPt,loSign,hiSign,a_degree);
#else
    computeMomentsUsingBinomial(loPt,hiPt,loSign,hiSign,a_degreePmax);
#endif
  }
}

void ComputeCutCellMoments<1>::simpleComputeMoments(const Real & a_loPt,
                                                    const Real & a_hiPt,
#if RECURSIVE_GEOMETRY_GENERATION == 0
                                                    const int  & a_degree)
#else
                                                    const int  & a_degreePmax)
#endif
{
#if RECURSIVE_GEOMETRY_GENERATION == 0
  for (int iDegree = 0; iDegree <= a_degree; ++iDegree)
#else
  for (int iDegree = 0; iDegree <= a_degreePmax; ++iDegree)
#endif
  {
    //definition of m_cutCellMoments.m_moments typedef requires that we define degree thus:
    IndexTM<int,1>degree;
    degree[0] = iDegree;
    m_cutCellMoments.m_moments[degree] = pow(a_hiPt,iDegree + 1) - pow(a_loPt,iDegree +1);
    //    Real dxFactor = pow(m_cutCellMoments.m_IFData.m_globalCoord.m_dx[0],iDegree + 1);
    //m_cutCellMoments.m_moments[degree] *= dxFactor;
    m_cutCellMoments.m_moments[degree] /= (iDegree + 1);
  }
}

void ComputeCutCellMoments<1>::computeMomentsUsingBinomial(const Real & a_loPt,
                                                           const Real & a_hiPt,
                                                           const int  & a_loSign,
                                                           const int  & a_hiSign,
#if RECURSIVE_GEOMETRY_GENERATION == 0
                                                           const int  & a_degree)
#else
                                                           const int  & a_degreePmax)
#endif
{
#if RECURSIVE_GEOMETRY_GENERATION == 0
  for (int iDegree = 0; iDegree <= a_degree; ++iDegree)
#else
  for (int iDegree = 0; iDegree <= a_degreePmax; ++iDegree)
#endif
  {
    Real epsilon = a_hiPt - a_loPt;

    // Definition of m_cutCellMoments.m_moments typedef requires that we define degree thus:
    IndexTM<int,1> degree;
    degree[0] = iDegree;
    m_cutCellMoments.m_moments[degree] = 0.0;

    // New method without substracting higher order terms
    for (int j = 1; j <= iDegree + 1; j++)
    {
      int bigger = j;
      int smaller = j;
      if (iDegree + 1 - j > j)
      {
        bigger = iDegree + 1 - j;
      }
      else
      {
        smaller = iDegree + 1 - j;
      }

      int numerator = 1;
      for (int i = bigger + 1; i <= iDegree + 1; ++i)
      {
        numerator *= i;
      }

      int denominator = 1;
      for (int i = 1; i <= smaller; ++i)
      {
        denominator *= i;
      }

      Real factor = numerator / denominator;
      if (a_loSign >= ON)
      {
        m_cutCellMoments.m_moments[degree] += factor * pow(a_loPt,iDegree + 1 - j) * pow(epsilon,j);
      }
      else if (a_hiSign >= ON)
      {
        m_cutCellMoments.m_moments[degree] -= factor * pow(a_hiPt,iDegree + 1 - j) * pow(epsilon,j) * pow(-1.0,j);
      }
    }

    //Real dxFactor = pow(m_cutCellMoments.m_IFData.m_globalCoord.m_dx[0],iDegree + 1);
    //m_cutCellMoments.m_moments[degree] *= dxFactor;
    m_cutCellMoments.m_moments[degree] /= iDegree + 1;
  }
}

void ComputeCutCellMoments<1>::print(ostream & a_out) const
{
  m_cutCellMoments.print(a_out);
}

void ComputeCutCellMoments<1>::operator=(const ComputeCutCellMoments<1> & a_computeCutCellMoments)
{
  // Only copy of the two objects are distinct
  if (this != &a_computeCutCellMoments)
  {
    m_cutCellMoments = a_computeCutCellMoments.m_cutCellMoments;
  }
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "TylerChannelIF.H"

#include "NamespaceHeader.H"

TylerChannelIF::TylerChannelIF(const Real& a_x1,
                 const Real& a_x2,
                 const Real& a_y1,
                 const Real& a_y2,
                 const Real& a_yDomainLength)
{
  m_x1 = a_x1;
  m_x2 = a_x2;

  m_y1 = a_y1;
  m_y2 = a_y2;

  m_yDomainLength = a_yDomainLength;
}

TylerChannelIF::TylerChannelIF(const TylerChannelIF& a_inputIF)
{
  m_x1 = a_inputIF.m_x1;
  m_x2 = a_inputIF.m_x2;

  m_y1 = a_inputIF.m_y1;
  m_y2 = a_inputIF.m_y2;

  m_yDomainLength = a_inputIF.m_yDomainLength;
}

TylerChannelIF::~TylerChannelIF()
{
}

Real TylerChannelIF::value(const RealVect& a_point) const
{
  Real retval;

  Real x = a_point[0];
  Real y = a_point[1];

  Real xmid = (m_x1 + m_x2) / 2.0;
  Real ymid = m_yDomainLength / 2.0;

  Real theta = 4.0 * (x - xmid) / (m_x2 - m_x1);
  Real frac = (tanh(theta) + 1.0) / 2.0;

  Real ydist = m_y1*(1.0-frac) + m_y2*frac;

  retval = Abs(y - ymid) - ydist;

  return retval;
}

BaseIF* TylerChannelIF::newImplicitFunction() const
{
  TylerChannelIF* TylerChannelPtr = new TylerChannelIF(m_x1,
                                                       m_x2,
                                                       m_y1,
                                                       m_y2,
                                                       m_yDomainLength);

  return static_cast<BaseIF*>(TylerChannelPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "SphereIF.H"
#include "IntersectionIF.H"
#include "MultiSphereIF.H"

#include "NamespaceHeader.H"

MultiSphereIF::MultiSphereIF(const Vector<Real>&     a_radii,
                             const Vector<RealVect>& a_centers,
                             const bool&             a_inside)
{
  // Remember the number of spheres
  m_numSpheres = a_radii.size();

  // Remember the parameters
  m_radii   = a_radii;
  m_centers = a_centers;
  m_inside  = a_inside;

  // Create all the spheres
  Vector<BaseIF*> spheres(m_numSpheres);
  for (int i = 0; i < m_numSpheres; i++)
  {
    spheres[i] = new SphereIF(m_radii[i],m_centers[i],false);
  }

  // Intersect their exteriors and complement if needed
  IntersectionIF multiSphere(spheres);
  m_multiSphere = new ComplementIF(multiSphere,m_inside);

  // Delete all the spheres (they've been copied into m_multiSphere)
  for (int i = 0; i < m_numSpheres; i++)
  {
    delete spheres[i];
  }
}

MultiSphereIF::MultiSphereIF(const MultiSphereIF& a_inputIF)
{
  // Remember the parameters
  m_numSpheres = a_inputIF.m_numSpheres;
  m_radii      = a_inputIF.m_radii;
  m_centers    = a_inputIF.m_centers;
  m_inside     = a_inputIF.m_inside;

  if (a_inputIF.m_multiSphere == NULL)
  {
    m_multiSphere = NULL;
  }
  else
  {
    m_multiSphere = (ComplementIF *)a_inputIF.m_multiSphere->newImplicitFunction();
  }
}

MultiSphereIF::~MultiSphereIF()
{
  // Delete the IF object
  if (m_multiSphere != NULL)
  {
    delete m_multiSphere;
  }
}

void MultiSphereIF::GetParams(Vector<Real>&     a_radii,
                              Vector<RealVect>& a_centers,
                              bool&             a_inside) const
{
  // Copy parameter information over
  a_radii   = m_radii;
  a_centers = m_centers;
  a_inside  = m_inside;
}

void MultiSphereIF::SetParams(const Vector<Real>&     a_radii,
                              const Vector<RealVect>& a_centers,
                              const bool&             a_inside)
{
  // Delete the IF object
  if (m_multiSphere != NULL)
  {
    delete m_multiSphere;
  }

  // Set the number of spheres
  m_numSpheres = a_radii.size();

  // Set parameter information
  m_radii   = a_radii;
  m_centers = a_centers;
  m_inside  = a_inside;

  // Create all the spheres
  Vector<BaseIF*> spheres(m_numSpheres);
  for (int i = 0; i < m_numSpheres; i++)
  {
    spheres[i] = new SphereIF(m_radii[i],m_centers[i],false);
  }

  // Intersect their exteriors and complement if needed
  IntersectionIF multiSphere(spheres);
  m_multiSphere = new ComplementIF(multiSphere,m_inside);

  // Delete all the spheres (they've been copied into m_multiSphere)
  for (int i = 0; i < m_numSpheres; i++)
  {
    delete spheres[i];
  }
}

Real MultiSphereIF::value(const RealVect& a_point) const
{
  Real retval;

  retval = 0.0;

  if (m_multiSphere != NULL)
  {
    retval = m_multiSphere->value(a_point);
  }

  return retval;
}

BaseIF* MultiSphereIF::newImplicitFunction() const
{
  MultiSphereIF* spherePtr = new MultiSphereIF(m_radii,
                                               m_centers,
                                               m_inside);

  return static_cast<BaseIF*>(spherePtr);
}


GeometryService::InOut MultiSphereIF::InsideOutside(const RealVect& a_low, const RealVect& a_high) const
{
  return m_multiSphere->InsideOutside(a_low, a_high);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "PolynomialIF.H"
#include "NamespaceHeader.H"

void PolyTerm::partialDerivative(PolyTerm       & a_partial,
                                 const IntVect  & a_whichPartialOp,
                                 const PolyTerm & a_polyterm) const
{
  a_partial = a_polyterm;

  // The direction and  order of differentation is summarzized by an IntVect
  for (int idir = 0; idir < SpaceDim; ++idir)
  {
    // Differentiate in the idir direction a_whichPartialOp number of times.
    int curPartialOp = a_whichPartialOp[idir];
    for (int ipartial = curPartialOp; ipartial > 0; --ipartial)
    {
      firstOrderPartial(a_partial,idir);
    }
  }
}

void PolyTerm::firstOrderPartial(PolyTerm       & a_partial,
                                 const int      & a_whichPartialDir) const
{
  // Take one derivative in the a_whichPartialDir direction
  a_partial.coef *= a_partial.powers[a_whichPartialDir];
  if (a_partial.powers[a_whichPartialDir] > 0)
  {
    a_partial.powers[a_whichPartialDir] -= 1;
  }
}

PolynomialIF::PolynomialIF(const Vector<PolyTerm>& a_polynomial,
                           const bool&             a_inside)
{
  // Copy polynomial
  int size = a_polynomial.size();

  m_polynomial.resize(size);

  for (int iterm = 0; iterm < size; iterm++)
    {
      m_polynomial[iterm] = a_polynomial[iterm];
    }

  // Save inside flag
  m_inside = a_inside;
}

PolynomialIF::PolynomialIF(const PolynomialIF& a_inputIF)
{
  // Copy polynomial
  int size = a_inputIF.m_polynomial.size();

  m_polynomial.resize(size);

  for (int iterm = 0; iterm < size; iterm++)
    {
      m_polynomial[iterm] = a_inputIF.m_polynomial[iterm];
    }

  // Save inside flag
  m_inside = a_inputIF.m_inside;
}

PolynomialIF::~PolynomialIF()
{
}

void PolynomialIF::GetParams(Vector<PolyTerm>& a_polynomial,
                             bool&             a_inside) const
{
  // Copy polynomial
  int size = m_polynomial.size();

  a_polynomial.resize(size);

  for (int iterm = 0; iterm < size; iterm++)
    {
      a_polynomial[iterm] = m_polynomial[iterm];
    }

  // Save inside flag
  a_inside = m_inside;
}

void PolynomialIF::SetParams(const Vector<PolyTerm>& a_polynomial,
                             const bool&             a_inside)
{
  // Copy polynomial
  int size = a_polynomial.size();

  m_polynomial.resize(size);

  for (int iterm = 0; iterm < size; iterm++)
    {
      m_polynomial[iterm] = a_polynomial[iterm];
    }

  // Save inside flag
  m_inside = a_inside;
}

Real PolynomialIF::value(const RealVect         & a_point,
                         const Vector<PolyTerm> & a_polynomial) const
{
  Real retval;

  int size = a_polynomial.size();

  // Evaluate the polynomial
  retval = 0.0;
  for (int iterm = 0; iterm < size; iterm++)
    {
      Real cur;

      cur = a_polynomial[iterm].coef;
      for (int idir = 0; idir < SpaceDim; idir++)
        {
          cur *= pow(a_point[idir],a_polynomial[iterm].powers[idir]);
        }

      retval += cur;
    }

  // Change the sign to change inside to outside
  if (!m_inside)
    {
      retval = -retval;
    }

  return retval;
}

Real PolynomialIF::value(const RealVect& a_point) const
{
  return value(a_point,m_polynomial);
}

Real PolynomialIF::value(const IndexTM<int,GLOBALDIM>  & a_partialDerivativeOp,
                         const IndexTM<Real,GLOBALDIM> & a_point) const
{
#ifdef CH_REALM
  // 0.0 is correct if a_partialDerivativeOp[GLOBALDIM] != 0
  Real retval = 0.0;

  Vector<PolyTerm> derivedPoly(m_polynomial);
  RealVect point;
  IntVect partialDerivativeOp;

  if (a_partialDerivativeOp[GLOBALDIM - 1] == 0)
    {
      for (int idir = 0; idir < SpaceDim; ++idir)
        {
          // Project on the SpaceDim dimensions, preliminary to calling the
          // generic value function. The reference surface polynomial has no z-terms.
          point[idir] = a_point[idir];

          // Project on the SpaceDim dimensions preliminary to calling the
          // generic partial derivative function.
          partialDerivativeOp[idir] = a_partialDerivativeOp[idir];
        }

      // Calculate the derivative of the polynomial
      partialDerivative(derivedPoly,partialDerivativeOp,m_polynomial);

      // Evaluate the derivative at the point in space
      retval = value(point,derivedPoly);
    }

  return retval;
#else
  MayDay::Abort("This function uses GLOBALDIM, which doesn't make sense outside of realm");

  return 0.0;
#endif
}

void PolynomialIF::partialDerivative(Vector<PolyTerm>       & a_partial,
                                     const IntVect          & a_whichPartialOp,
                                     const Vector<PolyTerm> & a_polynomial)const
{
  //The direction and order of differentiation is summarized by an IntVect
  int size = m_polynomial.size();

  for (int iterm = 0; iterm < size; iterm++)
    {
      a_partial[iterm].partialDerivative(a_partial[iterm],a_whichPartialOp,a_polynomial[iterm]);
    }
}

BaseIF* PolynomialIF::newImplicitFunction() const
{
  PolynomialIF* polynomialPtr = new PolynomialIF(m_polynomial,
                                                 m_inside);

  return static_cast<BaseIF*>(polynomialPtr);
}



#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <string>

#include "MayDay.H"

#include "CutCellMoments.H"

#include "NamespaceHeader.H"

// Null constructor
CutCellMoments<1>::CutCellMoments()
{
}

// Copy constructor
CutCellMoments<1>::CutCellMoments(const CutCellMoments<1>& a_thisCutCellMoments)

  :m_moments(a_thisCutCellMoments.m_moments),
   m_IFData(a_thisCutCellMoments.m_IFData),
   m_numActiveBounds(0)
{
}

// This constructor is used in the recursion
CutCellMoments<1>::CutCellMoments(const IFData<1> & a_info)
  :m_IFData(a_info),
   m_numActiveBounds(0)
{
  m_badNormal = false;
}

// Destructor
CutCellMoments<1>::~CutCellMoments()
{
}

Real CutCellMoments<1>::changeMomentCoordinates(OneDMoments           & a_refinedMomentMap,
                                                const IndexTM<int,1>  & a_monomial,
                                                const IndexTM<Real,1> & a_refinedCenterDelta)
{
  Real moment = 0.0;
  int degree = 0;
  degree += a_monomial[0];

  // Loop over the possible values of r in the development of the Taylor series
  for (int r = 0; r <= degree; r++)
  {
    // Generate all the possible monomials of degree r and add up the moment
    IndexTM<int,1> derivative;
    derivative[0] = r;

    // Add up the relevant term of the refined moment map to the map
    Real coeff = 1.0;
    Real factorial = 1.0;

    for (int j = 0; j < derivative[0]; j++)
    {
      coeff *= a_monomial[0] - j;
      factorial *= j+1;
    }

    coeff *= pow(a_refinedCenterDelta[0],a_monomial[0]-derivative[0]);

    moment += coeff * a_refinedMomentMap[derivative] / factorial;
  }

  return moment;
}

void CutCellMoments<1>::changeMomentCoordinatesToCellCenter()
{
  // Move moments from parent coord to cell center coord
  IndexTM<Real,1> delta = m_IFData.m_cellCenterCoord.m_origin;
  delta                -= m_IFData.m_parentCoord    .m_origin;

  OneDMoments copyMoments = m_moments;
  for (OneDMoments::const_iterator it = copyMoments.begin();
       it != copyMoments.end(); ++it)
    {
      IndexTM<int,1> mono = it->first;
      m_moments[mono] = changeMomentCoordinates(copyMoments, mono, delta);
    }
}

void CutCellMoments<1>::changeMomentCoordinatesToParentCenter()
{
  // Move moments from cell center coord to parent coord
  IndexTM<Real,1> delta = m_IFData.m_parentCoord    .m_origin;
  delta                -= m_IFData.m_cellCenterCoord.m_origin;

  OneDMoments copyMoments = m_moments;
  for (OneDMoments::const_iterator it = copyMoments.begin();
       it != copyMoments.end(); ++it)
    {
      IndexTM<int,1> mono = it->first;
      m_moments[mono] = changeMomentCoordinates(copyMoments, mono, delta);
    }
}

void CutCellMoments<1>::initialize(CutCellMoments<1> & a_refinedCutCell)
{
  initializeMap(m_EBmoments,a_refinedCutCell.m_EBmoments);
  initializeMap(m_moments,a_refinedCutCell.m_moments);
}

void CutCellMoments<1>::initializeMap(OneDMoments & a_map1,
                                      OneDMoments & a_map2)
{
  for (OneDMoments::const_iterator it = a_map2.begin(); it != a_map2.end(); ++it)
  {
    a_map1[it->first] = 0.0;
  }
}

Real CutCellMoments<1>::getBdMoment(const IndexTM<int,1>  & a_mono,
                                    const IFData<2>       & a_IFData,
                                    const IndexTM<Real,1> & a_refinedCenterDelta,
                                    OneDMoments             a_fullCellMap)
{
  Real moment = LARGEREALVAL;

  if (a_IFData.m_allVerticesOut)
  {
    moment = 0.0;
  }
  else if (a_IFData.m_allVerticesIn)
  {
    Real loPt = -0.5*m_IFData.m_globalCoord.m_dx[0];
    Real hiPt =  0.5*m_IFData.m_globalCoord.m_dx[0];

    moment = pow(hiPt,a_mono[0] + 1) - pow(loPt,a_mono[0] +1);
    moment = changeMomentCoordinates(a_fullCellMap,a_mono,a_refinedCenterDelta);
  }
  else
  {
    moment = changeMomentCoordinates(m_moments,a_mono,a_refinedCenterDelta);
  }

  return moment;
}

Real CutCellMoments<1>::getBdEBMoment(const IndexTM<int,1>  & a_mono,
                                      const IFData<2>       & a_IFData,
                                      const IndexTM<Real,1> & a_refinedCenterDelta)
{
  Real EBmoment = 0.0;

  return EBmoment;
}

void CutCellMoments<1>::addBdMoments(CutCellMoments<1>     & a_coarseBdCutCell,
                                     const IFData<2>       & a_IFData,
#if RECURSIVE_GEOMETRY_GENERATION == 0
                                     const int             & a_degreeP,
#else
                                     const int             & a_degreePmax,
#endif
                                     const bool            & a_useConstraints,
                                     const IndexTM<Real,1> & a_refinedCenterDelta,
                                     const IndexTM<int,1>  & a_localHilo)
{
  OneDMoments fullCellMap;

  if (a_IFData.m_allVerticesIn)
  {
    IndexTM<int,1> degree;

#if RECURSIVE_GEOMETRY_GENERATION == 0
    for (int iDegree = 0; iDegree <= a_degreeP; ++iDegree)
#else
    for (int iDegree = 0; iDegree <= a_degreePmax; ++iDegree)
#endif
    {
      degree[0] = iDegree;
      Real loPt = -0.5*m_IFData.m_globalCoord.m_dx[0];
      Real hiPt =  0.5*m_IFData.m_globalCoord.m_dx[0];
      fullCellMap[degree] = pow(hiPt,degree[0] + 1) - pow(loPt,degree[0] +1);
      fullCellMap[degree] /= degree[0]+1;
    }
  }

#if RECURSIVE_GEOMETRY_GENERATION == 0
  for (int iDegree = 0; iDegree <= a_degreeP; ++iDegree)
#else
  for (int iDegree = 0; iDegree <= a_degreePmax; ++iDegree)
#endif
  {
    IndexTM<int,1>degree;
    degree[0] = iDegree;
    Real bdMoment;
    if (a_IFData.m_allVerticesIn)
    {
      bdMoment = getBdMoment(degree,a_IFData,a_refinedCenterDelta,fullCellMap);
    }
    else
    {
      bdMoment = getBdMoment(degree,a_IFData,a_refinedCenterDelta);
    }

    a_coarseBdCutCell.m_moments[degree] += bdMoment;
  }
}

Real CutCellMoments<1>::getMoment(const IndexTM<int,1> & a_mono,
                                  const EBorVol        & a_EBorVOL) const
{
  return getMoment(a_mono);
}

// Method for reading moments
Real CutCellMoments<1>::getMoment(const IndexTM<int,1> & a_mono) const
{
  Real moment = LARGEREALVAL;

  // Find the vol in the map
  OneDMoments::const_iterator it = m_moments.find(a_mono);

  if (it != m_moments.end())
  {
    moment = it->second;
  }
  else
  {
    MayDay::Abort("No volume moment in m_moments");
  }

  return moment;
}

// Read geometric data and sanity check
Real CutCellMoments<1>::getVol(const EBorVol & a_EBorVol) const
{
  IndexTM<int,1> zero;
  zero[0] = 0;
  Real volume = getMoment(zero);

  return volume;
}

IndexTM<Real,1> CutCellMoments<1>::getCentroid(const EBorVol& a_EBorVol) const
{
  IndexTM<Real,1> centroid;
  IndexTM<int,1> first;
  first[0] = 1;

  Real volume = getVol(a_EBorVol);

  if (volume <= 0)
  {
    MayDay::Abort("Volume <= 0");
  }
  else
  {
    centroid[0] = getMoment(first)/volume;
  }

  return centroid;
}

bool CutCellMoments<1>::isCovered() const
{
  return m_IFData.m_allVerticesOut;
}

bool CutCellMoments<1>::isRegular() const
{
  return m_IFData.m_allVerticesIn;
}

void CutCellMoments<1>::print(ostream & a_out) const
{
  string padding = "  ";
  for (int i = 0; i < GLOBALDIM - 1; i++)
  {
    padding += "  ";
  }

  a_out << padding << "Dim = 1" << "\n";
  a_out << padding << "\n";

  for (OneDMoments::const_iterator it = m_moments.begin(); it != m_moments.end();++it)
  {
    std::ios::fmtflags origFlags = a_out.flags();
    int origWidth = a_out.width();
    int origPrecision = a_out.precision();

    a_out << padding << "Integral "
                     << it->first
                     << " = "
                     << setw(23)
                     << setprecision(16)
                     << setiosflags(ios::showpoint)
                     << setiosflags(ios::scientific)
                     << it->second
                     << "\n";

    a_out.flags(origFlags);
    a_out.width(origWidth);
    a_out.precision(origPrecision);
  }
  a_out << padding << "\n";

  a_out << padding << "IFData:" << "\n";
  a_out << m_IFData;
}

void CutCellMoments<1>::operator=(const CutCellMoments<1> & a_cutCellMoments)
{
  // Only copy if the two objects are distinct
  if (this != &a_cutCellMoments)
  {
    m_IFData  = a_cutCellMoments.m_IFData;
    m_moments = a_cutCellMoments.m_moments;
  }
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "PolyGeom.H"
#include "TransformIF.H"

#include "NamespaceHeader.H"


TransformIF::TransformIF(const BaseIF& a_impFunc)
{
  m_impFunc = a_impFunc.newImplicitFunction();

  matrixIdentity(m_transform);
  matrixIdentity(m_invTransform);
}

TransformIF::TransformIF(const BaseIF& a_impFunc,
                         const Real    a_transform[SpaceDim+1][SpaceDim+1],
                         const Real    a_invTransform[SpaceDim+1][SpaceDim+1])
{
  m_impFunc = a_impFunc.newImplicitFunction();

  // Copy the matrices over
  for (int i = 0; i <= SpaceDim; i++)
  {
    for (int j = 0; j <= SpaceDim; j++)
    {
      m_transform   [i][j] = a_transform   [i][j];
      m_invTransform[i][j] = a_invTransform[i][j];
    }
  }
}

TransformIF::TransformIF(const TransformIF& a_inputIF)
{
  m_impFunc = a_inputIF.m_impFunc->newImplicitFunction();

  // Copy the matrices over
  for (int i = 0; i <= SpaceDim; i++)
  {
    for (int j = 0; j <= SpaceDim; j++)
    {
      m_transform   [i][j] = a_inputIF.m_transform   [i][j];
      m_invTransform[i][j] = a_inputIF.m_invTransform[i][j];
    }
  }
}

TransformIF::~TransformIF()
{
  delete m_impFunc;
}

void TransformIF::translate(const RealVect& a_trans)
{
  // Temporary transformation matrix
  Real temp[SpaceDim+1][SpaceDim+1];

  // Translation
  RealVect trans = a_trans;

  // Create the forward transformation matrix
  matrixTranslate(temp,trans);

  // Update the overall forward transform
  matrixMultiply(m_transform,temp,m_transform);

  // Inverse translation
  trans = RealVect::Zero;
  trans -= a_trans;

  // Create the inverse transformation matrix
  matrixTranslate(temp,trans);

  // Update the overall inverse transform
  matrixMultiply(m_invTransform,m_invTransform,temp);
}

void TransformIF::scale(const Real& a_scale)
{
  // Temporary transformation matrix
  Real temp[SpaceDim+1][SpaceDim+1];

  // Set up a scaling vector
  RealVect scale(D_DECL(a_scale,a_scale,a_scale));

  // Create the forward transformation matrix
  matrixScale(temp,scale);

  // Update the overall forward transform
  matrixMultiply(m_transform,temp,m_transform);

  // Set up an inverse scaling vector
  RealVect invScale(D_DECL(1.0/a_scale,1.0/a_scale,1.0/a_scale));

  // Create the inverse transformation matrix
  matrixScale(temp,invScale);

  // Update the overall inverse transform
  matrixMultiply(m_invTransform,m_invTransform,temp);
}

void TransformIF::scale(const RealVect& a_scale)
{
  // Temporary transformation matrix
  Real temp[SpaceDim+1][SpaceDim+1];

  // Set up a scaling vector
  RealVect scale = a_scale;

  // Create the forward transformation matrix
  matrixScale(temp,scale);

  // Update the overall forward transform
  matrixMultiply(m_transform,temp,m_transform);

  // Inverse scaling
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    scale[idir] = 1.0 / scale[idir];
  }

  // Create the inverse transformation matrix
  matrixScale(temp,scale);

  // Update the overall inverse transform
  matrixMultiply(m_invTransform,m_invTransform,temp);
}

void TransformIF::rotate(const Real&     a_angle,
                         const RealVect& a_point,
                         const RealVect& a_axis)
{
  // Temporary transformation matrix
  Real temp[SpaceDim+1][SpaceDim+1];

  // Transformation matrix for forward transformation
  Real forTrans[SpaceDim+1][SpaceDim+1];

  // Transformation matrix for inverse transformation
  Real invTrans[SpaceDim+1][SpaceDim+1];

  // Start by translating a_point to the origin
  RealVect invTranslate = RealVect::Zero;
  invTranslate -= a_point;

  // Update the forward and inverse transformations
  matrixTranslate(forTrans,invTranslate);
  matrixTranslate(invTrans,invTranslate);

#if CH_SPACEDIM == 3
  // Rotate everything so a_axis aligns with the z-axis
  Real theta = 0.0;
  Real sinTheta = 0.0;
  Real cosTheta = 1.0;

  Real phi = 0.0;
  Real sinPhi = 0.0;
  Real cosPhi = 1.0;

  if (a_axis[0] != 0)
  {
    // Rotate about the z-axis to make the x component of a_axis zero
    theta = atan2(a_axis[0],a_axis[1]);
    sinTheta = sin(theta);
    cosTheta = cos(theta);

    // Set up the rotation matrix
    matrixIdentity(temp);

    temp[0][0] =  cosTheta;
    temp[0][1] = -sinTheta;
    temp[1][0] =  sinTheta;
    temp[1][1] =  cosTheta;

    // Update the forward and inverse transformations
    matrixMultiply(forTrans,temp,forTrans);
    matrixMultiply(invTrans,temp,invTrans);
  }

  Real newY = sinTheta*a_axis[0] + cosTheta*a_axis[1];
  Real newZ = a_axis[2];

  // Rotate about the x-axis to make the y component of a_axis zero
  phi = atan2(newY,newZ);
  sinPhi = sin(phi);
  cosPhi = cos(phi);

  // Set up the rotation matrix
  matrixIdentity(temp);

  temp[1][1] =  cosPhi;
  temp[1][2] = -sinPhi;
  temp[2][1] =  sinPhi;
  temp[2][2] =  cosPhi;

  // Update the forward and inverse transformations
  matrixMultiply(forTrans,temp,forTrans);
  matrixMultiply(invTrans,temp,invTrans);
#endif

  // Now do a rotation in the xy plane(s)
  matrixIdentity(temp);

  temp[0][0] =  cos(a_angle);
  temp[0][1] = -sin(a_angle);
  temp[1][0] =  sin(a_angle);
  temp[1][1] =  cos(a_angle);

  // Update the forward transformation
  matrixMultiply(forTrans,temp,forTrans);

  // Now do a negative rotation in the xy plane(s)
  matrixIdentity(temp);

  temp[0][0] =  cos(-a_angle);
  temp[0][1] = -sin(-a_angle);
  temp[1][0] =  sin(-a_angle);
  temp[1][1] =  cos(-a_angle);

  // Update the inverse transformation
  matrixMultiply(invTrans,temp,invTrans);

#if CH_SPACEDIM == 3
  // Set up the rotation matrix
  matrixIdentity(temp);

  temp[1][1] =  cosPhi;
  temp[1][2] =  sinPhi;
  temp[2][1] = -sinPhi;
  temp[2][2] =  cosPhi;

  // Update the forward and inverse transformations
  matrixMultiply(forTrans,temp,forTrans);
  matrixMultiply(invTrans,temp,invTrans);

  if (a_axis[0] != 0)
  {
    // Set up the rotation matrix
    matrixIdentity(temp);

    temp[0][0] =  cosTheta;
    temp[0][1] =  sinTheta;
    temp[1][0] = -sinTheta;
    temp[1][1] =  cosTheta;

    // Update the forward and inverse transformations
    matrixMultiply(forTrans,temp,forTrans);
    matrixMultiply(invTrans,temp,invTrans);
  }
#endif

  // Now translate the origin back to a_point
  matrixTranslate(temp,a_point);

  // Update the forward and inverse transformations
  matrixMultiply(forTrans,temp,forTrans);
  matrixMultiply(invTrans,temp,invTrans);

  // Update the overall forward transform
  matrixMultiply(m_transform,forTrans,m_transform);

  // Update the overall inverse transform
  matrixMultiply(m_invTransform,m_invTransform,invTrans);
}

void TransformIF::rotate(const RealVect& a_axis1,
                         const RealVect& a_axis2,
                         const RealVect& a_point)
{
  RealVect axis3 = PolyGeom::cross(a_axis1,a_axis2);
  // Cross product seems to be backwards
  axis3 *= -1.0;

  Real axis1Length = sqrt(PolyGeom::dot(a_axis1,a_axis1));
  Real axis2Length = sqrt(PolyGeom::dot(a_axis2,a_axis2));
  Real axis3Length = sqrt(PolyGeom::dot(axis3,axis3));

  Real angle = acos(PolyGeom::dot(a_axis1,a_axis2)/(axis1Length*axis2Length));

#if CH_SPACEDIM == 2
  if (axis3[0] < 0.0)
  {
    angle *= -1.0;
  }
#endif

  if (axis3Length != 0.0)
  {
    rotate(angle,a_point,axis3);
  }
}

Real TransformIF::value(const RealVect& a_point) const
{
  // Function value at the inverse transform of a_point
  Real retval;

  // The inverse transform of a_point
  RealVect invPoint;

  // Inverse transform a_point to invPoint
  vectorMultiply(invPoint,m_invTransform,a_point);

  // Get the function value at invPoint
  retval = m_impFunc->value(invPoint);

  return retval;
}

Real TransformIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{
  RealVect point;
  for (int idir = 0 ; idir < GLOBALDIM ; idir++)
    {
      point[idir] = a_point[idir];
    }

  return value(point);
}

BaseIF* TransformIF::newImplicitFunction() const
{
  TransformIF* transformPtr = new TransformIF(*m_impFunc,
                                              m_transform,
                                              m_invTransform);

  return static_cast<BaseIF*>(transformPtr);
}

bool TransformIF::fastIntersection(const RealVect& a_lo,
                                   const RealVect& a_hi) const
{
//   return m_impFunc->fastIntersection(a_lo,a_hi);
  return false;
}

GeometryService::InOut TransformIF::InsideOutside(const RealVect& a_lo,
                                                  const RealVect& a_hi) const
{
  // The size of the incoming bounding box
  RealVect len;
  len = a_hi - a_lo;

  // The bounding box corners in the pre-transform space
  RealVect newLo,newHi;

  // Get the lowest corner
  RealVect corner = a_lo;

  // The inverse transform of corner
  RealVect invCorner;

  // Inverse transform corner to invCorner
  vectorMultiply(invCorner,m_invTransform,corner);

  // Initialize the new corners
  newLo = invCorner;
  newHi = invCorner;

  // Build a unit box for iteration
  Box unit(IntVect::Zero, IntVect::Unit);

  // Iterate over all corners
  for (BoxIterator b(unit); b.ok(); ++b)
  {
    // Get the current corner
    corner = a_lo + RealVect(b())*len;

    // Inverse transform corner to invCorner
    vectorMultiply(invCorner,m_invTransform,corner);

    // Build the bounding box in the pre-transform space
    newLo.min(invCorner);
    newHi.max(invCorner);
  }

  // Report "InOut" using the pre-transform bounding box and the original
  // implicit function
  return m_impFunc->InsideOutside(newLo,newHi);
}

void TransformIF::vectorMultiply(IndexTM<Real,GLOBALDIM>& m_outPoint,
                                 const Real m_intrans[SpaceDim+1][SpaceDim+1],
                                 const IndexTM<Real,GLOBALDIM>& m_inPoint) const
{
  RealVect a_outPoint;
  RealVect a_inPoint;
  for (int idir = 0 ; idir < GLOBALDIM ; idir++)
    {
      a_outPoint[idir] = m_outPoint[idir];
      a_inPoint[idir] = m_inPoint[idir];
    }
  vectorMultiply(a_outPoint,m_intrans,a_inPoint);
  for (int idir = 0 ; idir < GLOBALDIM ; idir++)
    {
      m_outPoint[idir] = a_outPoint[idir];
    }
}

void TransformIF::vectorMultiply(RealVect&       m_outPoint,
                                 const Real      m_inTrans[SpaceDim+1][SpaceDim+1],
                                 const RealVect& m_inPoint) const
{
  // Temporary for input and output vector (in homogeneous coordinates)
  Real in[SpaceDim+1];
  Real out[SpaceDim+1];

  // Multiply the two inputs into the temporary matrix
  for (int i = 0; i < SpaceDim; i++)
  {
    in[i] = m_inPoint[i];
  }
  in[SpaceDim] = 1.0;

  // Multiply the vector by the matrix to get a vector
  for (int i = 0; i <= SpaceDim; i++)
  {
    Real total = 0.0;

    for (int k = 0; k <= SpaceDim; k++)
    {
      total += m_inTrans[i][k] * in[k];
    }

    out[i] = total;
  }

  Real scaling = 1.0 / out[SpaceDim];

  // Convert the transformed vector in homogeneous coordinates to a RaalVect
  for (int i = 0; i < SpaceDim; i++)
  {
      m_outPoint[i] = scaling * out[i];
  }
}

void TransformIF::matrixIdentity(Real m_trans[SpaceDim+1][SpaceDim+1]) const
{
  // Set up the identify
  for (int i = 0; i <= SpaceDim; i++)
  {
    for (int j = 0; j <= SpaceDim; j++)
    {
      m_trans[i][j] = 0.0;
    }

    m_trans[i][i] = 1.0;
  }
}

void TransformIF::matrixMultiply(Real       m_outTrans[SpaceDim+1][SpaceDim+1],
                                 const Real m_inTrans1[SpaceDim+1][SpaceDim+1],
                                 const Real m_inTrans2[SpaceDim+1][SpaceDim+1]) const
{
  // Temporary transformation matrix
  Real temp[SpaceDim+1][SpaceDim+1];

  // Multiply the two inputs into the temporary matrix
  for (int i = 0; i <= SpaceDim; i++)
  {
    for (int j = 0; j <= SpaceDim; j++)
    {
      Real total = 0.0;

      for (int k = 0; k <= SpaceDim; k++)
      {
        total += m_inTrans1[i][k] * m_inTrans2[k][j];
      }

      temp[i][j] = total;
    }
  }

  // Copy the temporary matrix into the returned matrix
  for (int i = 0; i <= SpaceDim; i++)
  {
    for (int j = 0; j <= SpaceDim; j++)
    {
      m_outTrans[i][j] = temp[i][j];
    }
  }
}

void TransformIF::matrixTranslate(Real            a_trans[SpaceDim+1][SpaceDim+1],
                                  const RealVect& a_translate) const
{
  // Start with the identity
  matrixIdentity(a_trans);

  // Set appropriate entries
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    a_trans[idir][SpaceDim] = a_translate[idir];
  }
}

void TransformIF::matrixScale(Real            a_trans[SpaceDim+1][SpaceDim+1],
                              const RealVect& a_scale) const
{
  // Start with the identity
  matrixIdentity(a_trans);

  // Set appropriate entries
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    a_trans[idir][idir] = a_scale[idir];
  }
}
#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "UnionIF.H"

#include "NamespaceHeader.H"

UnionIF::UnionIF(const BaseIF& a_impFunc1,
                 const BaseIF& a_impFunc2)
{
  // Number of implicit function in union
  m_numFuncs = 2;

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  // Make copies of the implicit functions
  m_impFuncs[0] = a_impFunc1.newImplicitFunction();
  m_impFuncs[1] = a_impFunc2.newImplicitFunction();
}

UnionIF::UnionIF(const Vector<BaseIF *>& a_impFuncs)
{
  // Number of implicit function in union
  m_numFuncs = a_impFuncs.size();

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  // Make copies of the implicit functions
  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (a_impFuncs[ifunc] == NULL)
    {
      m_impFuncs[ifunc] = NULL;
    }
    else
    {
      m_impFuncs[ifunc] = a_impFuncs[ifunc]->newImplicitFunction();
    }
  }
}

UnionIF::UnionIF(const UnionIF& a_inputIF)
{
  // Number of implicit function in union
  m_numFuncs = a_inputIF.m_impFuncs.size();

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  // Make copies of the implicit functions
  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (a_inputIF.m_impFuncs[ifunc] == NULL)
    {
      m_impFuncs[ifunc] = NULL;
    }
    else
    {
      m_impFuncs[ifunc] = a_inputIF.m_impFuncs[ifunc]->newImplicitFunction();
    }
  }
}

UnionIF::~UnionIF()
{
  // Delete all the copies
  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (m_impFuncs[ifunc] != NULL)
    {
      delete m_impFuncs[ifunc];
    }
  }
}

Real UnionIF::value(const RealVect& a_point) const
{
  // Minimum of the implicit functions values
  Real retval;

  retval = 1.0;

  // Find the minimum value and return it
  if (m_numFuncs > 0)
  {
    retval = m_impFuncs[0]->value(a_point);

    for (int ifunc = 1; ifunc < m_numFuncs; ifunc++)
    {
      Real cur;

      cur = m_impFuncs[ifunc]->value(a_point);
      if (cur < retval)
      {
        retval = cur;
      }
    }
  }

  return retval;
}

Real UnionIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{
  int closestIF = -1;
  findClosest(a_point,closestIF);

  if (closestIF == -1)
  {
    return 1.0;
  }
  else
  {
    return m_impFuncs[closestIF]->value(a_point);
  }
}

Real UnionIF::value(const IndexTM<int,GLOBALDIM> & a_partialDerivative,
                    const IndexTM<Real,GLOBALDIM>& a_point) const
{
  int closestIF = -1;
  findClosest(a_point,closestIF);

  if (closestIF == -1)
  {
    if (a_partialDerivative.sum() == 0)
    {
      return 1.0;
    }
    else
    {
      return 0.0;
    }
  }
  else
  {
    return m_impFuncs[closestIF]->value(a_partialDerivative,a_point);
  }
}

void UnionIF::findClosest(const IndexTM<Real,GLOBALDIM> & a_point,
                          int                           & a_closestIF) const
{
  Real retval = 0.0;

  if (m_numFuncs > 0)
    {
      retval = m_impFuncs[0]->value(a_point);
      a_closestIF = 0;

      for (int ifunc = 1; ifunc < m_numFuncs; ifunc++)
        {
          Real cur;
          cur = m_impFuncs[ifunc]->value(a_point);
          if (cur < retval)
            {
              retval = cur;
              a_closestIF = ifunc;
            }
        }
    }
}

BaseIF* UnionIF::newImplicitFunction() const
{
  UnionIF* unionPtr = new UnionIF(m_impFuncs);

  return static_cast<BaseIF*>(unionPtr);
}

bool UnionIF::fastIntersection(const RealVect& a_low,
                               const RealVect& a_high) const
{
  for (int i=0; i<m_impFuncs.size(); i++)
    {
      if (!m_impFuncs[i]->fastIntersection(a_low, a_high)) return false;
    }
  return true;
}

GeometryService::InOut UnionIF::InsideOutside(const RealVect& a_low,
                                              const RealVect& a_high) const
{
  CH_assert(fastIntersection(a_low, a_high));

  bool allCovered = true;
  for (int i = 0; i<m_numFuncs; ++i)
    {
      GeometryService::InOut r =  m_impFuncs[i]->InsideOutside(a_low, a_high);
      if (r == GeometryService::Regular) return r;
      if (r == GeometryService::Irregular) allCovered = false;
    }
  if (allCovered) return GeometryService::Covered;
  return GeometryService::Irregular;
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "SphereIF.H"

#include "NamespaceHeader.H"

SphereIF::SphereIF(const Real&     a_radius,
                   const RealVect& a_center,
                   const bool&     a_inside)
{
  // Remember the parameters
  m_radius = a_radius;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the radius squared
  m_radius2 = m_radius * m_radius;
}

SphereIF::SphereIF(const SphereIF& a_inputIF)
{
  // Remember the parameters
  m_radius  = a_inputIF.m_radius;
  m_center  = a_inputIF.m_center;
  m_inside  = a_inputIF.m_inside;

  m_radius2 = a_inputIF.m_radius2;
}

SphereIF::~SphereIF()
{
}

GeometryService::InOut SphereIF::InsideOutside(const RealVect& lo,
                                               const RealVect& hi) const
{

  // Fast Sphere-Box intersection from "Graphics Gems" pp 335-338, 1990

  Real dmin = 0; //distance from sphere center to nearest  point in box (squared)
  Real dmax = 0; //distance from sphere center to farthest point in box (squared)
  Real ai, bi, a, b;
  for (int i=0; i<CH_SPACEDIM; ++i)
    {
      ai = m_center[i] - lo[i];
      bi = m_center[i] - hi[i];
      a = ai * ai;
      b = bi * bi;
      dmax = dmax + Max(a,b);
      if (m_center[i] < lo[i] || m_center[i] > hi[i]) dmin = dmin + Min(a,b);
    }

  if (m_inside)
    {
      if (dmin >= m_radius2) return GeometryService::Covered;
      if (dmax <  m_radius2) return GeometryService::Regular;
    }
  else
    {
      if (dmin >  m_radius2) return GeometryService::Regular;
      if (dmax <= m_radius2) return GeometryService::Covered;
    }
  return GeometryService::Irregular;
}


void SphereIF::GetParams(Real&     a_radius,
                         RealVect& a_center,
                         bool&     a_inside) const
{
  // Copy parameter information over
  a_radius = m_radius;
  a_center = m_center;
  a_inside = m_inside;
}

void SphereIF::SetParams(const Real&     a_radius,
                         const RealVect& a_center,
                         const bool&     a_inside)
{
  // Set parameter information
  m_radius = a_radius;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the radius squared
  m_radius2 = m_radius * m_radius;
}

Real SphereIF::value(const RealVect& a_point) const
{
  Real retval;

  // The distance squared for m_center to a_point
  Real distance2;

  // Compute the distance squared
  distance2 = 0.0;
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    Real cur;
    cur = a_point[idir] - m_center[idir];

    distance2 += cur*cur;
  }

  // Return the difference between the sqaures (zero on the sphere)
  retval = distance2 - m_radius2;

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

BaseIF* SphereIF::newImplicitFunction() const
{
  SphereIF* spherePtr = new SphereIF(m_radius,
                                     m_center,
                                     m_inside);

  return static_cast<BaseIF*>(spherePtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include <fstream>
using std::ifstream;

#include "DEMIF.H"

#include "NamespaceHeader.H"

DEMIF::DEMIF(const IntVect&     a_ncell,
             const int&         a_interpType,
             const RealVect&    a_dx,
             const std::string& a_demFile,
             const Real&        a_bottomBuffer,
             const Real&        a_truncElev,
             const Real&        a_highGround,
             const Real&        a_verticalScale)
{
  m_ncell         = a_ncell;
  m_dx            = a_dx;
  m_interpType    = a_interpType;
  CH_assert(m_interpType!=2);//quadratic not supported anymore
  if (m_interpType==1)
    {
      m_doCubic = false;
    }
  else
    {
      m_doCubic = true;
    }

  m_bottomBuffer  = a_bottomBuffer;
  m_truncElev     = a_truncElev;
  m_highGround    = a_highGround;
  m_verticalScale = a_verticalScale;

  // Read in the header info
  bool justhead = true;
  readDEM(justhead,
          a_demFile);

  //allocate memory for DEM matrix
  m_DEM = new Real *[m_ncols];
  for (int i = 0; i < m_ncols;i++)
    {
      m_DEM[i] = new Real[m_nrows];
    }

  // Read in the whole file
  justhead = false;
  readDEM(justhead,
          a_demFile);

  //cache constants based on m_cellsize
  cacheConstants();

  //fill in stray "wet" cells, change nodata value to land
  // and convert DEM to meters.
  fixDEM();
}

bool DEMIF::cacheConstants()
{
  m_hx     = m_cellsize;
  m_hy     = m_cellsize;
  m_hx2    = pow(m_cellsize,2);
  m_hx3    = pow(m_cellsize,3);
  m_hy2    = pow(m_cellsize,2);
  m_hy3    = pow(m_cellsize,3);
  bool done = true;
  return done;
}

DEMIF::DEMIF(const DEMIF& a_inputIF)
{
  m_ncols         = a_inputIF.m_ncols;
  m_nrows         = a_inputIF.m_nrows;
  m_NODATA        = a_inputIF.m_NODATA;
  m_xllcorner     = a_inputIF.m_xllcorner;
  m_yllcorner     = a_inputIF.m_yllcorner;
  m_cellsize      = a_inputIF.m_cellsize;
  m_cellvalue     = a_inputIF.m_cellvalue;
  m_dx            = a_inputIF.m_dx;
  m_ncell         = a_inputIF.m_ncell;
  m_interpType    = a_inputIF.m_interpType;
  m_highGround    = a_inputIF.m_highGround;
  m_minDEM        = a_inputIF.m_minDEM;
  m_maxDEM        = a_inputIF.m_maxDEM;
  m_bottomBuffer  = a_inputIF.m_bottomBuffer;
  m_truncElev     = a_inputIF.m_truncElev;
  m_verticalScale = a_inputIF.m_verticalScale;

  if (m_interpType==1)
    {
      m_doCubic = false;
    }
  else
    {
      m_doCubic = true;
    }

  //allocate and copy memory for DEM matrix
  m_DEM = new Real *[m_ncols];

  for (int i = 0; i < m_ncols;i++)
    {
      m_DEM[i] = new Real[m_nrows];
      for (int j = 0; j < m_nrows;j++)
        {
          m_DEM[i][j] = a_inputIF.m_DEM[i][j];
        }
    }

  //cache constants based on m_cellsize
  cacheConstants();
}

DEMIF::~DEMIF()
{
  for (int i = 0; i < m_ncols;i++)
    {
      delete [] m_DEM[i];
    }
  delete [] m_DEM;
}

//Reads in a Digital Elevation Model file
bool DEMIF::readDEM(const bool&        a_justhead,
                    const std::string& a_demFile)
{
  bool fileread;
  //pout()<<"Reading DEM Header...\n";
  ifstream DEM_file;
  DEM_file.open(a_demFile.c_str()); //the input file
  if (DEM_file.bad())
    {
      MayDay::Abort("Bad DEM_file in readDEM");
    }
  char astring[1024];
  m_ncols = -99;

  DEM_file>>astring;
  DEM_file>>m_ncols;

  DEM_file>>astring;
  DEM_file>>m_nrows;

  DEM_file>>astring;
  DEM_file>>m_xllcorner;

  DEM_file>>astring;
  DEM_file>>m_yllcorner;

  DEM_file>>astring;
  DEM_file>>m_cellsize;

  DEM_file>>astring;
  DEM_file>>m_cellvalue;

  DEM_file>>astring;
  DEM_file>>m_NODATA;

  if (SpaceDim==2)
    {
      if (m_nrows!=1)
        {//2D column data...switch m_nrows and m_ncols
          int temp = m_nrows;
          m_nrows = m_ncols;
          m_ncols = temp;
        }
      else if (m_ncols==1)
        {
          MayDay::Abort("DEMIF::ncols and nrows are 1...need a bigger dataset");
        }
      CH_assert(m_nrows==1);
    }
  else if (SpaceDim==3 && m_nrows==1)
    {
      MayDay::Abort("DEMIF::nrows must not equal 1 for 3D");
    }

  //make sure the grid is big enough
  if (m_ncols==-99)
    {
      MayDay::Abort("DEMIF::Something wrong with DEM file");
    }

  if (!a_justhead)
    {
      m_minDEM =  1e20;
      m_maxDEM = -1e20;
      for (int j=m_nrows-1;j>=0;j--)
        {
          for (int i=0;i<m_ncols;i++)
            {
              //load in the data
              DEM_file>>m_DEM[i][j];

              //vertical shift and scale
              if (rint(m_DEM[i][j]) != m_NODATA)
                {
                  Real val = (m_bottomBuffer + m_DEM[i][j]*m_cellvalue)*m_verticalScale;
                  m_DEM[i][j] = val;
                  if (val < m_minDEM)
                    {
                      m_minDEM = val; //this is the highest spot so far...
                    }
                  if (val > m_maxDEM)
                    {
                      m_maxDEM = val; //this is the deepest spot so far...
                    }
                }
            }
        }
      pout()<<"  DEM min = "<<m_minDEM<<endl;
      pout()<<"  DEM max = "<<m_maxDEM<<endl;
    }
  DEM_file.close();

//   pout()<<"Warning: Setting (xllcorner,yllcorner) of DEM to (0.,0.)"<<endl;
//   m_xllcorner=0.;
//   m_yllcorner=0.;

  fileread = true;
  return fileread;
}

// change nodata value to land
// and convert DEM to meters.
bool DEMIF::fixDEM()
{
  bool DEMfixed = true;

  pout()<<"Changing fixing NODATA cells in DEM\n";

  int kn = 0;
  int kt = 0;
  for (int i=0;i<m_ncols;i++)
    {
      for (int j=0;j<m_nrows;j++)
        {
          if (rint(m_DEM[i][j]) == m_NODATA)
            {
              m_DEM[i][j] = m_highGround;
              kn++;
            }
          if (m_DEM[i][j] > m_truncElev)
            {
              m_DEM[i][j] = m_highGround;
              kt++;
            }
        }
    }
  pout()<<"Filled: "<<kn<<" no-data cells."<<endl;
  pout()<<"Filled: "<<kt<<" shallow cells."<<endl;
  return DEMfixed;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Real DEMIF::value(const RealVect& a_point) const
{

  Real retval =0.;

  const RealVect& x = a_point;

  //where xllcorner is the x-lower-left corner of the cell-centered DEM
  //find nearest cell in DEM (recall that the DEM values are cell centered)
  Real xi,yj;
  xi = (x[0]-m_xllcorner)/m_cellsize - 0.5;
  yj = (x[1]-m_yllcorner)/m_cellsize - 0.5;
  Real xiFloor = floor(xi);
  Real yjFloor = floor(yj);

  int i,j;
  // centered on i+1/2
  i = (int)xiFloor;
  j = (int)yjFloor;

#if CH_SPACEDIM==2
  j = 0;
#endif

  int sz;//this is the size of the interp stencil
  if (m_doCubic)
    {//cubic
     sz = 1;
    }
  else
    {//linear
     sz = 0;
    }

  //the following checks to make sure we are inside of the DEM database (otherwise return a NODATA value)
  if (i-sz<0)
    {
      retval=m_highGround;
    }
  else if (i+sz>m_ncols-2)
    {
      retval=m_highGround;
    }
#if CH_SPACEDIM ==2
  else if (j != 0)
    {
      MayDay::Abort("j not equal to 0 for 2d in DEMIF");
    }
#elif CH_SPACEDIM == 3
  else if (j-sz<0)
    {
      retval=m_highGround;
    }
  else if (j+sz>m_nrows-2)
    {
      retval=m_highGround;
    }
#endif
  else
    {
      if (m_interpType==1)
        { //bilinear interpolation
          RealVect a   = RealVect::Zero;
          Real xLo = m_xllcorner + (i+0.5)*m_cellsize; //this is the x position of the low side of this dem cell (i,j)
          Real yLo = m_yllcorner + (j+0.5)*m_cellsize; //this is the y position of the low side of this dem cell (i,j)

          //a is the (bi)linear coefficient
          a[0] = (x[0]-xLo)/m_cellsize;
          a[1] = (x[1]-yLo)/m_cellsize;

          const Real& fLoLo = m_DEM[i  ][j  ];
          const Real& fHiLo = m_DEM[i+1][j  ];
          Real rLo = (1.0-a[0])*fLoLo + a[0]*fHiLo;
          retval = rLo;

#if CH_SPACEDIM==3
          const Real& fLoHi = m_DEM[i  ][j+1];
          const Real& fHiHi = m_DEM[i+1][j+1];
          Real rHi = (1.0-a[0])*fLoHi + a[0]*fHiHi;
          retval   = (1.0-a[1])*rLo   + a[1]*rHi;
#endif
        }
      else if (m_interpType==3)
        { //bicubic interpolation type1 (this performs cubic interpolation in 1D, matching all values)
          //now let's do some bicubic interpolation...
#if CH_SPACEDIM==3
          const Real& f1 = m_DEM[i-1][j-1];
          const Real& f2 = m_DEM[i  ][j-1];
          const Real& f3 = m_DEM[i+1][j-1];
          const Real& f4 = m_DEM[i+2][j-1];
#endif
          const Real& f5 = m_DEM[i-1][j  ];
          const Real& f6 = m_DEM[i  ][j  ];
          const Real& f7 = m_DEM[i+1][j  ];
          const Real& f8 = m_DEM[i+2][j  ];
#if CH_SPACEDIM==3
          const Real& f9 = m_DEM[i-1][j+1];
          const Real& f10= m_DEM[i  ][j+1];
          const Real& f11= m_DEM[i+1][j+1];
          const Real& f12= m_DEM[i+2][j+1];
          const Real& f13= m_DEM[i-1][j+2];
          const Real& f14= m_DEM[i  ][j+2];
          const Real& f15= m_DEM[i+1][j+2];
          const Real& f16= m_DEM[i+2][j+2];
#endif
          Real xd=x[0]-m_xllcorner-m_hx*(float(i+1)); //this is the x-distance from (i+1/2,j+1/2)
          Real x2 = pow(xd,2);
          Real x3 = pow(xd,3);
#if CH_SPACEDIM==3
          Real yd=x[1]-m_yllcorner-m_hy*(float(j+1)); //this is the y-distance from (i+1/2,j+1/2)
          Real y2 = pow(yd,2);
          Real y3 = pow(yd,3);
#endif

#if CH_SPACEDIM==3
          //cubic type1 in x direction: for row j-1
          Real r1 = (-3.*m_hx3*( f1 - 9.*(f2 + f3) + f4)    +
                     2.*m_hx2*( f1 -27.*(f2 - f3) - f4)*xd  +
                     12.*m_hx*( f1 -    (f2 + f3) + f4)*x2 +
                     8.*(-f1 + 3.*(f2 - f3) + f4)*x3)/(48.*m_hx3);
#endif
          //cubic type1 in x direction: for row j
          Real r2 = (-3.*m_hx3*( f5 - 9.*(f6 + f7) + f8)    +
                     2.*m_hx2*( f5 -27.*(f6 - f7) - f8)*xd  +
                     12.*m_hx*( f5 -    (f6 + f7) + f8)*x2 +
                     8.*(-f5 + 3.*(f6 - f7) + f8)*x3)/(48.*m_hx3);
          retval = r2;
#if CH_SPACEDIM==3
          //cubic type1 in x direction: for row j+1
          Real r3 = (-3.*m_hx3*( f9 - 9.*(f10 + f11) + f12)    +
                     2.*m_hx2*( f9 -27.*(f10 - f11) - f12)*xd  +
                     12.*m_hx*( f9 -    (f10 + f11) + f12)*x2 +
                     8.*(-f9 + 3.*(f10 - f11) + f12)*x3)/(48.*m_hx3);

          //cubic type1 in x direction: for row j+2
          Real r4 = (-3.*m_hx3*( f13 - 9.*(f14 + f15) + f16)    +
                     2.*m_hx2*( f13 -27.*(f14 - f15) - f16)*xd  +
                     12.*m_hx*( f13 -    (f14 + f15) + f16)*x2 +
                     8.*(-f13 + 3.*(f14 - f15) + f16)*x3)/(48.*m_hx3);

          //cubic type1 in y direction!!!
          retval  = (-3.*m_hy3*( r1 - 9.*(r2 + r3) + r4)    +
                     2.*m_hy2*( r1 -27.*(r2 - r3) - r4)*yd  +
                     12.*m_hy*( r1 -    (r2 + r3) + r4)*y2 +
                     8.*(-r1 + 3.*(r2 - r3) + r4)*y3)/(48.*m_hy3);
#endif
        }
      else if (m_interpType==4)
        { //bicubic interpolation type2 (this performs cubic interpolation in 1D, matching values and derivatives)

          //now let's do some bicubic interpolation...
#if CH_SPACEDIM==3
          const Real& f1 = m_DEM[i-1][j-1];
          const Real& f2 = m_DEM[i  ][j-1];
          const Real& f3 = m_DEM[i+1][j-1];
          const Real& f4 = m_DEM[i+2][j-1];
#endif
          const Real& f5 = m_DEM[i-1][j  ];
          const Real& f6 = m_DEM[i  ][j  ];
          const Real& f7 = m_DEM[i+1][j  ];
          const Real& f8 = m_DEM[i+2][j  ];
#if CH_SPACEDIM==3
          const Real& f9 = m_DEM[i-1][j+1];
          const Real& f10= m_DEM[i  ][j+1];
          const Real& f11= m_DEM[i+1][j+1];
          const Real& f12= m_DEM[i+2][j+1];
          const Real& f13= m_DEM[i-1][j+2];
          const Real& f14= m_DEM[i  ][j+2];
          const Real& f15= m_DEM[i+1][j+2];
          const Real& f16= m_DEM[i+2][j+2];
#endif
          Real xd=x[0]-m_xllcorner-m_hx*(float(i+1)); //this is the x-distance from (i+1/2,j+1/2)
          Real x2 = pow(xd,2);
          Real x3 = pow(xd,3);
#if CH_SPACEDIM==3
          Real yd=x[1]-m_yllcorner-m_hy*(float(j+1)); //this is the y-distance from (i+1/2,j+1/2)
          Real y2 = pow(yd,2);
          Real y3 = pow(yd,3);

          //cubic type2 in x direction: for row j-1
          Real r1 = (-f1 + 9.*(f2 + f3) - f4)   /    16.  +
            ( f1 -11.*(f2 - f3) - f4)*xd /(m_hx *8.) +
            ( f1 -    (f2 + f3) + f4)*x2/(m_hx2*4.) +
            (-f1 + 3.*(f2 - f3) + f4)*x3/(m_hx3*2.);
#endif
          //cubic type2 in x direction: for row j
          Real r2 = (-f5 + 9.*(f6 + f7) - f8)   /    16.  +
            ( f5 -11.*(f6 - f7) - f8)*xd /(m_hx *8.) +
            ( f5 -    (f6 + f7) + f8)*x2/(m_hx2*4.) +
            (-f5 + 3.*(f6 - f7) + f8)*x3/(m_hx3*2.);
          retval = r2;
#if CH_SPACEDIM==3
          //cubic type2 in x direction: for row j+1
          Real r3 = (-f9 + 9.*(f10 + f11) - f12)   /    16.  +
            ( f9 -11.*(f10 - f11) - f12)*xd /(m_hx *8.) +
            ( f9 -    (f10 + f11) + f12)*x2/(m_hx2*4.) +
            (-f9 + 3.*(f10 - f11) + f12)*x3/(m_hx3*2.);

          //cubic type2 in x direction: for row j+2
          Real r4 = (-f13 + 9.*(f14 + f15) - f16)   /    16.  +
            ( f13 -11.*(f14 - f15) - f16)*xd /(m_hx *8.) +
            ( f13 -    (f14 + f15) + f16)*x2/(m_hx2*4.) +
            (-f13 + 3.*(f14 - f15) + f16)*x3/(m_hx3*2.);

          //cubic type2 in y direction!!!
          retval  = (-r1 + 9.*(r2 + r3) - r4)   /    16.  +
            ( r1 -11.*(r2 - r3) - r4)*yd /(m_hy *8.) +
            ( r1 -    (r2 + r3) + r4)*y2/(m_hy2*4.) +
            (-r1 + 3.*(r2 - r3) + r4)*y3/(m_hy3*2.);
#endif
        }
      else
        {
          MayDay::Abort("Bad InterpType in DEMIF");
        }
    }

  retval -= a_point[SpaceDim-1];

  return retval;
}

BaseIF* DEMIF::newImplicitFunction() const
{
  DEMIF* demPtr = new DEMIF(*this);

  return static_cast<BaseIF*>(demPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "MollifyIF.H"

#include "NamespaceHeader.H"

MollifyIF::MollifyIF(const BaseIF& a_impFunc,
                     const BaseIF& a_mollifier,
                     const Real&   a_min,
                     const Real&   a_max,
                     const int&    a_numPts)
{
  // Copy the implicit functions
  m_impFunc   = a_impFunc.newImplicitFunction();
  m_mollifier = a_mollifier.newImplicitFunction();

  // Save the sampled neighborhood specifications
  m_min    = a_min;
  m_max    = a_max;
  m_numPts = a_numPts;

  // Spacing of the sample points
  if (m_numPts > 1)
  {
    m_dx = (m_max - m_min) / (m_numPts - 1);
  }
  else
  {
    m_dx = 0.0;
  }

  // Box for the sampled mollifier
  m_sampleBox.define(IntVect::Zero, (m_numPts-1) * IntVect::Unit);

  // Create the FArrayBox for the sampled mollifier
  int nComp = 1;

  m_sampledMollifier.define(m_sampleBox,nComp);

  // Sum the mollifier values so they can be normalized
  m_mollifierSum = 0.0;

  // Sample the mollifier on the necessary grid
  for (BoxIterator bit(m_sampleBox); bit.ok(); ++bit)
  {
    IntVect iv = bit();
    RealVect point;

    for (int idir = 0; idir < SpaceDim; idir++)
    {
      point[idir] = m_max - iv[idir] * m_dx;
    }

    Real value = m_mollifier->value(point);

    m_mollifierSum += value;
    m_sampledMollifier(iv,0) = value;
  }

  // Normalize the sampled mollifier to be a partition of unity (i.e. to sum
  // to 1.0)
  m_sampledMollifier *= 1.0 / m_mollifierSum;
}

MollifyIF::MollifyIF(const MollifyIF& a_inputIF)
{
  // Copy things over
  if (a_inputIF.m_impFunc == NULL)
  {
    m_impFunc = NULL;
  }
  else
  {
    m_impFunc = a_inputIF.m_impFunc->newImplicitFunction();
  }

  if (a_inputIF.m_mollifier == NULL)
  {
    m_mollifier = NULL;
  }
  else
  {
    m_mollifier = a_inputIF.m_mollifier->newImplicitFunction();
  }

  m_min    = a_inputIF.m_min;
  m_max    = a_inputIF.m_max;
  m_numPts = a_inputIF.m_numPts;

  m_dx     = a_inputIF.m_dx;

  m_sampleBox = a_inputIF.m_sampleBox;

  m_sampledMollifier.define(a_inputIF.m_sampledMollifier.box(),
                            a_inputIF.m_sampledMollifier.nComp());
  m_sampledMollifier.copy  (a_inputIF.m_sampledMollifier);
}

MollifyIF::~MollifyIF()
{
  // Delete the IFs (if they exist)
  if (m_impFunc != NULL)
  {
    delete m_impFunc;
  }

  if (m_mollifier != NULL)
  {
    delete m_mollifier;
  }
}

Real MollifyIF::value(const RealVect& a_point) const
{
  Real retval = 0.0;

  // Apply the mollifier to the function at the current point (a_point)
  for (BoxIterator bit(m_sampleBox); bit.ok(); ++bit)
  {
    IntVect iv = bit();
    RealVect point(a_point);

    for (int idir = 0; idir < SpaceDim; idir++)
    {
      point[idir] += m_min + iv[idir] * m_dx;
    }

    retval += m_sampledMollifier(iv,0) * m_impFunc->value(point);
  }

  return retval;
}

Real MollifyIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{
  RealVect point;
  for (int idir = 0 ; idir < GLOBALDIM ; idir++)
    {
      point[idir] = a_point[idir];
    }

  return value(point);
}

BaseIF* MollifyIF::newImplicitFunction() const
{
  MollifyIF* mollifyPtr = new MollifyIF(*m_impFunc, *m_mollifier,
                                        m_min, m_max, m_numPts);

  return static_cast<BaseIF*>(mollifyPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "GaussianSphereIF.H"

#include "NamespaceHeader.H"

GaussianSphereIF::GaussianSphereIF(const Real&     a_sigma,
                                   const RealVect& a_center,
                                   const bool&     a_inside)
{
  // Remember the parameters
  m_sigma  = a_sigma;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the sigma squared and the normalizing factor
  m_sigma2 = m_sigma * m_sigma;
  m_normal = 1.0 / (m_sigma * sqrt(2.0*M_PI));
}

GaussianSphereIF::GaussianSphereIF(const GaussianSphereIF& a_inputIF)
{
  // Remember the parameters
  m_sigma  = a_inputIF.m_sigma;
  m_center = a_inputIF.m_center;
  m_inside = a_inputIF.m_inside;

  m_sigma2 = a_inputIF.m_sigma2;
  m_normal = a_inputIF.m_normal;
}

GaussianSphereIF::~GaussianSphereIF()
{
}

void GaussianSphereIF::GetParams(Real&     a_sigma,
                                 RealVect& a_center,
                                 bool&     a_inside) const
{
  // Copy parameter information over
  a_sigma  = m_sigma;
  a_center = m_center;
  a_inside = m_inside;
}

void GaussianSphereIF::SetParams(const Real&     a_sigma,
                                 const RealVect& a_center,
                                 const bool&     a_inside)
{
  // Set parameter information
  m_sigma  = a_sigma;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the sigma squared and the normalizing factor
  m_sigma2 = m_sigma * m_sigma;
  m_normal = 1.0 / (m_sigma * sqrt(2.0*M_PI));
}

Real GaussianSphereIF::value(const RealVect& a_point) const
{
  Real retval;

  // The distance squared for m_center to a_point
  Real distance2;

  // Compute the distance squared
  distance2 = 0.0;
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    Real cur;
    cur = a_point[idir] - m_center[idir];

    distance2 += cur*cur;
  }

  retval = m_normal * exp(-distance2/(2*m_sigma2));

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

Real GaussianSphereIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{
  RealVect point;
  for (int idir = 0 ; idir < GLOBALDIM ; idir++)
    {
      point[idir] = a_point[idir];
    }

  return value(point);
}

BaseIF* GaussianSphereIF::newImplicitFunction() const
{
  GaussianSphereIF* spherePtr = new GaussianSphereIF(m_sigma,
                                                     m_center,
                                                     m_inside);

  return static_cast<BaseIF*>(spherePtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "EllipsoidIF.H"

#include "NamespaceHeader.H"

EllipsoidIF::EllipsoidIF(const RealVect& a_radii,
                         const RealVect& a_center,
                         const bool&     a_inside)
{
  // Remember the parameters
  m_radii  = a_radii;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the radii squared
  m_radii2  = m_radii;
  m_radii2 *= m_radii;
}

EllipsoidIF::EllipsoidIF(const EllipsoidIF& a_inputIF)
{
  // Remember the parameters
  m_radii  = a_inputIF.m_radii;
  m_center = a_inputIF.m_center;
  m_inside = a_inputIF.m_inside;

  // Precompute the radii squared
  m_radii2  = m_radii;
  m_radii2 *= m_radii;
}

EllipsoidIF::~EllipsoidIF()
{
}

void EllipsoidIF::GetParams(RealVect& a_radii,
                            RealVect& a_center,
                            bool&     a_inside) const
{
  // Copy parameter information over
  a_radii  = m_radii;
  a_center = m_center;
  a_inside = m_inside;
}

void EllipsoidIF::SetParams(const RealVect& a_radii,
                            const RealVect& a_center,
                            const bool&     a_inside)
{
  // Set parameter information
  m_radii  = a_radii;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the radii squared
  m_radii2  = m_radii;
  m_radii2 *= m_radii;
}

Real EllipsoidIF::value(const RealVect& a_point) const
{
  Real retval;

  // Compute the equation of the ellipsoid
  Real sum;

  sum = 0.0;
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    Real cur;
    cur = a_point[idir] - m_center[idir];

    sum += cur*cur / m_radii2[idir];
  }

  // The sum should be 1.0 on the surface of the ellipsoid
  retval = sum - 1.0;

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

BaseIF* EllipsoidIF::newImplicitFunction() const
{
  EllipsoidIF* ellipsoidPtr = new EllipsoidIF(m_radii,
                                              m_center,
                                              m_inside);

  return static_cast<BaseIF*>(ellipsoidPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "EllipsoidIF.H"
#include "HelicoilIF.H"

#include "NamespaceHeader.H"

HelicoilIF::HelicoilIF(const Real& a_helixR,
                       const Real& a_helixPitch,
                       const Real& a_circleR,
                       const bool& a_inside)
{
  // Remember the parameters
  m_helixR     = a_helixR;
  m_helixPitch = a_helixPitch;
  m_circleR    = a_circleR;

  // Save inside flag
  m_inside = a_inside;

  Real slope = m_helixPitch / (2*M_PI*m_helixR);

  if (slope > 1.0)
  {
    m_ellipseR = m_circleR / sin(atan(slope));
    m_vertical = false;
  }
  else
  {
    m_ellipseR = m_circleR / cos(atan(slope));
    m_vertical = true;
  }

  RealVect radii(D_DECL(m_circleR,m_ellipseR,1.0));
  RealVect center(D_DECL(m_helixR,0.0,0.0));
  bool inside = true;

  EllipsoidIF crossSection(radii,center,inside);
  Real rate = 2*M_PI / m_helixPitch;

  m_helixIF = new HelixIF(crossSection,rate,m_inside,m_vertical);
}

HelicoilIF::HelicoilIF(const HelicoilIF& a_inputIF)
{
  // Remember the parameters
  m_helixR     = a_inputIF.m_helixR;
  m_helixPitch = a_inputIF.m_helixPitch;
  m_circleR    = a_inputIF.m_circleR;

  // Save inside flag
  m_inside = a_inputIF.m_inside;

  m_ellipseR = a_inputIF.m_ellipseR;
  m_vertical = a_inputIF.m_vertical;

  m_helixIF = a_inputIF.m_helixIF->newImplicitFunction();
}

HelicoilIF::~HelicoilIF()
{
  delete m_helixIF;
}

Real HelicoilIF::value(const RealVect& a_point) const
{
  Real retval = m_helixIF->value(a_point);

  return retval;
}

BaseIF* HelicoilIF::newImplicitFunction() const
{
  HelicoilIF* helicoilPtr;

  helicoilPtr = new HelicoilIF(m_helixR,m_helixPitch,m_circleR,m_inside);

  return static_cast<BaseIF*>(helicoilPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "SumIF.H"

#include "NamespaceHeader.H"

SumIF::SumIF(const BaseIF& a_impFunc1,
             const BaseIF& a_impFunc2,
             const bool&   a_sign)
{
  // Number of implicit function in sum
  m_numFuncs = 2;

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  // Make copies of the implicit functions
  m_impFuncs[0] = a_impFunc1.newImplicitFunction();
  m_impFuncs[1] = a_impFunc2.newImplicitFunction();

  //sum or difference
  m_sign = a_sign;
}

SumIF::SumIF(const Vector<BaseIF *>& a_impFuncs)
{
  // Number of implicit function in sum
  m_numFuncs = a_impFuncs.size();

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  // Make copies of the implicit functions

  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (a_impFuncs[ifunc] == NULL)
    {
      m_impFuncs[ifunc] = NULL;
    }
    else
    {
      m_impFuncs[ifunc] = a_impFuncs[ifunc]->newImplicitFunction();
    }
  }
  //sign to make the sum
  m_sign = true;
}

SumIF::SumIF(const SumIF& a_inputIF)
{
  // Number of implicit function in sum
  m_numFuncs = a_inputIF.m_impFuncs.size();

  // Vector of implicit function pointers
  m_impFuncs.resize(m_numFuncs);

  //get the sign
  m_sign =  a_inputIF.getSign();

  // Make copies of the implicit functions
  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (a_inputIF.m_impFuncs[ifunc] == NULL)
    {
      m_impFuncs[ifunc] = NULL;
    }
    else
    {
      m_impFuncs[ifunc] = a_inputIF.m_impFuncs[ifunc]->newImplicitFunction();
    }
  }
}

SumIF::~SumIF()
{
  // Delete all the copies
  for (int ifunc = 0; ifunc < m_numFuncs; ifunc++)
  {
    if (m_impFuncs[ifunc] != NULL)
    {
      delete m_impFuncs[ifunc];
    }
  }
}

void SumIF::setSign(bool a_sign)
{
  m_sign = a_sign;
}

Real SumIF::value(const RealVect& a_point) const

{

  // sum of the implicit functions values
  Real retval;
  retval = 0.0;

  if (m_sign)
    {
      // sum values and return it
      if (m_numFuncs > 0)
        {
          retval = m_impFuncs[0]->value(a_point);

          for (int ifunc = 1; ifunc < m_numFuncs; ifunc++)
            {
              retval=retval + m_impFuncs[ifunc]->value(a_point);
            }
        }
    }
  else
    {
//do the difference
      if (m_numFuncs != 2)
        {
          MayDay::Abort("Cannot make the difference for m_numFuncs != 2, m_sign should be equal to true");
        }
      retval =  m_impFuncs[0]->value(a_point) - m_impFuncs[1]->value(a_point);
    }

  return retval;
}

Real SumIF::value(const IndexTM<Real,GLOBALDIM>& a_point) const
{

  Real retval;
  retval = 0.0;

  if (m_sign)
    {
      if (m_numFuncs > 0)
        {
          retval = m_impFuncs[0]->value(a_point);

          for (int ifunc = 1; ifunc < m_numFuncs; ifunc++)
            {
              retval=retval + m_impFuncs[ifunc]->value(a_point);
            }
        }
    }

  else
    {
      //do the difference
      if (m_numFuncs != 2)
        {
          MayDay::Abort("Cannot make the difference for m_numFuncs != 2, m_sign should be equal to true");
        }
      retval =  m_impFuncs[0]->value(a_point) - m_impFuncs[1]->value(a_point);
    }

  return retval;
}

Real SumIF::value(const IndexTM<int,GLOBALDIM> & a_partialDerivative,
                           const IndexTM<Real,GLOBALDIM>& a_point) const
{

  Real retval;
  retval = 0.0;

  if (m_sign)
    {
      if (m_numFuncs > 0)
        {
          retval = m_impFuncs[0]->value(a_partialDerivative,a_point);

          for (int ifunc = 1; ifunc < m_numFuncs; ifunc++)
            {
              retval=retval + m_impFuncs[ifunc]->value(a_partialDerivative,a_point);
            }
        }
    }
  else
    {
      //do the difference
      if (m_numFuncs != 2)
        {
          MayDay::Abort("Cannot make the difference for m_numFuncs != 2, m_sign should be equal to true");
        }
      retval =  m_impFuncs[0]->value(a_partialDerivative,a_point) - m_impFuncs[1]->value(a_partialDerivative,a_point);
    }

  return retval;
}

bool SumIF::getSign() const
{
  return m_sign;
}

BaseIF* SumIF::getImplicitFunction(int a_num)
{
  return m_impFuncs[a_num];
}


BaseIF* SumIF::newImplicitFunction() const
{
  SumIF* sumPtr = new SumIF(m_impFuncs);
  sumPtr->setSign(m_sign);

  return static_cast<BaseIF*>(sumPtr);
}



#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "EBGeomDebugOut.H"

#include "NamespaceHeader.H"

void dumpIFData1(const IFData<1>* a_ifData)
{
  a_ifData->print(pout());
}

void dumpIFData2(const IFData<2>* a_ifData)
{
  a_ifData->print(pout());
}

void dumpIFData3(const IFData<3>* a_ifData)
{
  a_ifData->print(pout());
}

void dumpCCM1(const CutCellMoments<1>* a_ccm)
{
  a_ccm->print(pout());
}

void dumpCCM2(const CutCellMoments<2>* a_ccm)
{
  a_ccm->print(pout());
}

void dumpCCM3(const CutCellMoments<3>* a_ccm)
{
  a_ccm->print(pout());
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "PolarIF.H"

#include "NamespaceHeader.H"

PolarIF::PolarIF(const Real& a_primaryRadius,
                 const Real& a_perturbation,
                 const int & a_frequency,
                 const bool& a_inside)
{
  // Remember the parameters
  m_primaryRadius = a_primaryRadius;
  m_perturbation  = a_perturbation;
  m_frequency     = a_frequency;
  m_inside        = a_inside;
}

PolarIF::PolarIF(const PolarIF& a_inputIF)
{
  // Remember the parameters
  m_primaryRadius = a_inputIF.m_primaryRadius;
  m_perturbation  = a_inputIF.m_perturbation;
  m_frequency     = a_inputIF.m_frequency;
  m_inside        = a_inputIF.m_inside;
}

PolarIF::~PolarIF()
{
}

void PolarIF::GetParams(Real& a_primaryRadius,
               Real& a_perturbation,
               int & a_frequency,
               bool& a_inside)const
{
  // Copy parameter information over
  a_primaryRadius = m_primaryRadius;
  a_perturbation  = m_perturbation;
  a_frequency     = m_frequency;
  a_inside        = m_inside;
 }

void PolarIF::SetParams(const Real& a_primaryRadius,
               const Real& a_perturbation,
               const int & a_frequency,
               const bool& a_inside)
{
  // Set the parameters
  m_primaryRadius = a_primaryRadius;
  m_perturbation  = a_perturbation;
  m_frequency     = a_frequency;
  m_inside        = a_inside;
}

Real PolarIF::value(const RealVect& a_point) const
{
  Real retval;

  Real radius;
  Real theta;

  radius = sqrt(a_point[0]*a_point[0] + a_point[1]*a_point[1]);
  theta = atan2(a_point[1],a_point[0]);

  retval = radius - (m_primaryRadius + m_perturbation*cos(m_frequency*theta));

  if (!m_inside)
    {
      retval = -retval;
    }
  return retval;
}

BaseIF* PolarIF::newImplicitFunction() const
{
  PolarIF* polarPtr = new PolarIF( m_primaryRadius,
                                   m_perturbation,
                                   m_frequency,
                                   m_inside);

  return static_cast<BaseIF*>(polarPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "HelixIF.H"

#include "NamespaceHeader.H"

HelixIF::HelixIF(const BaseIF& a_impFunc,
                 const Real&   a_rate,
                 const bool&   a_inside,
                 const bool&   a_vertical)
{
  // Make a copy of the implicit function and rate
  m_impFunc = a_impFunc.newImplicitFunction();
  m_rate    = a_rate;

  // Save inside flag
  m_inside = a_inside;

  // Treat the impliction function are vertical (in the x-z plane) and not
  // horizontal (in the x-y plane)
  m_vertical = a_vertical;

  // This is the valid range of z for sweeping the vertical IF
  if (m_vertical)
  {
    m_minz = -M_PI / m_rate;
    m_maxz =  M_PI / m_rate;
  }
}

HelixIF::HelixIF(const HelixIF& a_inputIF)
{
  // Make a copy of the implicit function and rate
  m_impFunc = a_inputIF.m_impFunc->newImplicitFunction();
  m_rate    = a_inputIF.m_rate;

  // Save inside flag
  m_inside = a_inputIF.m_inside;

  // Treat the impliction function are vertical (in the x-z plane) and not
  // horizontal (in the x-y plane)
  m_vertical = a_inputIF.m_vertical;

  // This is the valid range of z for sweeping the vertical IF
  m_minz = a_inputIF.m_minz;
  m_maxz = a_inputIF.m_maxz;
}

HelixIF::~HelixIF()
{
  delete m_impFunc;
}

Real HelixIF::value(const RealVect& a_point) const
{
  Real retval;

#if CH_SPACEDIM == 2
  // In 2D, return the given implicit function
  retval =  m_impFunc->value(a_point);
#elif CH_SPACEDIM == 3
  // Get the point coordinates
  Real x = a_point[0];
  Real y = a_point[1];
  Real z = a_point[2];

  if (!m_vertical)
  {
    // Compute the rotation angle
    Real theta = m_rate * z;

    // Rotate the x,y point back to z = 0
    Real x2,y2;
    x2 =  cos(-theta)*x + sin(-theta)*y;
    y2 = -sin(-theta)*x + cos(-theta)*y;

    // Construct this point in x-y plane (z = 0)
    RealVect point(x2,y2,0.0);

    // Return the given implicit function at that point
    retval = m_impFunc->value(point);
  }
  else
  {
    Real r = sqrt(x*x + y*y);
    Real theta = atan2(y,x);

    Real unrotateZ = z - theta/m_rate;
    Real numZ = (unrotateZ - m_minz) / (m_maxz - m_minz);
    Real pullbackZ = (numZ - floor(numZ)) * (m_maxz - m_minz) + m_minz;

    RealVect point(r,pullbackZ,0.0);

    retval = m_impFunc->value(point);
  }
#else
  MayDay::Abort("need higher dim in HelixIF\n");
#endif

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

BaseIF* HelixIF::newImplicitFunction() const
{
  HelixIF* helixPtr;

  helixPtr = new HelixIF(*m_impFunc,m_rate,m_inside,m_vertical);

  return static_cast<BaseIF*>(helixPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>

#include "GeometryShop.H"
#include "NewGeometryShop.H"
#include "ReferenceHeightIF.H"
#include "NoRefinement.H"
#include "FixedRefinement.H"
#include "ComputeCutCellMoments.H"

#include "PolyGeom.H"
#include "RealVect.H"

#include "NamespaceHeader.H"

bool NewGeometryShop::s_verbose = false;

/**********************************************/
/*********************************************/
NewGeometryShop::NewGeometryShop(const BaseIF& a_baseIF,
                               const RealVect         & a_origin,
                               const RealVect         & a_vectDx,
                               const ProblemDomain    & a_domain,
#if RECURSIVE_GEOMETRY_GENERATION == 0
                               const int              & a_order,
                               const int              & a_degreeP,
#else
                               const int              & a_orderPmax,
                               const int              & a_degreePmax,
#endif
                               const bool             & a_useConstraints)
  :m_phase(-1),
   m_baseIF(a_baseIF.newImplicitFunction())

{
  CH_TIME("NewGeometryShop::NewGeometryShop");

  m_domain = a_domain;
  m_origin = a_origin;
  m_vectDx = a_vectDx;

#if RECURSIVE_GEOMETRY_GENERATION == 0
  m_order          = a_order;
  m_degreeP        = a_degreeP;
#else
  m_orderPmax      = a_orderPmax;
  m_degreePmax     = a_degreePmax;
#endif
  m_useConstraints = a_useConstraints;

  //this is used for scaling face areas
  m_volScaleFactor = 1.0;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      m_volScaleFactor *= m_vectDx[idir];
    }
  //this is used for scaling boundary area
  Real maxDxComponent = 0;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      if (m_vectDx[idir] > maxDxComponent)
        {
          maxDxComponent = m_vectDx[idir];
          m_bndryAreaScaleFactor = pow(m_vectDx[idir],SpaceDim -1);
        }
    }

  //records vector dx as an IndexTM
  //m_dxVect = convertRealVect2IndexTM(m_vectDx);
  for (int idir = 0 ; idir < SpaceDim ; idir++)
    {
      m_dxVect[idir] = m_vectDx[idir];
    }
  if (GLOBALDIM != SpaceDim)
    {
      const ReferenceHeightIF *refIF = dynamic_cast<const ReferenceHeightIF *>(m_baseIF);
      if (refIF == NULL)
      {
        MayDay::Error("NewGeomteryShop constructor: Couldn't cast BaseIF pointer to ReferenceHeightIF");
      }

      m_dxVect[SpaceDim] = refIF->getReferenceHeight();
    }

// Only create these in serial since they aren't distributed in parallel and
// this causes parallel runs to fail when the domain gets large enough.  This
// needs a better long-term fix.
#ifndef CH_MPI
  //initialize the FAB containing the residuals
  int nComp = 15;
  m_residuals.define(m_domain.domainBox(),nComp);
  m_residuals.setVal(0.0);

  int nGradComp = 15;
  m_gradNormal.define(m_domain.domainBox(),nGradComp);
  m_gradNormal.setVal(0.0);
#endif

  m_threshold = 1.0e-15;
  m_numCellsClipped = 0;
}

/**********************************************/
/*********************************************/
NewGeometryShop::~NewGeometryShop()
{
  CH_TIME("NewGeometryShop::~NewGeometryShop");

  delete(m_baseIF);
}

/**********************************************/
/*********************************************/



bool NewGeometryShop::isRegular(const Box           & a_region,
                               const ProblemDomain & a_domain,
                               const RealVect      & a_origin,
                               const Real          & a_dx) const
{
  CH_TIME("NewGeometryShop::isRegular");
  //set a vectDx
  RealVect vectDx = m_vectDx;

  // first check any of the Box corners is outside, and return false
  // right away. (bvs)
  RealVect physCorner;
  IntVect lo = a_region.smallEnd();
  IntVect len = a_region.size();
  Box unitBox(IntVect::Zero, IntVect::Unit);
  for (BoxIterator bit(unitBox); bit.ok(); ++bit)
    {
      IntVect current = lo + len*bit();
      for (int idir = 0; idir < CH_SPACEDIM; ++idir)
        {
          physCorner[idir] = vectDx[idir]*(current[idir]) + a_origin[idir];
        }
      Real functionValue = m_baseIF->value(physCorner);
      if (functionValue > 0.0 )
        {
          return false;
        }
    }

  return isRegularEveryPoint(a_region, a_domain, a_origin, a_dx);
}

bool NewGeometryShop::isRegularEveryPoint(const Box&           a_region,
                                         const ProblemDomain& a_domain,
                                         const RealVect&      a_origin,
                                         const Real&          a_dx) const
{
  CH_TIME("NewGeometryShop::isRegularEveryPoint");

  //set a vectDx
  RealVect vectDx = m_vectDx;

  // All corner indices for the current box
  Box allCorners(a_region);
  allCorners.surroundingNodes();

  RealVect physCorner;
  BoxIterator bit(allCorners);
  // If every corner is inside, the box is regular
  for (int i=0; i<2; i++)
    {
      for (; bit.ok(); ++bit, ++bit)
        {
          // Current corner
          const IntVect& corner = bit();

          // Compute physical coordinate of corner


          for (int idir = 0; idir < CH_SPACEDIM; ++idir)
            {
              physCorner[idir] = vectDx[idir]*(corner[idir]) + a_origin[idir];
            }

          // If the implicit function value is positive then the current corner is
          // outside the domain
          Real functionValue = m_baseIF->value(physCorner);

          if (functionValue > 0.0 )
            {
              return false;
            }
        }
      bit.reset();
      ++bit;
    }

  return true;
}

/**********************************************/
/*********************************************/
bool NewGeometryShop::isCovered(const Box           & a_region,
                               const ProblemDomain & a_domain,
                               const RealVect      & a_origin,
                               const Real          & a_dx) const
{
  CH_TIME("NewGeometryShop::isCovered");

  //set a vectDx
  RealVect vectDx = m_vectDx;

  // first check any of the Box corners is outside, and return false
  // right away. (bvs)
  RealVect physCorner;
  IntVect lo = a_region.smallEnd();
  IntVect len = a_region.size();
  Box unitBox(IntVect::Zero, IntVect::Unit);
  for (BoxIterator bit(unitBox); bit.ok(); ++bit)
    {
      IntVect current = lo + len*bit();
      for (int idir = 0; idir < CH_SPACEDIM; ++idir)
        {
          physCorner[idir] = vectDx[idir]*(current[idir]) + a_origin[idir];
        }
      Real functionValue = m_baseIF->value(physCorner);
      if (functionValue < 0.0 )
        {
          return false;
        }
    }

  return isCoveredEveryPoint(a_region, a_domain, a_origin, a_dx);
}

bool NewGeometryShop::isCoveredEveryPoint(const Box&           a_region,
                                         const ProblemDomain& a_domain,
                                         const RealVect&      a_origin,
                                         const Real&          a_dx) const
{
  CH_TIME("NewGeometryShop::isCoveredEveryPoint");

  //set a vectDx
  RealVect vectDx = m_vectDx;

  // All corner indices for the current box
  Box allCorners(a_region);
  allCorners.surroundingNodes();

  RealVect physCorner;
  BoxIterator bit(allCorners);
  // If every corner is inside, the box is regular
  for (int i=0; i<2; i++)
    {
      for (; bit.ok(); ++bit, ++bit)
        {
          // Current corner
          IntVect corner = bit();

          // Compute physical coordinate of corner

          for (int idir = 0; idir < CH_SPACEDIM; ++idir)
            {
              physCorner[idir] = vectDx[idir]*(corner[idir]) + a_origin[idir];
            }

          // If the implicit function value is positive then the current corner is
          // outside the domain
          Real functionValue = m_baseIF->value(physCorner);

          if (functionValue < 0.0 )
            {
              return false;
            }
        }
      bit.reset();
      ++bit;
    }

  return true;
}

bool NewGeometryShop::isIrregular(const Box           & a_region,
                                 const ProblemDomain & a_domain,
                                 const RealVect      & a_origin,
                                 const Real          & a_dx) const
{
  CH_TIME("NewGeometryShop::isIrregular");

  //set a vectDx
  RealVect vectDx = m_vectDx;

  // first check any of the Box corners is outside, and return false
  // right away. (bvs)
  RealVect physCorner;
  IntVect lo = a_region.smallEnd();
  IntVect len = a_region.size();
  for (int idir = 0; idir < CH_SPACEDIM; ++idir)
    {
      physCorner[idir] = vectDx[idir]*(lo[idir]) + a_origin[idir];
    }
  Real originVal = m_baseIF->value(physCorner);

  Box unitBox(IntVect::Zero, IntVect::Unit);
  for (BoxIterator bit(unitBox); bit.ok(); ++bit)
    {
      IntVect current = lo + len*bit();
      for (int idir = 0; idir < CH_SPACEDIM; ++idir)
        {
          physCorner[idir] = vectDx[idir]*(current[idir]) + a_origin[idir];
        }
      Real functionValue = m_baseIF->value(physCorner);
      if (functionValue * originVal < 0.0 )
        {
          return true;
        }
    }

  // return isIrregularEveryPoint(a_region, a_domain, a_origin, a_dx, originVal);
  return !(isRegularEveryPoint(a_region, a_domain, a_origin, a_dx) ||
           isCoveredEveryPoint(a_region, a_domain, a_origin, a_dx));
}

bool NewGeometryShop::isIrregularEveryPoint(const Box&           a_region,
                                         const ProblemDomain& a_domain,
                                         const RealVect&      a_origin,
                                         const Real&          a_dx,
                                         const Real&          a_originVal) const
{
  CH_TIME("NewGeometryShop::isIrregularEveryPoint");

  //set a vectDx
  RealVect vectDx = m_vectDx;

  // All corner indices for the current box
  Box allCorners(a_region);
  allCorners.surroundingNodes();

  RealVect physCorner;
  BoxIterator bit(allCorners);
  // If every corner is inside, the box is regular
  for (int i=0; i<2; i++)
    {
      for (; bit.ok(); ++bit, ++bit)
        {
          // Current corner
          IntVect corner = bit();

          // Compute physical coordinate of corner

          for (int idir = 0; idir < CH_SPACEDIM; ++idir)
            {
              physCorner[idir] = vectDx[idir]*(corner[idir]) + a_origin[idir];
            }

          // If the implicit function value is positive then the current corner is
          // outside the domain
          Real functionValue = m_baseIF->value(physCorner);

          if (functionValue * a_originVal < 0.0 )
            {
              return true;
            }
        }
      bit.reset();
      ++bit;
    }

  return false;
}

/**********************************************/
/*********************************************/
void NewGeometryShop::fillGraph(BaseFab<int>&       a_regIrregCovered,
                               Vector<IrregNode>&  a_nodes,
                               const Box&          a_validRegion,
                               const Box&          a_ghostRegion,
                               const ProblemDomain & a_domain,
                               const RealVect      & a_origin,
                               const Real          & a_dx) const
{
  CH_TIME("NewGeometryShop::fillGraph");

  CH_assert(a_domain.contains(a_ghostRegion));

  IntVectSet ivsirreg = IntVectSet(DenseIntVectSet(a_ghostRegion, false));

  for (BoxIterator bit(a_ghostRegion); bit.ok(); ++bit)
    {
      const IntVect iv =bit();
      Box miniBox(iv, iv);

      RvgDim cellCenter;
      for (int idir = 0;idir < SpaceDim; ++idir)
        {
          cellCenter[idir] = m_dxVect[idir]*(iv[idir] +0.5) + a_origin[idir];
        }
      if (GLOBALDIM != SpaceDim)
        {
          const ReferenceHeightIF *refIF = dynamic_cast<const ReferenceHeightIF *>(m_baseIF);
          if (refIF == NULL)
          {
            MayDay::Error("NewGeomteryShop constructor: Couldn't cast BaseIF pointer to ReferenceHeightIF");
          }

          cellCenter[SpaceDim] = refIF->getOrigin()[SpaceDim] + (refIF->getReferenceHeight() / 2.0);
        }

#if RECURSIVE_GEOMETRY_GENERATION != 0
      // P+R+D = m_degreePmax + m_orderPmax + GLOBALDIM and
      // R = Rmax when P = 0, so Rmax = m_degreePmax + m_orderPmax
      int maxOrder = m_degreePmax + m_orderPmax;
#endif

      //member data: sign(chosen from -1,0,1) of each vertex,
      //location of each edge intersection, cellCenter,normal and gradNormal
#if RECURSIVE_GEOMETRY_GENERATION == 0
      IFData<GLOBALDIM> edgeData(*m_baseIF,m_dxVect,cellCenter,m_order);
#else
      IFData<GLOBALDIM> edgeData(*m_baseIF,m_dxVect,cellCenter,maxOrder);
#endif

      //create a CutCellMoment object, in order to detect whether any face coincides with the interface
      CutCellMoments <GLOBALDIM> globalDimCutCell(edgeData);

#if (USING_TOP_FACE_MOMENTS)
      Iv2 bdId;
      bdId[BDID_DIR]   = 2;
      bdId[BDID_HILO]  = 1;
      CutCellMoments<GLOBALDIM-1> cutCell;
      cutCell = globalDimCutCell.m_bdCutCellMoments[bdId];
#else
      CutCellMoments<GLOBALDIM> cutCell;
      cutCell = globalDimCutCell;
#endif
      if (cutCell.isCovered())
        {
          //set covered cells to -1
          a_regIrregCovered(iv, 0) = -1;
        }
      else if (cutCell.isRegular())
        {
          //set regular cells to 1
          a_regIrregCovered(iv, 0) =  1;
        }
      else
        {
          //set irregular cells to 0
          //irregular if any face coincides with interface and edgeData.m_allVerticesIn = true
          a_regIrregCovered(iv, 0) =  0;
          if (a_validRegion.contains(iv))
            {
              ivsirreg |= iv;
            }
        }
    }

  //now loop through irregular cells and make nodes for each  one.
  for (IVSIterator ivsit(ivsirreg); ivsit.ok(); ++ivsit)
    {
      VolIndex vof(ivsit(), 0);
      Real     volFrac, bndryArea;
      RealVect normal, volCentroid, bndryCentroid;
      Vector<int> loArc[SpaceDim];
      Vector<int> hiArc[SpaceDim];
      Vector<Real> loAreaFrac[SpaceDim];
      Vector<Real> hiAreaFrac[SpaceDim];
      Vector<RealVect> loFaceCentroid[SpaceDim];
      Vector<RealVect> hiFaceCentroid[SpaceDim];

      computeVoFInternals(volFrac,
                          loArc,
                          hiArc,
                          loAreaFrac,
                          hiAreaFrac,
                          bndryArea,
                          normal,
                          volCentroid,
                          bndryCentroid,
                          loFaceCentroid,
                          hiFaceCentroid,
                          ivsirreg,
                          vof,
                          a_domain,
                          a_origin,
                          a_dx,
                          m_vectDx,
                          ivsit());
      {
        CH_TIME("fillGraph::endOfirregularCellLoop");
        IrregNode newNode;
        newNode.m_cell          = ivsit();
        newNode.m_volFrac       = volFrac;
        newNode.m_cellIndex     = 0;
        newNode.m_volCentroid   = volCentroid;
        newNode.m_bndryCentroid = bndryCentroid;
        for (int faceDir = 0; faceDir < SpaceDim; faceDir++)
          {
            int loNodeInd = newNode.index(faceDir, Side::Lo);
            int hiNodeInd = newNode.index(faceDir, Side::Hi);
            newNode.m_arc[loNodeInd]          = loArc[faceDir];
            newNode.m_arc[hiNodeInd]          = hiArc[faceDir];
            newNode.m_areaFrac[loNodeInd]     = loAreaFrac[faceDir];
            newNode.m_areaFrac[hiNodeInd]     = hiAreaFrac[faceDir];
            newNode.m_faceCentroid[loNodeInd] = loFaceCentroid[faceDir];
            newNode.m_faceCentroid[hiNodeInd] = hiFaceCentroid[faceDir];
          }
        a_nodes.push_back(newNode);
      }
    } //end loop over cells in the box
}

/**********************************************/
/*********************************************/
void NewGeometryShop::computeVoFInternals(Real&               a_volFrac,
                                         Vector<int>         a_loArc[SpaceDim],
                                         Vector<int>         a_hiArc[SpaceDim],
                                         Vector<Real>        a_loAreaFrac[SpaceDim],
                                         Vector<Real>        a_hiAreaFrac[SpaceDim],
                                         Real&               a_bndryArea,
                                         RealVect&           a_normal,
                                         RealVect&           a_volCentroid,
                                         RealVect&           a_bndryCentroid,
                                         Vector<RealVect>    a_loFaceCentroid[SpaceDim],
                                         Vector<RealVect>    a_hiFaceCentroid[SpaceDim],
                                         const IntVectSet&   a_ivsIrreg,
                                         const VolIndex&     a_vof,
                                         const ProblemDomain&a_domain,
                                         const RealVect&     a_origin,
                                         const Real&         a_dx,
                                         const RealVect&     a_vectDx,
                                         const IntVect&      a_iv)const
{
  CH_TIME("GeometryShop::ComputeVofInternals");

  //assigns a_iv to m_currIv
  settCurrIv(a_iv);

  //for each CutCellMoments<dim>, we record the cell Center
  //(in physical coordinates at the global dimension)
  RvgDim cellCenter;
  for (int idir = 0;idir < SpaceDim; ++idir)
    {
      cellCenter[idir] = m_dxVect[idir]*(m_currIv[idir] +0.5) + m_origin[idir];
    }
  if (GLOBALDIM != SpaceDim)
    {
      const ReferenceHeightIF *refIF = dynamic_cast<const ReferenceHeightIF *>(m_baseIF);
      if (refIF == NULL)
      {
        MayDay::Error("NewGeomteryShop constructor: Couldn't cast BaseIF pointer to ReferenceHeightIF");
      }

      cellCenter[SpaceDim] = refIF->getOrigin()[SpaceDim] + (refIF->getReferenceHeight() / 2.0);

    }

#if RECURSIVE_GEOMETRY_GENERATION != 0
  // P+R+D = m_degreePmax + m_orderPmax + GLOBALDIM and
  // R = Rmax when P = 0, so Rmax = m_degreePmax + m_orderPmax
  int maxOrder = m_degreePmax + m_orderPmax;
#endif

  // member data: sign (chosen from -1,0,1) of each vertex,
  // location of each edge intersection, cellCenter, normal and gradNormal
#if RECURSIVE_GEOMETRY_GENERATION == 0
  IFData<GLOBALDIM> edgeData(*m_baseIF,m_dxVect,cellCenter,m_order);
#else
  IFData<GLOBALDIM> edgeData(*m_baseIF,m_dxVect,cellCenter,maxOrder);
#endif

  //construct data holders for all moments
  ComputeCutCellMoments<GLOBALDIM> computeThisVof(edgeData);

  //refines if constraints violated or normal = (0,0)
  int maxNumberRefinements = 1;
  RefinementCriterion<GLOBALDIM> refinementCriterion(maxNumberRefinements);

  //compute the moments and save answers in thisVof
#if RECURSIVE_GEOMETRY_GENERATION == 0
  computeThisVof.computeMoments(m_order,m_degreeP,m_useConstraints,refinementCriterion);
#else
  computeThisVof.computeMoments(m_orderPmax,m_degreePmax,m_useConstraints,refinementCriterion);
#endif
  CutCellMoments<GLOBALDIM> thisVof = computeThisVof.m_cutCellMoments;

#if (USING_TOP_FACE_MOMENTS)
    {
      Iv2 bdId;
      bdId[BDID_DIR]   = 2;
      bdId[BDID_HILO]  = 1;
      ((NewGeometryShop *)this)->m_cutCellMoments = thisVof.m_bdCutCellMoments[bdId];
    }
#else
    {
      ((NewGeometryShop *)this)->m_cutCellMoments = thisVof;
    }
#endif

  //fill a gradNormal check FAB
  //fillGradNormFAB();

  //fillresiduals
  //fillResiduals(degreeP);

  //fillVolFrac:
  a_volFrac = fillVolFrac();

  //fillloArc
  fillLoArc(a_loArc,
            a_ivsIrreg);

  //fillHiArc
  fillHiArc(a_hiArc,
            a_ivsIrreg);

  //face area:lo
  fillLoAreaFrac(a_loAreaFrac);

  //face area:hi
  fillHiAreaFrac(a_hiAreaFrac);

  //fill boundary area
  a_bndryArea = fillBndryArea();

  //fillNormal
  a_normal = fillNormal();

  //fillvolCentroid:
  a_volCentroid = fillvolCentroid();

  //fillbndryCentroid
  a_bndryCentroid = fillBndryCentroid();

  //fillLoFaceCentroid
  fillLoFaceCentroid(a_loFaceCentroid);

  //fillHiFaceCentroid
  fillHiFaceCentroid(a_hiFaceCentroid);

  //sanity check for computed quantities
  clipComputedVal(a_volFrac,
                  a_loAreaFrac,
                  a_hiAreaFrac,
                  a_bndryArea,
                  a_volCentroid,
                  a_bndryCentroid,
                  a_loFaceCentroid,
                  a_hiFaceCentroid,
                  m_currIv);
}

void NewGeometryShop::settCurrIv(const IntVect& a_iv)const
{
  m_currIv = a_iv;
}

#if RECURSIVE_GEOMETRY_GENERATION == 0
void NewGeometryShop::fillResiduals(int & a_degreeP)const
#else
void NewGeometryShop::fillResiduals(int & a_degreePmax)const
#endif
{
// Only create these in serial since they aren't distributed in parallel and
// this causes parallel runs to fail when the domain gets large enough.  This
// needs a better long-term fix.
#ifndef CH_MPI
#if RECURSIVE_GEOMETRY_GENERATION == 0
  for (int iDegree = 0 ; iDegree < a_degreeP + 1 ; iDegree++)
#else
  for (int iDegree = 0 ; iDegree <= a_degreePmax; iDegree++)
#endif
    {
      for (int normJ = 0 ; normJ < 3 ; normJ++)
        {
          m_residuals(m_currIv,iDegree * 3 + normJ) = m_cutCellMoments.getResidual(iDegree,normJ);
        }
    }
#endif
}

//fillVolFrac
Real NewGeometryShop::fillVolFrac()const
{
  EBorVol momentMap = VolMoment;

 //when called with VolMoment , get Vol returns the volume fraction
  Real volume = m_cutCellMoments.getVol(momentMap);

  return volume/m_volScaleFactor;
}

//records connectivity between vofs
void NewGeometryShop::fillArc(Vector<int>        a_arc[SpaceDim],
                             const int        & a_hilo,
                             const IntVectSet & a_ivsIrreg)const
{
  Iv2 bdId;
  //a_hilo is 0 or 1
  bdId[BDID_HILO] = a_hilo;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      bdId[BDID_DIR] = idir;
      bool covered =  m_cutCellMoments.getBdCutCellMoments(bdId).isCovered();

      if (covered)
        {
          a_arc[idir].resize(0);
        }
      else
        {
          a_arc[idir].resize(1);

          //otherIV is the iv in the idir direction on the a_hilo side
          IntVect otherIV = m_currIv;
          otherIV[idir] += (a_hilo*2) - 1;

          if (m_domain.contains(otherIV))
            {
              int otherCellIndex;
              if (a_ivsIrreg.contains(otherIV))
                {
                  otherCellIndex = 0;
                }
              else
                {
                  //arc to regular cell
                  otherCellIndex = -2;
                }
              a_arc[idir][0]=otherCellIndex;
            }
          else if (!m_domain.contains(otherIV))
            {
              //boundary arcs always -1
              a_arc[idir][0] = -1;
            }
        }
    }
}
  //records connectivity between vofs
  void NewGeometryShop::fillLoArc(Vector<int>        a_loArc[SpaceDim],
                                 const IntVectSet & a_ivsIrreg)const
{
   int hilo = 0;
   fillArc(a_loArc,
           hilo,
           a_ivsIrreg);
}

//records connectivity between vofs
void NewGeometryShop::fillHiArc(Vector<int>        a_hiArc[SpaceDim],
                               const IntVectSet & a_ivsIrreg)const
{
  int hilo = 1;
  fillArc(a_hiArc,
          hilo,
          a_ivsIrreg);
}

//face area
void NewGeometryShop::fillAreaFrac(Vector<Real>  a_areaFrac[SpaceDim],
                                  const int   & a_hilo)const
{
  //volume moments of coordinate aligned faces
  EBorVol momentMap = VolMoment;

  Iv2 bdId;
  bdId[BDID_HILO] = a_hilo;
  for (int idir = 0; idir < SpaceDim ;++ idir)
    {
      bdId[BDID_DIR] = idir;
      bool covered = m_cutCellMoments.getBdCutCellMoments(bdId).isCovered();
      //when called with VolMoment,get Vol returns the volume fraction
      if (!covered)
        {
          a_areaFrac[idir].resize(1);
          a_areaFrac[idir][0] = m_cutCellMoments.getBdCutCellMoments(bdId).getVol(momentMap);
          //scale area fraction
          Real scaleFactor = m_vectDx[idir]/m_volScaleFactor;
          a_areaFrac[idir][0] *= scaleFactor;
        }
      else
        {
          a_areaFrac[idir].resize(0);
        }
    }

}
//face area:lo
void NewGeometryShop::fillLoAreaFrac(Vector<Real>a_loAreaFrac[SpaceDim])const
{
  int hilo = 0;
  fillAreaFrac(a_loAreaFrac,hilo);
}
//face area:hi
void NewGeometryShop::fillHiAreaFrac(Vector<Real>a_loAreaFrac[SpaceDim])const
{
  int hilo = 1;
  fillAreaFrac(a_loAreaFrac,hilo);
}

//fill boundary area
Real NewGeometryShop::fillBndryArea()const
{
  EBorVol momentMap = EBMoment;
  Real bndryArea =  m_cutCellMoments.getVol(momentMap);
  bndryArea /= m_bndryAreaScaleFactor;

  return bndryArea;
}

//fillNormal
RealVect NewGeometryShop::fillNormal() const
{
  RealVect normal;

  IndexTM<int,SpaceDim> zeroDerivative = IndexTM<int,SpaceDim>::Zero;

  map<IndexTM<int,SpaceDim>,
      IndexTM<Real,SpaceDim>,
      LexLT<IndexTM<int,SpaceDim> > >::const_iterator iter =
        m_cutCellMoments.m_IFData.m_normalDerivatives.find(zeroDerivative);

  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      normal[idir] = iter->second[idir];
    }

 return normal;
}

//fillvolCentroid
RealVect NewGeometryShop::fillvolCentroid()const
{
  EBorVol momentMap = VolMoment;

  //returns IndexTM physical coordinates
  RealVect cutCellCentroidPhysCoord = m_cutCellMoments.getCentroid(momentMap);

  //returns RealVect coordinates relative to cell center
  RealVect centroid = convert2RelativeCoord(cutCellCentroidPhysCoord);

  return centroid;
}

//fillbndryCentroid
RealVect NewGeometryShop::fillBndryCentroid()const
{
  EBorVol momentMap = EBMoment;

  //returns IndexTM physical coordinates
  RealVect cutCellCentroidPhysCoord = m_cutCellMoments.getCentroid(momentMap);

  //returns realvect relative to m_currIv
  RealVect centroid = convert2RelativeCoord(cutCellCentroidPhysCoord);
  return(centroid);
}

//fillLoFaceCentroid
void NewGeometryShop::fillFaceCentroid(Vector<RealVect>  a_faceCentroid[SpaceDim],
                                      const int       & a_hilo)const
{
//volume moments of coordinate aligned faces
  EBorVol momentMap = VolMoment;

  Iv2 bdId;
  bdId[BDID_HILO] = a_hilo;
  for (int idir = 0; idir < SpaceDim ;++ idir)
    {
      bdId[BDID_DIR] = idir;
      bool covered = m_cutCellMoments.getBdCutCellMoments(bdId).isCovered();
       if (!covered)
        {
          a_faceCentroid[idir].resize(1);

          IndexTM<Real,SpaceDim - 1>centroidRel2FacePhysCoord;
          //returns IndexTM in physical (SpaceDim-1) coordinates
          centroidRel2FacePhysCoord = m_cutCellMoments.getBdCutCellMoments(bdId).getCentroid(momentMap);
          //assigns SpaceDim-1 values to the appropriate components of a RealVect
          RealVect centroidPhysCoord;

          centroidPhysCoord[idir] = 0.0;
          for (int jdir = 0; jdir < SpaceDim; ++jdir)
            {
              if (jdir < idir)
                {
                  centroidPhysCoord[jdir] = centroidRel2FacePhysCoord[jdir];
                }
              else if (jdir > idir)
                {
                  centroidPhysCoord[jdir] = centroidRel2FacePhysCoord[jdir - 1];
                }
            }
          //returns values relative to the cell center
          RealVect centroid = convert2RelativeCoord(centroidPhysCoord);
          a_faceCentroid[idir][0] = centroid;
        }
      else
        {
          a_faceCentroid[idir].resize(0);
        }
    }
}
//fillLoFaceCentroid
void NewGeometryShop::fillLoFaceCentroid(Vector<RealVect>a_loFaceCentroid[SpaceDim])const
{
  int hilo = 0;
  fillFaceCentroid(a_loFaceCentroid,hilo);
}

  //fillHiFaceCentroid
void NewGeometryShop::fillHiFaceCentroid(Vector<RealVect>a_hiFaceCentroid[SpaceDim])const
{
 int hilo = 1;
 fillFaceCentroid(a_hiFaceCentroid,hilo);
}


//takes RealVect physical coordinates to coordinates relative to m_currIv
RealVect NewGeometryShop::convert2RelativeCoord(const RealVect& a_rVect)const
{
  //rvect[idir] = dx*(iv[idir] + 0.5 + relCoord[idir]) + origin[idir]
  RealVect retval;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      // retval[idir] = a_rVect[idir] - m_origin[idir];
      retval[idir] = a_rVect[idir] /  m_vectDx[idir];
      //retval[idir] -= (m_currIv[idir] + 0.5);
    }

  return retval;
}

//takes IndexTM physical coordinates to coordinates relative to m_currIv
RealVect NewGeometryShop::convert2RelativeCoord(const IndexTM<Real,SpaceDim>& a_rVect)const
{
  //rvect[idir] = dx*(iv[idir] + 0.5 + relCoord[idir]) + origin[idir]
  RealVect retval;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      // retval[idir] = a_rVect[idir] - m_origin[idir];
      retval[idir] = a_rVect[idir] / m_vectDx[idir];
      //      retval[idir] -= (m_currIv[idir] + 0.5);
    }
  return retval;
}

//next four functions take RealVect and IntVect to IndexTM and viseVersa
IndexTM<Real,SpaceDim>NewGeometryShop::convertRealVect2IndexTM(const RealVect& a_realVect)const
{
  IndexTM<Real,SpaceDim> retval;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      retval[idir] = a_realVect[idir];
    }
  return retval;
}
//2 of 4
RealVect NewGeometryShop::convertIndexTM2RealVect(const IndexTM<Real,SpaceDim>& a_indexTm)const
{
  RealVect retval;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      retval[idir] = a_indexTm[idir];
    }
  return retval;
}
//3 of 4
IndexTM<int,SpaceDim>NewGeometryShop::convertIntVect2IndexTM(const IntVect& a_intVect)const
{
  IndexTM<int,SpaceDim> retval;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      retval[idir] = a_intVect[idir];
    }
  return retval;
}

//4 of 4
IntVect NewGeometryShop::convertIndexTM2IntVect(const IndexTM<int,SpaceDim>& a_indexTm)const
{
  IntVect retval;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      retval[idir] = a_indexTm[idir];
    }
  return retval;
}
void NewGeometryShop::clipComputedVal(Real            &    a_volFrac,
                                     Vector<Real>         a_loAreaFrac[SpaceDim],
                                     Vector<Real>         a_hiAreaFrac[SpaceDim],
                                     Real            &    a_bndryArea,
                                     RealVect        &    a_volCentroid,
                                     RealVect        &    a_bndryCentroid,
                                     Vector<RealVect>     a_loFaceCentroid[SpaceDim],
                                     Vector<RealVect>     a_hiFaceCentroid[SpaceDim],
                                     const IntVect   &    a_iv)const

{

  //clipping
  //only report adjustments when discrepancy is above the threshold
  bool thisVofClipped = false;
  Real discrepancy = 0.0;
  Real volDiscrepancy = 0.0;
  //volFrac out of bounds
  if (a_volFrac < 0.0)
    {
      volDiscrepancy = Abs(a_volFrac);
      char message[1024];
      if (SpaceDim ==2)
        {
          sprintf(message,"vol fraction (%e) out of bounds. Clipping: (%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1]);
        }
      else if (SpaceDim == 3)
        {
          sprintf(message,"vol frac (%e) out of bounds. Clipping: (%d,%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1],a_iv[2]);
        }
      else
        {
          sprintf(message,"SpaceDim not 2 or 3");
        }

      if (volDiscrepancy > m_threshold)
        {
          pout() << message << endl;
        }
      //do the clipping
      thisVofClipped = true;
      a_volFrac = -a_volFrac;
    }

  if (a_volFrac > 1.0)
    {
      volDiscrepancy = Abs(1.0 - a_volFrac);
      char message[1024];
      if (SpaceDim ==2)
        {
          sprintf(message,"vol fraction (%e) out of bounds. Clipping: (%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1]);
        }
      else if (SpaceDim == 3)
        {
          sprintf(message,"vol frac (%e) out of bounds. Clipping: (%d,%d,%d)",
                  a_volFrac,a_iv[0],a_iv[1],a_iv[2]);
        }
      else
        {
          sprintf(message,"SpaceDim not 2 or 3");
        }
      if (volDiscrepancy>m_threshold)
        {
          pout() << message << endl;
        }
      //do the clipping
      thisVofClipped = true;
      a_volFrac = 1.0;
    }

  //area frac out of bounds
  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_loAreaFrac[idir].size();num ++)
        {
          //lo frac too high
          if (a_loAreaFrac[idir][num] > 1.0)
            {
              discrepancy = Abs(1 - a_loAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold)
                {
                  pout() << message << endl;
                }

              //do the clipping
              thisVofClipped = true;
              a_loAreaFrac[idir][num] = 1.0;
            }
          //lo frac too low
          if (a_loAreaFrac[idir][num] < 0.0)
            {
              discrepancy = Abs(a_loAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"lo area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_loAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold)
                {
                  pout() << message << endl;
                }

              //do the clipping
              thisVofClipped = true;
              a_loAreaFrac[idir][num] = -a_loAreaFrac[idir][num];
            }

        }
    }

  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_hiAreaFrac[idir].size();num ++)
        {
          //hi frac too high
          if (a_hiAreaFrac[idir][num] > 1.0)
            {
              discrepancy = Abs(1 - a_hiAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold)
                {
                  pout() << message << endl;
                }

              //do the clipping
              thisVofClipped = true;
              a_hiAreaFrac[idir][num] = 1.0;
            }
          //hi frac too low
          if (a_hiAreaFrac[idir][num] < 0.0)
            {
              discrepancy = Abs(a_hiAreaFrac[idir][num]);
              char message[1024];
              if (SpaceDim ==2)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1]);
                }
              else if (SpaceDim == 3)
                {
                  sprintf(message,"hi area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                          a_hiAreaFrac[idir][num],a_iv[0],a_iv[1],a_iv[2]);
                }
              else
                {
                  sprintf(message,"SpaceDim not 2 or 3");
                }
              if (discrepancy>m_threshold)
                {
                  pout() << message << endl;
                }

              //do the clipping
              thisVofClipped = true;
              a_hiAreaFrac[idir][num] = -a_hiAreaFrac[idir][num];
            }

        }

    }

  //bndry area out of bounds
  if (a_bndryArea < 0.0)
    {
      discrepancy = Abs(a_bndryArea);
      char message[1024];
      if (SpaceDim ==2)
        {
          sprintf(message,"boundary area fraction (%e) out of bounds. Clipping: (%d,%d)",
                  a_bndryArea,a_iv[0],a_iv[1]);
        }
      else if (SpaceDim == 3)
        {
          sprintf(message,"boundary area fraction (%e) out of bounds. Clipping: (%d,%d,%d)",
                  a_bndryArea,a_iv[0],a_iv[1],a_iv[2]);
        }
      else
        {
          sprintf(message,"SpaceDim not 2 or 3");
        }
      if (discrepancy>m_threshold)
        {
          pout() << message << endl;
        }

      //do the clipping
      thisVofClipped = true;
      a_bndryArea = 0.0;
    }

  //volCentroid out of bounds
  for (int idir =0;idir<SpaceDim;++idir)
    {
      if (a_volCentroid[idir] > 0.5)
        {
          discrepancy = Abs(0.5 - a_volCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"volCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"volCentroid(%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy>m_threshold)
            {
              pout() << message << endl;
            }
          //do the clipping
          thisVofClipped = true;
          a_volCentroid[idir] = 0.5;
        }
      if (a_volCentroid[idir] < -0.5)
        {
          discrepancy = Abs(-0.5 - a_volCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"volCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"volCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_volCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy > m_threshold)
            {
              pout() << message << endl;
            }
          //do the clipping
          thisVofClipped = true;
          a_volCentroid[idir] = -0.5;
        }

      //boundary centroid out of bounds
      if (a_bndryCentroid[idir] > 0.5)
        {
          discrepancy = Abs(0.5 - a_bndryCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"bndryCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"boundary Centroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy>m_threshold)
            {
              pout() << message << endl;
            }
          //do the clipping
          thisVofClipped = true;
          a_bndryCentroid[idir] = 0.5;
        }

      if (a_bndryCentroid[idir] < -0.5)
        {
          discrepancy = Abs(-0.5 - a_bndryCentroid[idir]);
          char message[1024];
          if (SpaceDim ==2)
            {
              sprintf(message,"bndryCentroid (%e) out of bounds. Clipping: (%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1]);
            }
          else if (SpaceDim == 3)
            {
              sprintf(message,"bndryCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                      a_bndryCentroid[idir],a_iv[0],a_iv[1],a_iv[2]);
            }
          else
            {
              sprintf(message,"SpaceDim not 2 or 3");
            }
          if (discrepancy > m_threshold)
            {
              pout() << message << endl;
            }
          //do the clipping
          thisVofClipped = true;
          a_bndryCentroid[idir] = -0.5;
        }
    }
  //loFaceCentroid out of bounds
  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_loFaceCentroid[idir].size();num ++)
        {
          for (int jdir = 0; jdir<SpaceDim; ++jdir)
            {
              if (jdir != idir)
                {
                  if (a_loFaceCentroid[idir][num][jdir] > 0.5)
                    {
                      discrepancy = Abs(0.5 - a_loFaceCentroid[idir][num][jdir]);
                      char message[1024];
                      if (SpaceDim ==2)
                        {
                          sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                                  a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                        }
                      else if (SpaceDim == 3)
                        {
                          sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                                  a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                        }
                      else
                        {
                          sprintf(message,"SpaceDim not 2 or 3");
                        }
                      if (discrepancy > m_threshold)
                        {
                          pout() << message << endl;
                        }
                      //do the clipping
                      thisVofClipped = true;
                      a_loFaceCentroid[idir][num][jdir] = 0.5;
                    }
                  if (a_loFaceCentroid[idir][num][jdir] < -0.5)
                    {
                      discrepancy = Abs(-0.5 - a_loFaceCentroid[idir][num][jdir]);
                      char message[1024];
                      if (SpaceDim ==2)
                        {
                          sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                                  a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                        }
                      else if (SpaceDim == 3)
                        {
                          sprintf(message,"loFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                                  a_loFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                        }
                      else
                        {
                          sprintf(message,"SpaceDim not 2 or 3");
                        }
                      if (discrepancy > m_threshold)
                        {
                          pout() << message << endl;
                        }
                      //do the clipping
                      thisVofClipped = true;
                      a_loFaceCentroid[idir][num][jdir] = -0.5;
                    }
                }
            }
        }
    }
  //hiFaceCentroid out of bounds
  for (int idir = 0; idir<SpaceDim; ++idir)
    {
      for (int num = 0; num < a_hiFaceCentroid[idir].size();num ++)
        {
          for (int jdir = 0; jdir<SpaceDim; ++jdir)
            {
              if (jdir != idir)
                {
                  if (a_hiFaceCentroid[idir][num][jdir] > 0.5)
                    {
                      discrepancy = Abs(0.5 - a_hiFaceCentroid[idir][num][jdir]);
                      char message[1024];
                      if (SpaceDim ==2)
                        {
                          sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                                  a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                        }
                      else if (SpaceDim == 3)
                        {
                          sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                                  a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                        }
                      else
                        {
                          sprintf(message,"SpaceDim not 2 or 3");
                        }
                      if (discrepancy > m_threshold)
                        {
                          pout() << message << endl;
                        }
                      //do the clipping
                      thisVofClipped = true;
                      a_hiFaceCentroid[idir][num][jdir] = 0.5;
                    }
                  if (a_hiFaceCentroid[idir][num][jdir] < -0.5)
                    {
                      discrepancy = Abs(0.5 - a_hiFaceCentroid[idir][num][jdir]);
                      char message[1024];
                      if (SpaceDim ==2)
                        {
                          sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d)",
                                  a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1]);
                        }
                      else if (SpaceDim == 3)
                        {
                          sprintf(message,"hiFaceCentroid (%e) out of bounds. Clipping: (%d,%d,%d)",
                                  a_hiFaceCentroid[idir][num][jdir],a_iv[0],a_iv[1],a_iv[2]);
                        }
                      else
                        {
                          sprintf(message,"SpaceDim not 2 or 3");
                        }
                      if (discrepancy > m_threshold)
                        {
                          pout() << message << endl;
                        }
                      //do the clipping
                      thisVofClipped = true;
                      a_hiFaceCentroid[idir][num][jdir] = -0.5;
                    }
                }

              if (thisVofClipped)
                {
                  NewGeometryShop* changedThis = (NewGeometryShop *) this;
                  changedThis->m_numCellsClipped += 1;
                }
            }
        }
    }
}
int NewGeometryShop::getNumCellsClipped()
{
  return m_numCellsClipped;
}

#if RECURSIVE_GEOMETRY_GENERATION == 0
void NewGeometryShop::outputResidual(int & type,int & a_degreeP)const
#else
void NewGeometryShop::outputResidual(int & type,int & a_degreePmax)const
#endif
{
// Only create these in serial since they aren't distributed in parallel and
// this causes parallel runs to fail when the domain gets large enough.  This
// needs a better long-term fix.
#ifndef CH_MPI
  if (type == 0)
    {
#ifdef CH_USE_HDF5
      const char name[] = "Residual.hdf5";
      int nComp = 15;
      Vector<string> labels(nComp);
#if RECURSIVE_GEOMETRY_GENERATION == 0
      for (int iDegree = 0 ; iDegree <= a_degreeP ; iDegree++)
#else
      for (int iDegree = 0 ; iDegree <= a_degreePmax; iDegree++)
#endif
        {
          for (int iRes = 0 ; iRes < 3 ; iRes ++)
            {
              char labelChSt[80];
              sprintf(labelChSt, "ResidualsDegree_%d Norm_%d", iDegree,iRes);
              string label(labelChSt);
              labels[iDegree*3 + iRes] = label;
            }
        }
      writeFABname(&m_residuals,name,labels);
#endif
    }
  else
    {
#if RECURSIVE_GEOMETRY_GENERATION == 0
      for (int iDegree = 0 ; iDegree <=a_degreeP; iDegree++)
#else
      for (int iDegree = 0 ; iDegree <= a_degreePmax; iDegree++)
#endif
        {
          for (int iRes = 0 ; iRes < 3; iRes++)
            {
              Real res = m_residuals.norm(iRes,iDegree*3+iRes);
              pout()<<"Residual["<<iDegree*3+iRes<<"]="<<res<<endl;
            }
        }
    }
#endif
}

void NewGeometryShop::outputGradNormal()const
{
// Only create these in serial since they aren't distributed in parallel and
// this causes parallel runs to fail when the domain gets large enough.  This
// needs a better long-term fix.
#ifndef CH_MPI
#ifdef CH_USE_HDF5
  const char name[] = "GradNormal.hdf5";
  writeFABname(&m_gradNormal,name);
#endif
#endif
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "GaussianIF.H"

#include "NamespaceHeader.H"

GaussianIF::GaussianIF(const RealVect& a_origin,
                       const Real&     a_height,
                       const RealVect& a_sig2,
                       const int&      a_upDir,
                       const bool&     a_inside)
{
  // Remember the parameters
  m_origin = a_origin;
  m_height = a_height;
  m_sig2   = a_sig2;
  m_upDir  = a_upDir;
  m_inside = a_inside;
}

GaussianIF::GaussianIF(const GaussianIF& a_inputIF)
{
  // Remember the parameters
  m_origin = a_inputIF.m_origin;
  m_height = a_inputIF.m_height;
  m_sig2   = a_inputIF.m_sig2;
  m_upDir  = a_inputIF.m_upDir;
  m_inside = a_inputIF.m_inside;
}

GaussianIF::~GaussianIF()
{
}

void GaussianIF::GetParams(RealVect& a_origin,
                           Real&     a_height,
                           RealVect& a_sig2,
                           int&      a_upDir,
                           bool&     a_inside) const
{
  // Copy parameter information over
  a_origin = m_origin;
  a_height = m_height;
  a_sig2   = m_sig2;
  a_upDir  = m_upDir;
  a_inside = m_inside;
}

void GaussianIF::SetParams(const RealVect& a_origin,
                           const Real&     a_height,
                           const RealVect& a_sig2,
                           const int&      a_upDir,
                           const bool&     a_inside)
{
  // Set parameter information
  m_origin = a_origin;
  m_height = a_height;
  m_sig2   = a_sig2;
  m_upDir  = a_upDir;
  m_inside = a_inside;
}

Real GaussianIF::value(const RealVect& a_point) const
{
  Real retval = 0.0;

  for (int idir = 0; idir < SpaceDim; idir++)
    {
      if (idir != m_upDir)
        {
          retval += pow(a_point[idir]-m_origin[idir],2)/(-2.0*m_sig2[idir]);
        }
    }

  retval  = exp(retval);
  retval *= m_height;
  retval -= (a_point[m_upDir]-m_origin[m_upDir]);

  // Change the sign to change inside to outside
  if (!m_inside)
    {
      retval = -retval;
    }

  CH_assert(!std::isnan(retval) && !std::isinf(retval));

  return retval;
}

BaseIF* GaussianIF::newImplicitFunction() const
{
  GaussianIF* gaussianPtr = new GaussianIF(m_origin,
                                           m_height,
                                           m_sig2,
                                           m_upDir,
                                           m_inside);

  return static_cast<BaseIF*>(gaussianPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "RhodoneaIF.H"

#include "NamespaceHeader.H"

RhodoneaIF::RhodoneaIF(const Real&     a_innerRadius,
                       const Real&     a_outerRadius,
                       const int&      a_frequency,
                       const RealVect& a_center,
                       const bool&     a_inside)
{
  CH_assert(SpaceDim == 2);
  CH_assert(a_innerRadius > 0.);
  CH_assert(a_outerRadius > 0.);
  CH_assert(a_frequency != 0);

  // Remember the parameters
  m_innerRadius = a_innerRadius;
  m_outerRadius = a_outerRadius;
  m_frequency   = a_frequency;
  m_center = a_center;
  m_inside = a_inside;
}

RhodoneaIF::RhodoneaIF(const RhodoneaIF& a_inputIF)
{
  // Remember the parameters
  m_innerRadius = a_inputIF.m_innerRadius;
  m_outerRadius = a_inputIF.m_outerRadius;
  m_frequency   = a_inputIF.m_frequency;
  m_center = a_inputIF.m_center;
  m_inside = a_inputIF.m_inside;
}

RhodoneaIF::~RhodoneaIF()
{
  CH_assert(SpaceDim == 2);
}

void RhodoneaIF::GetParams(Real&     a_innerRadius,
                           Real&     a_outerRadius,
                           int&      a_frequency,
                           RealVect& a_center,
                           bool&     a_inside) const
{
  // Copy parameter information over
  a_innerRadius = m_innerRadius;
  a_outerRadius = m_outerRadius;
  a_frequency   = m_frequency;
  a_center = m_center;
  a_inside = m_inside;
}

void RhodoneaIF::SetParams(const Real&     a_innerRadius,
                           const Real&     a_outerRadius,
                           const int&      a_frequency,
                           const RealVect& a_center,
                           const bool&     a_inside)
{
  CH_assert(a_innerRadius > 0.);
  CH_assert(a_outerRadius > 0.);
  CH_assert(a_frequency != 0);

  // Set parameter information
  m_innerRadius = a_innerRadius;
  m_outerRadius = a_outerRadius;
  m_frequency   = a_frequency;
  m_center = a_center;
  m_inside = a_inside;
}

Real RhodoneaIF::value(const RealVect& a_point) const
{
  Real retval;

  // Compute polar coordinates of this point, relative to center
  Real rad = 0.;
  for (int idir=0; idir<SpaceDim; idir++)
    {
      Real cur = a_point[idir]-m_center[idir];
      rad += cur*cur;
    }
  rad = sqrt(rad);
  Real theta = atan2(a_point[1]-m_center[1],a_point[0]-m_center[0]);

  // Compute the radius of the rhodonea at this theta
  Real rRhod = m_innerRadius + m_outerRadius*sin(m_frequency*theta);

  // The ratio should be 1.0 on the surface of the rhodonea
  Real ratio = rad/rRhod;

  retval = ratio - 1.0;

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

BaseIF* RhodoneaIF::newImplicitFunction() const
{
  RhodoneaIF* ellipsoidPtr = new RhodoneaIF(m_innerRadius,
                                            m_outerRadius,
                                            m_frequency,
                                            m_center,
                                            m_inside);

  return static_cast<BaseIF*>(ellipsoidPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "PolyGeom.H"
#include "TiltedCylinderIF.H"

#include "NamespaceHeader.H"

TiltedCylinderIF::TiltedCylinderIF(const Real&     a_radius,
                                   const RealVect& a_direction,
                                   const RealVect& a_point,
                                   const bool&     a_inside)
{
  SetParams(a_radius,a_direction,a_point,a_inside);
}

TiltedCylinderIF::TiltedCylinderIF(const TiltedCylinderIF& a_inputIF)
{
  // Remember the parameters
  m_radius = a_inputIF.m_radius;
  m_direction = a_inputIF.m_direction;
  m_tiltedAxis = a_inputIF.m_tiltedAxis;
  m_coordDir = a_inputIF.m_coordDir;
  m_point = a_inputIF.m_point;
  m_inside = a_inputIF.m_inside;

  // Precompute the radius squared
  m_radius2 = m_radius * m_radius;

  // Precompute the length squared of the direction vector
  m_length2 = PolyGeom::dot(m_direction,m_direction);
}

TiltedCylinderIF::~TiltedCylinderIF()
{
}

GeometryService::InOut TiltedCylinderIF::InsideOutside(const RealVect& lo,
                                                       const RealVect& hi) const
{

  // Fast Sphere-Box intersection from "Graphics Gems" pp 335-338, 1990

  Real dmin = 0; //distance from cylinder axis to nearest  point in box (squared)
  Real dmax = 0; //distance from cylinder axis to farthest point in box (squared)
  Real ai, bi, a, b;

  Tuple<int,CH_SPACEDIM-1> tanDirs = PolyGeom::computeTanDirs(m_coordDir);
  for (int i=0; i<CH_SPACEDIM-1; ++i)
    {
      ai = m_point[tanDirs[i]] - lo[tanDirs[i]];
      bi = m_point[tanDirs[i]] - hi[tanDirs[i]];
      a = ai * ai;
      b = bi * bi;
      dmax = dmax + Max(a,b);
      if (m_point[tanDirs[i]] < lo[tanDirs[i]] || m_point[tanDirs[i]] > hi[tanDirs[i]]) dmin = dmin + Min(a,b);
    }

  if (m_inside)
    {
      if (dmin >= m_radius2) return GeometryService::Covered;
      if (dmax <  m_radius2) return GeometryService::Regular;
    }
  else
    {
      if (dmin >  m_radius2) return GeometryService::Regular;
      if (dmax <= m_radius2) return GeometryService::Covered;
    }
  return GeometryService::Irregular;
}


void TiltedCylinderIF::GetParams(Real&     a_radius,
                                 RealVect& a_direction,
                                 RealVect& a_point,
                                 bool&     a_inside) const
{
  // Copy parameter information over
  a_radius = m_radius;
  a_direction = m_direction;
  a_point = m_point;
  a_inside = m_inside;
}

void TiltedCylinderIF::SetParams(const Real&     a_radius,
                                 const RealVect& a_direction,
                                 const RealVect& a_point,
                                 const bool&     a_inside)
{
  // Set parameter information
  m_radius = a_radius;
  m_direction = a_direction;
  m_point = a_point;
  m_inside = a_inside;

  // Precompute the radius squared
  m_radius2 = m_radius * m_radius;

  // Precompute the length squared of the direction vector
  m_length2 = PolyGeom::dot(m_direction,m_direction);

  m_tiltedAxis = true;

  for (int i=0; i<CH_SPACEDIM; ++i)
    {
      if (m_direction[i] != 0.0)
        {
          bool idDirection = true;
          Tuple<int,CH_SPACEDIM-1> tanDirs = PolyGeom::computeTanDirs(i);
          for (int itan = 0; itan < CH_SPACEDIM-1; itan++)
            {
              if (m_direction[tanDirs[itan]] != 0.0)
                {
                  idDirection = false;
                }
            }

          if (idDirection)
            {
              m_tiltedAxis = false;
              m_coordDir = i;
            }
        }
    }
}

Real TiltedCylinderIF::value(const RealVect& a_point) const
{
  Real retval;

  // Get a_point relative to a point on the cylinder's axis, m_point
  RealVect delta;

  delta = a_point;
  delta -= m_point;

  // Get the dot product of the relative vector (above) and the cylinder's
  // axis vector and normalize by the square of the length of the direction
  // vector
  Real dot = PolyGeom::dot(m_direction,delta);
  dot /= m_length2;

  // Find the vector from a_point to the point on the cylinder's axis closest
  // to a_point
  RealVect closest;

  closest = m_direction;
  closest *= dot;
  closest -= delta;

  // Find the length squared of this vector and compare it to the radius
  // squared
  Real length2 = PolyGeom::dot(closest,closest);

  // Return the difference between the sqaures (zero on the cylinder)
  retval = length2 - m_radius2;

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

BaseIF* TiltedCylinderIF::newImplicitFunction() const
{
  TiltedCylinderIF* tiltedCylinderPtr = new TiltedCylinderIF(m_radius,
                                                             m_direction,
                                                             m_point,
                                                             m_inside);

  return static_cast<BaseIF*>(tiltedCylinderPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#if defined(CH_Darwin) && defined(__GNUC__) && ( __GNUC__ == 3 )
// deal with the broken isnan()/isinf() in GCC on MacOS
#include <unistd.h>
#define _GLIBCPP_USE_C99 1
#endif

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>
#include "GeometryService.H"
#include "GeometryShop.H"
#include "Moments.H"
#include "LSquares.H"
#include "PolyGeom.H"
#include "RealVect.H"
#include "CH_Timer.H"

#include "NamespaceHeader.H"

/*************/
// edgeMo Methods //
void edgeMo::define(const RealVect& a_loPt,
                    const RealVect& a_hiPt,
                    const bool& a_intersectLo,
                    const int& a_direction,
                    const bool& a_covered,
                    const bool& a_regular,
                    const bool& a_dontKnow)
{
  m_Lo = a_loPt;
  m_Hi = a_hiPt;
  m_intersectLo = a_intersectLo;

  m_varOfInt = a_direction;

  m_edgeLength = m_Hi[m_varOfInt] - m_Lo[m_varOfInt];

  RealVect temp = m_Hi;
  temp += m_Lo;
  temp /= 2.0;

  m_edgeCentroid = temp;

  m_covered  = a_covered;
  m_regular  = a_regular;
  m_dontKnow = a_dontKnow;
}
/*************/
RealVect edgeMo::getLo() const
{
  return m_Lo;
}
/*************/
RealVect edgeMo::getHi() const
{
  return m_Hi;
}
/*************/
bool edgeMo::getIntersectLo() const
{
  return m_intersectLo;
}
/*************/

Real edgeMo::getEdgeLength() const
{
  return m_edgeLength;
}
/*************/

RealVect edgeMo::getEdgeCentroid() const
{
  return m_edgeCentroid;
}

/*************/
// access the member data
bool edgeMo::isCovered() const
{
  return m_covered;
}

bool edgeMo::isRegular() const
{
  return m_regular;
}

bool edgeMo::dontKnow() const
{
  return m_dontKnow;
}

int edgeMo::direction() const
{
  return m_varOfInt;
}

// caclulate moments
Real edgeMo::moment(const IntVect& a_exponent) const
{
  IntVect exp = a_exponent;

  exp[m_varOfInt] += 1;

  Real plusOne = exp[m_varOfInt];

  Real lo = 1.0;
  Real hi = 1.0;

  for (int idir = 0; idir < SpaceDim; idir++)
  {
    int num = exp[idir];
    Real curLo = m_Lo[idir];
    Real curHi = m_Hi[idir];

    for (int i = 0; i < num; i++)
    {
      lo *= curLo;
      hi *= curHi;
    }
  }

  return (hi - lo) / plusOne; // plusOne should be at least 1
}

// faceMo Methods //
void faceMo::define(const edgeMo a_edges[4],
                    const int& a_faceNormal,
                    const bool& a_covered,
                    const bool& a_regular,
                    const bool& a_dontKnow)
{
  for (int i = 0; i < 4; i++)
    {
      m_edges[i] = a_edges[i];
    }

  m_faceNormal = a_faceNormal;

  m_covered  = a_covered;
  m_regular  = a_regular;
  m_dontKnow = a_dontKnow;

  makeNormal();
}

// area
void faceMo::setFaceArea(const Real& a_area)
{
  m_areaFrac = a_area;
}

Real faceMo::getFaceArea() const
{
  return m_areaFrac;
}

// centroid
void faceMo::setFaceCentroid(const RealVect& a_centroid)
{
  m_centroid = a_centroid;
}

RealVect faceMo::getFaceCentroid() const
{
  return m_centroid;
}

// facetype
bool faceMo::isRegular() const
{
  return m_regular;
}

bool faceMo::isCovered() const
{
  return m_covered;
}

bool faceMo::dontKnow() const
{
  return m_dontKnow;
}

// bndLength
Real faceMo::getBdLength() const
{
  return m_bdLength;
}

// normal
void faceMo::getNormal(Real a_normal[2]) const
{
  for (int i = 0; i < 2; i++)
    {
      a_normal[i] = m_normalVec[i];
    }
}

// edges
void faceMo::getEdges(edgeMo a_Edges[4]) const
{
  for (int i = 0; i < 4; i++)
    {
      a_Edges[i] = m_edges[i];
    }
}

edgeMo faceMo::retrieveEdge(int& a_iEdge) const
{
  return m_edges[a_iEdge];
}

// faceNormal
int faceMo::getFaceNormal()const
{
  return m_faceNormal;
}

// construct normal vector
void faceMo::makeNormal()
{
  IntVect zeros = IntVect::Zero;

  for (int index = 0; index < 2; ++index)
    {
      edgeMo HiEdge = m_edges[2*index + 1];
      edgeMo LoEdge = m_edges[2*index];

      m_normalVec[index] = (HiEdge.moment(zeros) - LoEdge.moment(zeros));
    }

  // this sets m_bdlength, too
  normalize(m_normalVec);
}

// also set m_bdLength
void faceMo::normalize(Real a_normalVec[2])
{
  m_bdLength = 0.0;
  for (int index = 0; index < 2; ++index)
    {
      m_bdLength += a_normalVec[index] * a_normalVec[index];
    }

  if (m_bdLength == 0.0)
    {
      return;
    }

  m_bdLength = sqrt(m_bdLength);
  for (int idir = 0; idir < 2; ++idir)
    {
      a_normalVec[idir] /= m_bdLength;
    }
}

// vofMo Methods
void vofMo::define(const faceMo a_faces[6])
{
  for (int i = 0; i < 6; ++i)
    {
      edgeMo edges[4];
      a_faces[i].getEdges(edges);

      bool covered  = a_faces[i].isCovered();
      bool regular  = a_faces[i].isRegular();
      bool dontKnow = a_faces[i].dontKnow();

      int faceNormal = a_faces[i].getFaceNormal();

      m_faces[i].define(edges,faceNormal,covered,regular,dontKnow);
    }
  makeNormal();
}

void vofMo::makeNormal()
{
  int order = 0;
  for (int index = 0; index < 3; ++index)
    {
      Moments geom;

      faceMo& HiFace = m_faces[2*index+1];
      faceMo& LoFace = m_faces[2*index];

      Real hiArea = geom.momentCalc2D(order,HiFace)[0];
      Real loArea = geom.momentCalc2D(order,LoFace)[0];

      m_normalVec[index] = hiArea - loArea;
    }

  // this sets m_bdArea, too
  normalize(m_normalVec);
}

void vofMo::setNormal(Real a_normalVec[3])
{
  for (int i = 0; i < 3; i++)
    {
      m_normalVec[i] = a_normalVec[i];
    }
}

void  vofMo::getNormal(Real a_normalVec[3]) const
{
  for (int idir = 0; idir < 3; idir++)
    {
      a_normalVec[idir] = m_normalVec[idir];
    }
}

void vofMo::normalize(Real a_normalVec[3])
{
  m_bdArea = 0.0;
  for (int idir = 0; idir < SpaceDim; ++idir)
    {
      m_bdArea += a_normalVec[idir] * a_normalVec[idir];
    }

  m_bdArea = sqrt(m_bdArea);

  if (m_bdArea != 0.0)
    {
      for (int idir = 0; idir < SpaceDim; ++idir)
        {
          a_normalVec[idir] /= m_bdArea;
        }
    }

  setNormal(a_normalVec);
}

void vofMo::getFaces(faceMo a_faces[6]) const
{
  for (int i = 0; i < 6; ++i)
    {
      edgeMo edges[4];
      m_faces[i].getEdges(edges);

      int faceNormal = m_faces[i].getFaceNormal();

      bool regular  = m_faces[i].isRegular();
      bool covered  = m_faces[i].isCovered();
      bool dontKnow = m_faces[i].dontKnow();

      a_faces[i].define(edges,faceNormal,covered,regular,dontKnow);
    }
}

Real vofMo::getBdArea() const
{
  return m_bdArea;
}

// Moments Methods //
Moments::Moments()
{
}

Vector<Real> Moments::momentCalc3D(const int& a_order,
                                   vofMo&     a_vof)
{
  CH_TIME("momentCalc3D");
  Vector<IntVect> list(0),listPlus(0);
  listOfMoments(a_order,list);       // this function knows SpaceDim
  listOfMoments(a_order+1,listPlus);

  Real** A;
  int numRows = listPlus.size()*SpaceDim;
  int numCols = listPlus.size()+list.size();

  LSquares tools;
  tools.allocArray(numRows,numCols,A);

  Real normalVec[3];
  a_vof.getNormal(normalVec);

  Vector<Real> normal(3);
  for (int idir = 0; idir < 3; ++idir)
    {
      normal[idir] = normalVec[idir];
    }

  makeMatrix(list,listPlus,normal,A);

  Vector<Real> rhs(numRows);
  Vector<Real> x(numCols);
  Vector<Real> answer(numRows);
  Vector<Real> answer2DHi;
  Vector<Real> answer2DLo;

  for (int jdir=0;jdir<3;jdir++)
    {

      faceMo faces[6];
      a_vof.getFaces(faces);

      faceMo& hiFace = faces[2*jdir+1];
      faceMo& loFace = faces[2*jdir];

      if (hiFace.isCovered())
      {
        answer2DHi.resize(listPlus.size());

        for (int count = 0; count < listPlus.size(); count++)
        {
          answer2DHi[count] = 0.0;
        }
      }
      else
      {
        answer2DHi = momentCalc2D(a_order+1,hiFace);
      }

      if (loFace.isCovered())
      {
        answer2DLo.resize(listPlus.size());

        for (int count = 0; count < listPlus.size(); count++)
        {
          answer2DLo[count] = 0.0;
        }
      }
      else
      {
        answer2DLo = momentCalc2D(a_order+1,loFace);
      }

      for (int count=0;count<listPlus.size();count++)
        // numRows = length of rhs
        {
          rhs[count*3 + jdir] += answer2DHi[count] -  answer2DLo[count];
        }
    }

  LSquares whichMethod;
  whichMethod.LeastSquares(A,x,rhs);

  tools.freeArray(numRows,numCols,A);

  return x;
}

Vector<Real> Moments::momentCalc2D(const int&    a_order,
                                   const faceMo& a_face)
{
  CH_TIME("momentCalc2D");
  // 2 vector because 2D, even if SpaceDim=3
  Vector<Real> normal(2);
  Real normalVec[2];

  a_face.getNormal(normalVec);

  for (int j = 0; j < 2; j++)
    {
      normal[j] = (normalVec[j]);
    }

  int faceNormal = a_face.getFaceNormal();

  Vector<IntVect> list(0),listPlus(0);
  listOfMoments(a_order,list); // this function knows SpaceDim
  listOfMoments(a_order+1,listPlus);

  Real** A;
  int numRows = listPlus.size() * 2; // this is a 2 because faces are 2D. If SpaceDim=3 we iterate
  // over SpaceDim and exclude the case where idir = facenormal because the div theorem wouldn't
  // make sense in this context

  int numCols = listPlus.size()+list.size();
  LSquares tools;

  tools.allocArray(numRows,numCols,A);
  int sizeBig = listPlus.size();

  // make the matrix
  makeMatrix(list,listPlus,normal,A,faceNormal);

  Vector<Real> rhs(numRows);

  // x is the unknown
  Vector<Real> x(numCols);

  // make the rhs
  edgeMo edges[4];
  a_face.getEdges(edges);
  Real moment = 0.0;
  int rowIndex = -1;

  for (int exp = 0; exp < sizeBig; ++exp)
    {
      for (int j = 0; j < SpaceDim; j++)
        {
          edgeMo HiEdge;
          edgeMo LoEdge;

          // these little formulae chose which pair of
          // edges is appropriate. No doubt this could be done better
          if (j != faceNormal)
            {
              int low=-1;

              rowIndex += 1;

              if (faceNormal==0)
                {
                  low = j*j - j;
                }
              else if (faceNormal==1)
                {
                  low = j;
                }
              else if (faceNormal==2)
                {
                  low = j*j + j;
                }

              HiEdge = edges[low+1];
              LoEdge = edges[low];

              IntVect monomial = listPlus[exp];
              moment = HiEdge.moment(monomial) - LoEdge.moment(monomial);

              rhs[rowIndex] = moment;
            }
        }
    }

  LSquares whichMethod;
  whichMethod.LeastSquares(A,x,rhs);

  tools.freeArray(numRows,numCols,A);

  return x;
}

void  Moments::listOfMoments(const int&       a_order,
                             Vector<IntVect>& a_exponents)
{
  D_TERM(
  for (int i = 0; i <= a_order; ++i),
    for (int j = 0; j <= a_order; ++j),
      for (int k = 0; k <= a_order; ++k))
        if (D_TERM(i,+j,+k) == a_order)
          {
            IntVect newexp(D_DECL(i,j,k));
            a_exponents.push_back(newexp);
          }
}

void Moments::makeMatrix(const Vector<IntVect>& a_list,
                         const Vector<IntVect>& a_listPlus,
                         const Vector<Real>&    a_normalVec,
                         Real**                 a_A,
                         const int&             a_faceNormal)
{
  int faceNormal; // default argument is
  // absent in SpaceDim = 2 or for a (fully) 3D matrix
  // fully means not merely a 2D face in SpaceDim = 3
  if (SpaceDim == 2)
    {
      faceNormal = 2;
    }
  else
    {
      faceNormal = a_faceNormal;
    }

  int sizeBig = a_listPlus.size();
  int sizeSmall = a_list.size();
  int offset = sizeSmall;
  int rowIndex = -1;
  int vecIndex; // normalVec might only have two components

  for (int i = 0; i < sizeBig; ++i)
    {
      IntVect F = a_listPlus[i];
      for (int j = 0; j < SpaceDim; ++j)
        {
          if (faceNormal == 999)
            {
              vecIndex = j;
            }
          else
            {
              // this gives vecIndex = 0 or 1
              vecIndex = (j*j*(1-faceNormal) + j*(2*faceNormal-1)) / 2;
            }

          if (j != faceNormal)
            {
              int whichCol;

              rowIndex += 1;
              Real coeff = 0.0;

              if (F[j] > 0)
                {
                  IntVect DivF = F;
                  DivF[j] -= 1;

                  for (int counter = 0; counter < sizeSmall; ++counter)
                    {
                      if (DivF == a_list[counter])
                        {
                          whichCol = counter;
                        }
                    } // this should work as long as there are no duplicates in a_list
                  coeff = F[j];
                  a_A[rowIndex][whichCol] = coeff;
                }

              a_A[rowIndex][offset+i] = a_normalVec[vecIndex];
            }
        }
    }
}
#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "IFSlicer.H"

#include "NamespaceHeader.H"

// empty constructor (dim == GLOBALDIM)
IFSlicer<GLOBALDIM>::IFSlicer()
{
  m_implicitFunction = NULL;
}

//copy constructor
IFSlicer<GLOBALDIM>::IFSlicer(const IFSlicer<GLOBALDIM> & a_IFSlicer)
{
  m_implicitFunction = a_IFSlicer.m_implicitFunction->newImplicitFunction();
}

// constructor (dim == GLOBALDIM)
IFSlicer<GLOBALDIM>::IFSlicer(const BaseIF & a_implicitFunction)
{
  m_implicitFunction = a_implicitFunction.newImplicitFunction();
}

// Destructor (dim == GLOBALDIM)
IFSlicer<GLOBALDIM>::~IFSlicer()
{
  if (m_implicitFunction != NULL)
    {
      delete m_implicitFunction;
    }
}

Real IFSlicer<GLOBALDIM>::value(const IndexTM<int, GLOBALDIM> & a_partialDerivative,
                                const IndexTM<Real,GLOBALDIM> & a_point) const
{
  return m_implicitFunction->value(a_partialDerivative,a_point);
}

void IFSlicer<GLOBALDIM>::print(ostream& a_out) const
{
  MayDay::Abort("Not implemented");
  // m_implicitFunction->print(a_out);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "TorusIF.H"

#include "NamespaceHeader.H"

TorusIF::TorusIF(const Real&     a_majorRadius,
                 const Real&     a_minorRadius,
                 const RealVect& a_center,
                 const bool&     a_inside)
{
  // Remember parameters
  m_majorRadius = a_majorRadius;
  m_minorRadius = a_minorRadius;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the minor radius squared
  m_minorRadius2 = m_minorRadius * m_minorRadius;
}

TorusIF::TorusIF(const TorusIF& a_inputIF)
{
  // Remember parameters
  m_majorRadius = a_inputIF.m_majorRadius;
  m_minorRadius = a_inputIF.m_minorRadius;
  m_center = a_inputIF.m_center;
  m_inside = a_inputIF.m_inside;

  // Precompute the minor radius squared
  m_minorRadius2 = m_minorRadius * m_minorRadius;
}

TorusIF::~TorusIF()
{
}

void TorusIF::GetParams(Real&     a_majorRadius,
                        Real&     a_minorRadius,
                        RealVect& a_center,
                        bool&     a_inside) const
{
  // Copy parameter information over
  a_majorRadius = m_majorRadius;
  a_minorRadius = m_minorRadius;
  a_center = m_center;
  a_inside = m_inside;
}

void TorusIF::SetParams(const Real&     a_majorRadius,
                        const Real&     a_minorRadius,
                        const RealVect& a_center,
                        const bool&     a_inside)
{
  // Set parameter information
  m_majorRadius = a_majorRadius;
  m_minorRadius = a_minorRadius;
  m_center = a_center;
  m_inside = a_inside;

  // Precompute the minor radius squared
  m_minorRadius2 = m_minorRadius * m_minorRadius;
}

Real TorusIF::value(const RealVect& a_point) const
{
  Real retval;

  // Get the radius of a_point (excluding the z coordinate in 3D)
  Real radius1;

  radius1 = 0.0;
  for (int idir = 0; idir < 2; idir++)
  {
    Real cur;
    cur = a_point[idir] - m_center[idir];

    radius1 += cur*cur;
  }

  // Move to the center of the minor circle
  radius1 = sqrt(radius1) - m_majorRadius;

  // Get the radius squared in this coordinate system
  Real radius2;

  radius2 = radius1*radius1;
  for (int idir = 2; idir < SpaceDim; idir++)
  {
    Real cur;
    cur = a_point[idir] - m_center[idir];

    radius2 += cur*cur;
  }

  // Return the difference between the squares (zero on the torus)
  retval = radius2 - m_minorRadius2;

  // Change the sign to change inside to outside
  if (!m_inside)
  {
    retval = -retval;
  }

  return retval;
}

BaseIF* TorusIF::newImplicitFunction() const
{
  TorusIF* torusPtr = new TorusIF(m_majorRadius,
                                  m_minorRadius,
                                  m_center,
                                  m_inside);

  return static_cast<BaseIF*>(torusPtr);
}

#include "NamespaceFooter.H"
#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#include "SphereArrayIF.H"

#include "NamespaceHeader.H"

SphereArrayIF::SphereArrayIF(const Real&     a_radius,
                             const RealVect& a_firstCenter,
                             const RealVect& a_spacing)
{
  // Remember the parameters
  m_radius = a_radius;
  m_firstCenter = a_firstCenter;
  m_spacing = a_spacing;

  // Precompute the radius squared
  m_radius2 = m_radius * m_radius;
}

SphereArrayIF::SphereArrayIF(const SphereArrayIF& a_inputIF)
{
  // Remember the parameters
  m_radius      = a_inputIF.m_radius;
  CH_assert(m_radius > 0);
  m_firstCenter = a_inputIF.m_firstCenter;
  m_spacing     = a_inputIF.m_spacing;
  for (int idir = 0; idir < SpaceDim; idir++)
    {
      if (m_spacing[idir] < 2.5*m_radius)
        {
          MayDay::Abort("SphereArrayIF: spheres too close");
        }
    }
  // Precompute the radius squared
  m_radius2 = m_radius * m_radius;
}

SphereArrayIF::~SphereArrayIF()
{
}

Real SphereArrayIF::value(const RealVect& a_point) const
{
  //compute which center we are closest to
  RealVect dist = a_point;
  dist -= m_firstCenter;
  dist /= m_spacing;
  //make distance integer numbers in all directions
  for (int idir = 0; idir < SpaceDim; idir++)
    {
      dist[idir] = rint(dist[idir]);
    }
  //now multiply the distance by the spacing and add it to the firstCenter;
  dist *= m_spacing;
  RealVect center = m_firstCenter;
  center += dist;

  // The distance squared for m_center to a_point
  Real distance2;

  // Compute the distance squared
  distance2 = 0.0;
  for (int idir = 0; idir < SpaceDim; idir++)
  {
    Real cur;
    cur = a_point[idir] - center[idir];

    distance2 += cur*cur;
  }

  // Return the difference between the sqaures (zero on the sphere)
  Real retval = m_radius2 - distance2;

  return retval;
}
                                                       //
BaseIF* SphereArrayIF::newImplicitFunction() const
{
  SphereArrayIF* spherePtr = new SphereArrayIF(m_radius,
                                               m_firstCenter,
                                               m_spacing);

  return static_cast<BaseIF*>(spherePtr);
}

GeometryService::InOut SphereArrayIF::InsideOutside(const RealVect& a_low,
                                                    const RealVect& a_high) const
{
  RealVect lo(a_low);
  RealVect hi(a_high);


  lo-=m_firstCenter;
  hi-=m_firstCenter;

  // first, find nearst spheres to hi and lo
  IntVect nearestLo, nearestHi;
  bool differByTwo = true;
  for (int i=0; i<CH_SPACEDIM; ++i)
    {
      nearestLo[i] = (int)(lo[i]/m_spacing[i]);
      nearestHi[i] = (int)(hi[i]/m_spacing[i]);
      if ( nearestHi[i] - nearestLo[i] <= 1 ) differByTwo = false;
    }
  if (differByTwo)
    {
      return GeometryService::Irregular;
    }

  nearestLo-=IntVect::Unit;
  nearestHi+=IntVect::Unit;
  Box near(nearestLo, nearestHi);
  BoxIterator n(near);

  for (n.reset(); n.ok(); ++n)
  {
    Real dmin = 0;
    Real dmax = 0;
    Real ai, bi, a, b, c;
    for (int i=0; i<CH_SPACEDIM; ++i)
      {
        c = n()[i]*m_spacing[i];
        ai= c-lo[i];
        bi= c-hi[i];
        a = ai*ai;
        b = bi*bi;
        dmax = dmax + Max(a,b);
        if (c<lo[i] || c> hi[i]) dmin = dmin + Min(a,b);
      }
    if (dmax < m_radius2)
      {
        return GeometryService::Covered;
      }
    if (dmin <= m_radius2 && dmax >= m_radius2) return GeometryService::Irregular;
  }

  return GeometryService::Regular;

}

#include "NamespaceFooter.H"
